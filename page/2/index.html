<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:type" content="website">
<meta property="og:title" content="icestrawberryxjw">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="icestrawberryxjw">
<meta property="og:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="icestrawberryxjw">
<meta name="twitter:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>icestrawberryxjw</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">icestrawberryxjw</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/ip-conf-file-inconsistency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/ip-conf-file-inconsistency/" itemprop="url">解决Centos网卡IP和配置文件不符的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T22:15:45+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月9日所写，未经允许不得转载。</p>
<p>昨天发现连不上自己的服务器了，以为是网卡没起来或者网线被别人重插了，后来看了一下发现网卡起来了，ip也配的是对的，再ifconfig下，发现居然网卡em1用的是网卡em2的配置文件。如图：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060901.png" alt="2018060901"></p>
<p>并且，修改em2的配置文件中的ip，em1会相应变化，推测em1和em2互用了对方的配置文件= =。</p>
<p>使用nmcli查看，确实如此：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060902.png" alt="2018060902"></p>
<p>在别的正常的服务器上，是这样的：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060903.png" alt="2018060903"></p>
<p><strong>验证了我的猜测，下面是解决方案：</strong></p>
<p>Red Hat Enterprise Linux 7 与 CentOS 7 中默认的网络服务由 NetworkManager 提供，这是动态控制及配置网络的守护进程，它用于保持当前网络设备及连接处于工作状态，同时也支持传统的 ifcfg 类型的配置文件。可以用<strong>命令行工具 nmcli</strong> 来控制 NetworkManager，相应的也有一个<strong>图形化的配置工具nmtui</strong>。</p>
<p>NetworkManager 可以用于以下类型的连接：Ethernet，VLANS，Bridges，Bonds，Teams，Wi-Fi，mobile boradband（如移动3G）以及 IP-over-InfiniBand。针对与这些网络类型，NetworkManager 可以配置他们的网络别名，IP 地址，静态路由，DNS，VPN连接以及很多其它的特殊参数。 </p>
<p><strong>一些Network Manager中的概念：</strong></p>
<ul>
<li>device叫网络接口，是物理设备</li>
<li>connection是连接，偏重于逻辑设置</li>
<li>多个connection可以应用到同一个device，但同一时间只能启用其中一个connection。这样的好处是针对一个网络接口，我们可以设置多个网络连接，比如静态IP和动态IP，再根据需要up相应的connection。</li>
</ul>
<p><strong>nmcli的具体用法可以参考manpage，下面是常用命令（单词可以不写全，比如connection写成con）：</strong></p>
<ol>
<li><p>nmcli modifiy命令修改网卡的具体配置，实际上编辑的是<code>/etc/sysconfig/network-scripts/ifcfg-*</code>文件。在不想使用该文件时，可以通过delete删除对应的连接：<code>nmcli connection delete ens3</code>。默认情况下通过nmcli add 或 modify的操作只是修改了配置文件，并不会立即生效，想要生效启用，需要通过“nmcli conn up 接口名” 来启用对应的配置。 </p>
</li>
<li><p><code>nmcli -p con up em1 ifname em1</code>修改设备连接的配置文件，<strong>只用这个来修改网卡使用的配置文件的话重启网卡之后就会无效！</strong>因为默认的网卡和配置文件之间的连接没有删除。</p>
</li>
<li><p><code>nmcli -p connection show &quot;em1&quot;</code> 显示em1连接配置集详情 </p>
</li>
<li><p><code>nmcli -p -m multiline -f all con show</code> 显示NetworkManager 连接配置集</p>
</li>
<li><p><code>nmcli -f name,autoconnect c s</code></p>
</li>
<li><p><code>nmcli connection show</code>查看当前的连接，terminal里未启用的是黄色，启用的是绿色。</p>
</li>
<li><p><code>nmcli connection show --active</code>仅查看活跃连接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# nmcli connection show --active</div><div class="line">名称    UUID                                  类型            设备   </div><div class="line">em2     c67732e2-be50-4589-ad40-4537da423795  802-3-ethernet  em1    </div><div class="line">virbr0  4c0b2e32-9e55-472f-8693-03fda6c95847  bridge          virbr0`</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="解决步骤："><a href="#解决步骤：" class="headerlink" title="解决步骤："></a><strong>解决步骤</strong>：</h3><p>一开始以为网卡的配置是单纯找对应网卡名称的配置文件，现在才知道是将网卡设备和逻辑接口连接起来，然后使用逻辑接口的配置文件。</p>
<p>首先使用<code>nmcli connection delete CONNECTION_NAME</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection delete em2     //把网卡em1和配置文件ifcfg-em2的连接断开</div></pre></td></tr></table></figure>
<p>下一步，把网卡em1和接口em1匹配起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection add ifname em1 con-name em1 type ethernet //建立网卡em1和逻辑接口em1的连接</div></pre></td></tr></table></figure>
<p>然后，使用<code>nmcli connection show</code>就可以看到增加了一条连接信息，显示黄色说明还没有启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nmcli connection delete be36eaf2011de-43ab-9ff6-58b32796a444 //删掉下图绿色下面一行的未启动的网卡em2和逻辑接口em1的连接</div><div class="line">nmcli connection add ifname em2 con-name em2 type ethernet //建立网卡em2和逻辑接口em2的连接</div></pre></td></tr></table></figure>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060904.jpg" alt="2018060904"></p>
<p>但是，因为刚刚建立网卡em1和逻辑接口em1的时候，网卡em2和逻辑接口em1的连接还没删除，所以在/etc/sysconfig/network-scripts里面会出现ifcfg-em1-1，把文件名改成ifcfg-em1，需要在里面配置好静态ip、网关等信息然后保存。</p>
<p>再次用<code>nmcli connection show</code>查看，发现网卡em1和逻辑接口em1连接了，网卡em2和逻辑接口em2连接了，原来的连接断开了。但是em1的连接没有启用（红色）。</p>
<p>用nmtui编辑连接后，ifcfg文件也会有相应的改动；手工修改ifcfg后，nmtui中也能看到。<br>但是，<strong>不论用nmtui还是直接修改ifcfg文件，想让新的配置生效，需要load连接配置文件并重新up连接。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nmcli con load /etc/sysconfig/network-scripts/ifcfg-em1</div><div class="line">nmcli con load /etc/sysconfig/network-scripts/ifcfg-em2</div><div class="line">nmcli con up em1</div></pre></td></tr></table></figure>
<p>再次用<code>nmcli connection show</code>查看，发现网卡em1和逻辑接口em1连接启用了（显示绿色）</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060905.jpg" alt="2018060905"></p>
<p>服务器重启之后，配置依然有效，至此解决。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cnblogs.com/panblack/p/Centos7-WhatsNew-02-networking.html" target="_blank" rel="external">https://www.cnblogs.com/panblack/p/Centos7-WhatsNew-02-networking.html</a></li>
<li>nmcli(1) Linux man page</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/promiscuous-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/promiscuous-mode/" itemprop="url">关于网卡的混杂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T22:13:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月9日所写，未经允许不得转载。</p>
<p>tcpdump的一个副作用就是可以让网卡进入混杂模式。每次tcpdump，都会在/var/log/messages里看到这样：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060907.png" alt="2018060907"></p>
<p>实际上，网卡是否处于PROMISC模式，ifconfig（ip link show也是如此）并不是最直接的判断依据，换句话说就是ifconfig能看到PROMISC标记表示一定处于混杂模式，但处于混杂模式并不一定能看到PROMISC标记。内核判断网卡是否处于混杂模式是看<code>/sys/class/net/ifname/flags</code>的值，如果置位了0x100，则处于混杂模式。</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060906.png" alt="2018060906"></p>
<ul>
<li><strong>混杂模式的ifconfig和ip link show都按看不到的问题</strong></li>
</ul>
<p><a href="http://seclists.org/bugtraq/2002/Jul/302有这样的解释" target="_blank" rel="external">http://seclists.org/bugtraq/2002/Jul/302有这样的解释</a></p>
<blockquote>
<p>This is a well knwon issue and C. Grenier and I have understood why<br>very recently. In fact, this due to the changing of the handling of<br>promiscuous mode in kernel space.</p>
<p>With kernel 2.0, one had to perform the following to set the interface<br>to promiscuous mode:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">strncpy</span>(ifr.ifr_name, <span class="string">"eth0"</span>, IFNAMSIZ);</div><div class="line">&gt; ioctl(sock, SIOCGIFFLAGS, &amp;ifr);</div><div class="line">&gt; ifr.ifr_flags |= IFF_PROMISC;</div><div class="line">&gt; ioctl(sock, SIOCSIFFLAGS, &amp;ifr);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The trouble was that the promiscuous mode was handled by a flag.  Each<br>time a process sets this mode, the flag is set. But if another process<br>removes this mode, the flag is cleared. Rather bad behavior.</p>
<p>Since kernel 2.2, a processus must ask to enter in a membership of<br>process (setsockopt(…, PACKET_ADD_MEMBERSHIP,…)) using the<br>interface in promiscuous mode. A counter is then increased. One a<br>process of the membership does not need the promiscuous mode anymore,<br>it drops the membership (setsockopt(…, PACKET_DROP_MEMBERSHIP, …))<br>the counter is decreased, and promiscuous mode is disabled as soon as<br>the counter is 0. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq</span> <span class="title">mr</span>;</span></div><div class="line">&gt; ...</div><div class="line">&gt; <span class="built_in">memset</span>(mr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mr));</div><div class="line">&gt; mr.mr_ifindex = ifr.ifr_ifindex;</div><div class="line">&gt; mr.mr_type =  PACKET_MR_PROMISC;</div><div class="line">&gt; setsockopt(sock, SOL_PACKET, PACKET_ADD_MEMBERSHIP, (<span class="keyword">char</span> *)&amp;mr, <span class="keyword">sizeof</span>(mr));</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The call to ioctl(SIOCGIFFLAGS) reports only promiscuous mode sets by<br>ioctl(SIOCSIFFLAGS).</p>
</blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://ieevee.com/tech/2016/11/24/promisc.html" target="_blank" rel="external">https://ieevee.com/tech/2016/11/24/promisc.html</a></li>
<li><a href="http://seclists.org/bugtraq/2002/Jul/302" target="_blank" rel="external">http://seclists.org/bugtraq/2002/Jul/302</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/CplusPrimerChapter9-mem-manage-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/CplusPrimerChapter9-mem-manage-note/" itemprop="url">C++内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T21:58:50+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ Primer Plus</em> 第九章的内存模型 笔记整理。—— Jiawei Xu 2019年3月6日</p>
<hr>
<p><strong>关键字：</strong>存储持续性、链接性、作用域、初始化、单定义规则、存储说明符（auto, register, static, extern, mutable, thread_local）、CV限定符（const, volatile）、名称修饰/矫正/C++语言链接性</p>
<h4 id="变量内存管理-存储持续性"><a href="#变量内存管理-存储持续性" class="headerlink" title="变量内存管理-存储持续性"></a>变量内存管理-存储持续性</h4><p>C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间。</p>
<ul>
<li><p><strong>自动存储持续性</strong>（栈）：</p>
<p>在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们的内存被释放。<strong>C++有两种存储持续性为自动的变量</strong>：局部变量和register关键字。</p>
</li>
<li><p><strong>静态存储持续性</strong>（全局变量/外部变量、static）：</p>
<p>在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为<strong>静态</strong>。它们在程序整个运行过程中都存在。</p>
<p><strong>C++有三种存储持续性为静态的变量</strong>，在整个程序执行期间存在，未被初始化的静态变量默认为0，静态数组和结果的每个元素和成员的所有位都置为0，这种变量被称为<strong>零初始化</strong>的(zero-initialized)：</p>
<ul>
<li><strong>外部链接性external linkage</strong>：可在其他文件中访问，格式：代码块外面声明</li>
<li><strong>内部链接性internal linkage</strong>：只能在当前文件中访问，格式：代码块外面声明+static限定符</li>
<li><strong>无连接性static linkage</strong>：只能在当前函数或代码块中访问，格式：代码块内声明+static限定符</li>
</ul>
</li>
<li><p><strong>动态存储持续性</strong>（堆/自由存储）：</p>
<p>用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的持续性为动态，有时候被称为自由存储(free store)或堆(heap)。</p>
</li>
<li><p><strong>线程存储持续性</strong>（C++11、并行编程、thread_local）</p>
<p>如果变量使用关键字<strong>thread_local</strong>声明的，则其生命周期与所属的线程一样长，并行编程的内容。thread_local之于线程，犹如常规静态变量之于整个程序。</p>
</li>
</ul>
<h4 id="链接性（linkage）"><a href="#链接性（linkage）" class="headerlink" title="链接性（linkage）"></a>链接性（linkage）</h4><p>描述了名称如何在不同单元间共享。链接性在外部的名称可在文件间共享，链接性在内部的名称只能由一个文件中的函数共享。</p>
<h4 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h4><p>文件作用域（作用域为全局）：从定义位置到文件结尾之间可用。</p>
<p>局部作用域（自动变量，automatic variable）：局部。</p>
<p>静态变量的作用域：全局还是局部取决于如何被定义。</p>
<p>函数原型作用域(function prototype scope)中使用的名称只在包含参数列表的括号内可用。</p>
<p>类中声明的成员的作用域：整个类。</p>
<p>在名称空间中声明的变量的作用域为整个名称空间，全局作用域是名称空间作用域的特例。</p>
<h4 id="Auto"><a href="#Auto" class="headerlink" title="Auto"></a>Auto</h4><p>C和C++11之前，用于显式地指出变量为自动存储</p>
<p>C++11中，用于自动类型推断</p>
<h4 id="寄存器变量Register"><a href="#寄存器变量Register" class="headerlink" title="寄存器变量Register"></a>寄存器变量Register</h4><p>C和C++11之前，建议编译器使用CPU寄存器来存储自动变量，旨在提高访问变量的速度；</p>
<p>C++11中，用于显式地指出变量是自动的，作用域为代码块，在代码块中声明，无链接性。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li><p>静态初始化=零初始化+常量表达式初始化（sizeof运算符也包括）</p>
<p>在编译器处理文件时初始化</p>
</li>
<li><p>动态初始化：</p>
<p>在编译后初始化</p>
</li>
<li><p>C++新增关键字constexpr</p>
<p>创建常量表达式的方式</p>
</li>
</ul>
<h4 id="外部-全局变量的C-单定义规则-One-Definition-Rule-ODR"><a href="#外部-全局变量的C-单定义规则-One-Definition-Rule-ODR" class="headerlink" title="外部/全局变量的C++单定义规则(One Definition Rule, ODR)"></a>外部/全局变量的C++单定义规则(One Definition Rule, ODR)</h4><p><strong>外部变量</strong>：链接性为外部的变量，存储持续性为静态，作用域为整个文件。也称全局变量。</p>
<p>如果要在多个文件中使用外部变量，只需要在一个文件里包含定义，但是其他文件使用的时候都要用extern声明。</p>
<p>两种外部变量声明的方式：</p>
<ul>
<li><p>定义声明/定义defining declaring/definition（给变量分配存储空间）</p>
</li>
<li><p>引用申明/声明 referencing declaration/declaration（不给变量分配存储空间）</p>
<p>方法：在变量前面用<strong>关键字extern</strong>，且不进行初始化（两个条件都要满足，否则声明为定义，会分配存储空间）</p>
<p><strong>C++中的作用域解析运算符(::)</strong>：放在变量名前，该运算符表示使用变量的全局版本（更安全，不依赖于作用域）</p>
</li>
</ul>
<p>在多文件程序中，可以在一个文件（且只能在一个文件）定义一个外部变量，使用它的其他文件必须使用关键字extern声明它。</p>
<h4 id="存储说明符"><a href="#存储说明符" class="headerlink" title="存储说明符"></a>存储说明符</h4><ul>
<li>auto（C++11之后不再是说明符）</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>thread_local（C++11新增）</li>
<li>mutable：即使结构（或类）变量为const，其某个成员也可以被修改，</li>
</ul>
<h4 id="CV-限定符"><a href="#CV-限定符" class="headerlink" title="CV-限定符"></a>CV-限定符</h4><ul>
<li>const：在C++中，const限定符对默认存储类型有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。<ul>
<li>在C++下，全局const定义就像是使用了static说明符一样。</li>
<li>可以使用extern关键字覆盖默认的内部链接性<code>extern const int states=50;</code>，鉴于单个const在多个文件间共享，因此只有一个文件可对其进行初始化。</li>
<li>在函数或代码块中声明const时，作用域为代码块。</li>
</ul>
</li>
<li>volatile：即使程序代码没有对内存单元进行修改，其值也可能发生变化。作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile。则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器不要进行这种优化。</li>
</ul>
<h4 id="函数链接性"><a href="#函数链接性" class="headerlink" title="函数链接性"></a>函数链接性</h4><ul>
<li><p>所有函数的存储持续性都自动为静态的。默认情况下，函数的链接性为外部的，可以在文件间共享。、</p>
</li>
<li><p>可以使用static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字。于是，可以在其他文件中定义同名的函数，和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义。</p>
</li>
<li>单定义规则也适用于非内联函数，对于每个非内联函数，程序只能包含一个定义。对于链接性为外部的函数来说，多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。</li>
</ul>
<h4 id="C-查找函数定义的顺序"><a href="#C-查找函数定义的顺序" class="headerlink" title="C++查找函数定义的顺序"></a>C++查找函数定义的顺序</h4><ul>
<li>静态函数：本文件</li>
<li>所有程序文件-&gt;没找到的话，在库中搜索</li>
</ul>
<h4 id="名称矫正-名称修饰-C-语言链接"><a href="#名称矫正-名称修饰-C-语言链接" class="headerlink" title="名称矫正/名称修饰/C++语言链接"></a>名称矫正/名称修饰/C++语言链接</h4><p>在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称，这种方法被称为C++语言链接（C++ language linkage）。方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; void spiff(int)  //使用C语言链接性</div><div class="line">extern void spiff(int) 		//使用C++语言链接性</div><div class="line">extern &quot;C++&quot; void spiff(int) 		//使用C++语言链接性</div></pre></td></tr></table></figure>
<h4 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h4><p>含义：使用C++运算符new(或C函数malloc())分配的内存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/FreeFlow-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/FreeFlow-note/" itemprop="url">FreeFlow Software-based Virtual RDMA Networking for Containerized Clouds(NSDI 2019)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T20:29:43+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/科研论文笔记/" itemprop="url" rel="index">
                    <span itemprop="name">科研论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年2月25日所写，未经允许不得转载。</p>
<h3 id="概述-主要成果"><a href="#概述-主要成果" class="headerlink" title="概述-主要成果"></a>概述-主要成果</h3><ol>
<li>容器的优点：large-scale cloud applications, high resource efficiency, lightweight isolation。RDMA的优点：data-intensive applications, high networking performance, high throughput, low latency, low CPU utilization。</li>
<li>FreeFlow是一个software-based RDMA virtualization framework designed for containerized clouds.</li>
<li>FreeFlow满足云环境下的一些要求，例如多租户隔离，容器迁移的可移植性。</li>
<li>FreeFlow对应用透明，提供几乎裸金属RDMA的网络性能，同时CPU overhead不大。</li>
<li>Application代码修改很少 。FreeFlow在TensorFlow和Spark上测试，提供了和裸金属RDMA媲美的应用程序性能。</li>
<li>boost the performancee of real-world applications by up to 14.6 times more in throughput and about 98% lower in latency over using conventional TCP/IP virtual networking. </li>
<li>开源：<a href="https://github.com/Microsoft/Freeflow" target="_blank" rel="external">https://github.com/Microsoft/Freeflow</a></li>
</ol>
<h3 id="容器云的three-properties-in-networking"><a href="#容器云的three-properties-in-networking" class="headerlink" title="容器云的three properties in networking"></a>容器云的three properties in networking</h3><ol>
<li>Isolation：每个容器都有独立的网络命名空间，包括端口、流表、接口。</li>
<li>Portability：每个容器必须使用虚拟网络来和其他容器交互，它的虚拟IP是固定的，不管宿主机是哪个。 </li>
<li>Controllability：Orchestrators can easily enforce control plane policies 控制平面规则（比如访问控制admission control, routing）和data plane policies数据平面规则（比如QoS, metering计量），这个特性在多租户云环境尤其需要。</li>
</ol>
<p>In TCP/IP-based operations, network- ing is fully virtualized via a software (virtual) switch.</p>
<h3 id="解决问题时的Challenge"><a href="#解决问题时的Challenge" class="headerlink" title="解决问题时的Challenge"></a>解决问题时的Challenge</h3><p>很难完全虚拟化基于RDMA的网络传输。 </p>
<p>It is difficult to modify the control plane states (e.g., routes) in hardware in shared cloud environments, while it is also hard to control the data path since traffic directly goes between RAM and NIC via PCIe bus. 控制平面状态如路由等在硬件上难修改，数据平面流量走RAM和NIC。</p>
<h3 id="Goal-of-the-paper"><a href="#Goal-of-the-paper" class="headerlink" title="Goal of the paper"></a>Goal of the paper</h3><blockquote>
<p>We want cloudbased, containerized applications to be able to use RDMA as efficiently as they would in a dedicated bare-metal cluster; while at the same time achieving the isolation, portability and controllability requirements in containerized clouds.</p>
<p>The goal of FreeFlow is to <strong>provide an virtual interface inside</strong> <strong>each container</strong>, and applications can use RDMA via a virtual network on top of the virtual interface in an unmodified way.</p>
</blockquote>
<p>总结来说就是面向容器的基于软件的RDMA虚拟化 </p>
<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>Currently, there is no mature RDMA virtualization solutions for containers. </p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic1.jpg" alt="RDMA networking solutions that can be potentially used for containers."></p>
<p><strong>现有工作的缺点：</strong> </p>
<ol>
<li><p><strong>基于硬件的I/0虚拟化技术</strong></p>
<blockquote>
<p>Hardware-based I/O virtualization techniques like <strong>SR-IOV</strong> have fundamental portability limitations, since they require reconfiguration of hardware NICs and switches to support migrations of containers. </p>
</blockquote>
</li>
<li><p><strong>控制路径虚拟化解决方案</strong></p>
<blockquote>
<p>Control path virtualization solutions, such as <strong>HyV</strong>, only manipulate the control plane commands for isolation and portability, and they do not have the visibility or control of the data traffic. Because of this, they cannot flexibly support data plane policies needed by cloud providers. </p>
</blockquote>
</li>
<li><p><strong>软件RDMA</strong></p>
<blockquote>
<p>Software-emulated RDMA, e.g., <strong>SoftRoCE</strong>, can easily achieve isolation, portability, and controllability by running RDMA on top of the UDP networking stack and use existing virtual IP networking solutions, but its performance will be limited by UDP. </p>
</blockquote>
</li>
</ol>
<h3 id="FreeFlow设计思路"><a href="#FreeFlow设计思路" class="headerlink" title="FreeFlow设计思路"></a>FreeFlow设计思路</h3><p><strong>技术核心：每个server上都有一个软件虚拟交换机，类似于TCP/IP的VSwitch</strong></p>
<blockquote>
<p>The software virtual switch has the full access to both control path (e.g., address, routing) and data path (e.g., data traffic) of the communications among containers. This design philosophy is similar to existing software virtual switches used for TCP/IP networking in the containerized cloud.</p>
</blockquote>
<p><strong>设计时考虑的两点：</strong> </p>
<ol>
<li><p><strong>透明性 (设计：应用程序和FreeFlow共享内存和文件描述符+尽量少修改应用程序的代码)</strong></p>
<blockquote>
<p><strong>We want FreeFlow to be completed transparent to applications</strong>.  If FreeFlow and a container share the same memory (x4.3) and file descriptor (x4.4), any operations on the underlying physical RDMA NIC will automatically take effect inside the container. </p>
<p><strong>A further problem is that sharing resources transparently to applications is not straightforward,</strong> given that applications do not cooperatively create resources that are shareable. Wedesign methods to convert resource from non-shareable to shareable with no or minimal modifications on application code.</p>
</blockquote>
</li>
<li><p><strong>性能要求（throughput：利用零拷贝，latency：CPU自旋的共享内存进程间channel+限制CPU开销）</strong></p>
<p>提供和裸金属RDMA媲美的吞吐和延迟，吞吐的瓶颈是内存拷贝，延时的瓶颈但是inter-process communication. </p>
</li>
</ol>
<p><strong>Evaluation tools:</strong> </p>
<ul>
<li>standard microbenchmarking tools</li>
<li>real-world data-intensive applications（without any or with minimal modification）<ul>
<li>Spark</li>
<li>TensorFlow</li>
</ul>
</li>
</ul>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><h4 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h4><ol>
<li><p>host mode networking</p>
<p>容器使用宿主机的IP和端口空间，像host OS里的原始进程一样通信。</p>
<p>poor isolation（e.g.,端口冲突）and portability（e.g.,迁移到另一个主机之后必须改IP和端口）</p>
</li>
<li><p>virtual mode networking </p>
<p>namespace完全隔离，容器之间通过overlay网络的软件vSwitch通信。Orchestrators可以完全控制容器迁移，可以实施控制平面和数据平面的策略。</p>
<blockquote>
<p>Indeed, orchestrators like <strong><em>Kubernetes</em></strong> mandate the use of virtual networking mode. A number of software solutions are available to provide virtual networking fabrics for containers, such as <strong><em>Weave</em></strong>, and <strong><em>Docker Overlay</em></strong>.</p>
</blockquote>
</li>
</ol>
<h4 id="Approach-to-virtualize-RDMA-network"><a href="#Approach-to-virtualize-RDMA-network" class="headerlink" title="Approach to virtualize RDMA network"></a>Approach to virtualize RDMA network</h4><blockquote>
<p>One possible approach：the NIC runs a simple layer-2 switch</p>
<p>Use hardware-based solutions such as SR-IOV. As an example shown in Figure 1(a), <strong>with SRIOV, the NIC runs a simple layer-2 switch that merely performs VLAN forwarding</strong>. Hence, all packets generated from and destined to a virtual network have to be directly routed in the underlying physical network. Thus, migrating container C1 to Host2 requires <strong>reconfiguring the physical switch</strong> to route C1’s packets to Host2 rather than Host1.  </p>
<p>缺点： 1) 影响可移植性，迁移需要重新并配置, 2) physical sw需要维护很大一张路由表 </p>
</blockquote>
<p><strong><em>The right approach to virtualizing RDMA network for containers：use a software switch – just like it is done for virtualizing traditional TCP/IP networking.</em></strong></p>
<p>虚拟化RDMA网络的方式使用软件sw，虚拟网络路由完全每个主机里的软件switches实现，physical network只负责把数据包发给不同的主机。软件sw可以提供好的隔离和控制平面的可移植性。也可以用来实现数据平面的网络功能比如QoS和metering计量。</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic2.jpg" alt=""></p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic3.jpg" alt=""></p>
<ol>
<li><p><strong>software FreeFlow router也是一个主机上的容器</strong> </p>
<p>FreeFlow intercepts the communication between applications and physical NICs, and performs control plane and data plane policies inside the software FreeFlow router which runs as another container on the host machine. </p>
</li>
<li><p><strong>router和应用程序共享内存</strong></p>
<p>数据层面上，物理网卡访问router的内存，因为容器和router的内存是同一块物理内存，所以网卡能够直接访问应用程序的内存。</p>
</li>
</ol>
<h3 id="RDMA-API选择"><a href="#RDMA-API选择" class="headerlink" title="RDMA API选择"></a>RDMA API选择</h3><p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic5.png" alt=""></p>
<blockquote>
<p><strong>MPI</strong></p>
<p><strong>Message Passing Interface</strong> is a library specification that enables the development of paral- lel software libraries to utilize parallel computers, clusters, and heterogeneous networks. Mella- nox OFED includes the following MPI implementation over InfiniBand: </p>
<p>Open MPI – an open source MPI-2 implementation by the Open MPI Project </p>
<p>Mellanox OFED also includes MPI benchmark tests such as OSU BW/LAT, Intel MPI Bench- mark, and Presta. </p>
<p><strong>SDP</strong></p>
<p>为了充分利用 RDMA 提供的所有优势，需要使用 RDMA 语义或上层协议，比如 User-Level Direct Access Transport (uDAPL) 或 Message Passing Interface (MPI) 来编写应用程序。然而，对于 RDMA 来说，重写一个 TCP 应用程序可能非常昂贵，因此，针对这种情况开发了一个替代解决方案。该方法称之为 Direct Socket Protocol (SDP)，无需重新编码任何应用程序。</p>
<p>SDP 是一个连线协议，在 RDMA 能力的适配器和套接字之间使用。鉴于这个原因，SDP 对应用程序是透明的，而标准流套接字的实现不需要使用另一个 API 替换。DB2 应用程序和 DB2 服务器无需修改就可在 SDP 或 TCP 上运行。用户只需要在执行应用程序之前通过预加载 SDP 共享库来选择要使用的协议即可。所有关于 TCP 的设置，比如主机名、IP 地址和端口，均无需修改。</p>
<p>例如，一个使用 TCP 连接到数据库服务器的 Java 应用程序也可以使用相同 JDBC URL 在 SDP 上运行。该 SDP 库，一旦预加载之后，将根据一组在 <code>/etc/libsdp.conf</code> 中定义的规则，以及服务器接受的协议来决定必需启动哪个协议。默认规则指定 SDP 作为第一个选项，如果连接失败，SDP 库将退回到 TCP。</p>
<p>一个应用程序可以只使用 SDP，或者只使用 TCP，或者同时使用二者。例如，可以将一个应用程序配置为使用 SDP 实现 DB2 数据库连接以及使用 TCP 实现 LDAP 连接。数据库和 LDAP 服务器可以在不同的物理机器上运行，或者运行在相同的机器上但侦听不同的接口。本文稍后将讨论各种场景以及如何应用规则。</p>
<p><strong>rocket</strong></p>
<p>include <rdma rsocket.h=""></rdma></p>
<p>rsockets is a protocol over RDMA that supports a socket-level API for applications. rsocket APIs are intended to match the behavior of corresponding socket calls, except where noted. rsocket functions match the name and function signature of socket calls, with the exception that all function calls are prefixed with an ‘r’.</p>
<p><strong>iSER(iSCSI RDMA Protocol)</strong></p>
</blockquote>
<p><strong>FreeFlow选择IB Verb API（Verbs）</strong>： The Verbs library and associated drivers allow applications to read, write and monitor the three queues. Actual transfer of the data, including packetization and error recovery, is handled by the NIC. To transparently support Verbs, FreeFlow <strong>creates virtual QPs and CQs in virtual NICs</strong> and relates the operations on them with operations on real QPs and CQs in the physical NICs.</p>
<h4 id="具体架构设计"><a href="#具体架构设计" class="headerlink" title="具体架构设计"></a>具体架构设计</h4><p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic6.png" alt="FreeFlow Architecture"></p>
<ul>
<li><p>FreeFlow network library (FFL)</p>
</li>
<li><p>FreeFlow software router (FFR)</p>
</li>
<li><p>FreeFlow network orchestrator (FFO).</p>
</li>
</ul>
<p>There are various types of RDMA operations including one- and two-sided operations for data transfer, poll- and event-based mechanisms for work completion notification, and TCP/IP and RDMA-CM for the connection establishment.</p>
<p>关于RDMA： </p>
<ol>
<li><p>The Verbs library and associated drivers allow applications to read, write and <strong>monitor</strong> the three queues. Verb libs有监控工具 </p>
</li>
<li><p>Actual transfer of the data, including packetization and error recovery, is handled by the NIC. 网卡负责实际的传输，包括 packetization和错误恢复 </p>
</li>
</ol>
<p>one-sided operations such as WRITE and READ</p>
<p>two-sided operations such as SEND and RECV </p>
<p>为了透明支持Verbs，FreeFlow建了虚拟的QP和CP和物理网卡上的真实QP和CP关联. </p>
<p>Step1: 应用请求支持Verbs的网卡列表，FFL截获了call然后返回容器的虚拟网卡的文本数据。 </p>
<p>Step2: 应用在它的的虚拟网卡上创建QP和CQ，FFR在物理网卡上创建相应的队列（QP和CQ’）。等到FFR完成了队列的创建了之后，QP-IDs和其他元数据信息通过FFL转发给应用。 </p>
<p>Step3: 应用注册了一块内存mem给QP。 FFR分配了相应的的块内存s-mem在它的共享内存IPC空间，和mem的空间一样大，注册s-mem给QP’ </p>
<p>FFR返回了它使用来创造s-mem的ID（一个IPC内存的主机范围的唯一名称）。FFL用这个ID来将s-mem和自己的虚拟内存空间映射起来。 </p>
<p>Step4: 应用请求local QP地址（RDMA的GID）。地址信息将会和另一边共享  local QP和remote QP配对。这一步最后，FFR返回QP’的实际的GID。 </p>
<p>Step5: 应用和远程交换GID和QP-ID。交换信息的通道是TCP/IP或者RDMA-CM。 </p>
<p>Step6：应用使用接受端的GID把它的local QP和远程容器的QP匹配起来。 </p>
<p>Step7：应用修改了local QP的状态，修改为Ready 、Send/Receive state。FFR相应修改QP’的状态。 </p>
<p>One-sided Operation </p>
<ul>
<li>Client需要server 的GID、远程内存buffer的地址，访问内存的security key。 </li>
<li>有两个挑战： <ul>
<li>目标的内存地址mem在远程的容器的虚拟内存里面。但是本地的FFR不知道对应的另一半的s-mem。解决方案：FreeFlow在FFO中为每个FFR建立一个中心化的key-value存储，来学习应用虚拟内存空间和对应FFR虚拟内存空间的s-mem指针。 </li>
<li>远程FFR不知道什么时候把数据拷贝到应用内存里面 </li>
</ul>
</li>
<li>基于零拷贝的机制来支持one-side operation：使得mem和s-mem是一段相同的物理内存，这样FFR不需要做任何拷贝，应用可以直接得到数据 <ul>
<li>第一种方法：写新的API，ibv_malloc和ibv_free来让应用代理内存的创造和删除，缺点是需要改动app的data buffer creation的代码 </li>
<li>第二种方法：FFL截断malloc call。FFL释放va的物理内存然后指定一个FFR的物理共享内存给va，但是va必须是一个内存整页的开头，会降低host的内存利用率 </li>
<li>更推荐第一种方法 </li>
</ul>
</li>
</ul>
<p>Event-based Operations </p>
<p>从CQ中获得通知的方法： </p>
<ol>
<li>应用定期poll CQ看有没有完成的operation </li>
<li>event-based的方法，应用创建一个事件channel，将CQ放进channel中。channel包含一个文件描述符（当opeartion完成时会引发）。 </li>
</ol>
<p>在FreeFlow中，因为raw file descriptor是物理网卡创建的，FFR需要把文件描述符传给FFL，这里FFR和FFL是共享OS kernel的两个进程. </p>
<p>FFL和FFR之间的通信： </p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic4.jpg" alt=""></p>
<p>低延时通信用FastPath： 用一个cpu core 自旋，数据平面无阻塞 </p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li><p>implement FFL by modifying <strong>libibverbs (v1.2.1), libmlx4 (v1.2.1) and librdmacm (v1.1.0)</strong>. </p>
</li>
<li><p>增加了4000 lines of C code to implement FreeFlow’s logic. </p>
</li>
<li><p>implemented FFR from scratch in about 2000 lines of C++ code.  </p>
</li>
<li><p>For FFO, use ZooKeeper to store the user defined information; e.g., IP assignment, access control, resource sharing policies, and memory mapping information for one-sided operations. </p>
</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1207rdmasocketdirect/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1207rdmasocketdirect/</a></li>
<li><a href="https://linux.die.net/man/7/rsocket" target="_blank" rel="external">https://linux.die.net/man/7/rsocket</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/18/RoGUE-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/RoGUE-note/" itemprop="url">RoGUE_RDMA over Generic Unconverged Ethernet(SoCC'18)笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-18T10:49:21+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/科研论文笔记/" itemprop="url" rel="index">
                    <span itemprop="name">科研论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年11月15日所写，未经允许不得转载。</p>
<h3 id="1-问题描述和论文概括"><a href="#1-问题描述和论文概括" class="headerlink" title="1. 问题描述和论文概括"></a>1. 问题描述和论文概括</h3><p>RDMA为用户态提供了直接访问、在应用程序的buffer中传输数据的能力。RDMA旁路了开销较高的系统调用，在硬件上进行组包和包解析操作。允许单向操作，凭借一边的连接可以在硬件上完全处理而不需要主机软件的参与。因此RDMA相比于TCP/IP网络提高了端到端的时延和CPU占用。</p>
<p>RNIC：RDMA网卡</p>
<p>PFC：使用backpressure-based congestion control来给RDMA提供无损网络。PFC是的交换机或者主机当他们的buffer占用超过一定的阀值产生pause frame，然后让发送方节流。有了PFC之后，丢包只会发生在少见的bit损坏上，RNIC就可以用简单的硬件重传方案来恢复。</p>
<p>RoCE的优势：低延迟、低CPU利用率，场景：DC云基础设施服务。</p>
<p>目前RoCE、FPC的缺点：影响网络稳定性、复杂的网络管理、HOL Blocking问题、设备故障和不正确的路由可能导致整个网络死锁、Bufferbloat问题、unfair packet scheduling。</p>
<p>关于FPC问题的相关进展：</p>
<ol>
<li><p>DCQCN缓解了一部分风险，但是没有完全解决这些问题。</p>
</li>
<li><p>最近的研究关于数据中心拥塞控制，DCQCN，缓解了PFC被唤醒的频率。但是还是有问题：从其接收队列停止读取的慢速或恶意主机可以生成暂停帧并拒绝其他租户访问网络。</p>
</li>
<li><p>深入的监控通过识别是否有这样的问题会发生来解决这个问题，但是监控是有限的、不准确的、不能大规模部署。</p>
</li>
</ol>
<p>和SIGCOMM’18的思路一样：不去修复以上这些问题，而是去掉RoCE中的PFC，用新的拥塞控制和新的拥塞导致的丢包恢复方案代替。</p>
<p>该论文提出的RoGUE（RDMA over Generic Unconverged Ethernet)的理念和贡献：不需要依靠PFC。重新思考RDMA拥塞控制和恢复机制，寻找一种保持低延时低CPU优点、但是还能够容忍由于拥塞导致的丢包的方式。（从降低能耗角度），并且增加了UC的丢包恢复。</p>
<h3 id="2-设计难点和挑战"><a href="#2-设计难点和挑战" class="headerlink" title="2. 设计难点和挑战"></a>2. 设计难点和挑战</h3><p>那么问题来了，在哪里和如何实现所想要的（拥塞控制）功能？</p>
<table>
<thead>
<tr>
<th></th>
<th>想法一</th>
<th>想法二</th>
</tr>
</thead>
<tbody>
<tr>
<td>在哪里实现</td>
<td>完全用RNIC硬件实现</td>
<td>完全用软件实现</td>
</tr>
<tr>
<td>pros</td>
<td>1、管理者，特别是本地或者私有云的小规模，不能依靠RNIC提供商来推行硬件改变，因此他们需要了解传统RNIC；大的云比如google和Microsoft可以和提供商推广自定义的交换机网卡特性比如结合了拥塞控制的改进，但是对于企业小中型私有数据中心和云。他们就只能用不灵活的通用的硬件。2、刻在硬件上的方法不能处理交换机上非标准协议实现，也不能处理交换机功能的升级或者端系统拥塞控制协议；3、不利于各种算法的快速实现应用，不利于向下兼容和网络升级。数据中心拥塞控制是快速发展的，每年都有一些新的拥塞控制算法提出来。在硬件上实现拥塞控制算法会降低阻碍这些新算法的应用。4、现有的RNIC丢包恢复机制是设计用来在低错包的情况下工作的。当时PFC关掉时，在有新建连接的burst时流丢包严重，但是RNIC硬件机制恢复这些丢包时效率很低，它花几百毫秒来检测丢包然后恢复。</td>
<td>1、基于包层面的拥塞信号对软件是透明的，传统方案利用的拥塞信号例如丢包和ECN比特都是被RNIC接收，软件无法得到；2、无差别的使用软件驱动的控制（比如使用软件来调整数据包速度使其达到一个合适的速率，或者识别和恢复丢包）会严重破坏RDMA cpu和时延的效益；</td>
</tr>
<tr>
<td>cons</td>
<td>低时延、低CPU利用率、性能高</td>
<td>易于实现</td>
</tr>
</tbody>
</table>
<p>子结论一：需要平衡好硬件和软件的工作范围</p>
<p>RoGUE的实现方式：OpenFabrics Enterprise Distribution(OFED) 用户层面API之上一个中介层，它把RDMA的拥塞控制和丢包恢复功能提到了软件上，利用现有的硬件来协助软件加速性能。</p>
<h3 id="3-RoGUE设计"><a href="#3-RoGUE设计" class="headerlink" title="3. RoGUE设计"></a>3. RoGUE设计</h3><p><strong>软硬件具体分工：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>拥塞控制功能</th>
<th>丢包恢复功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>软件</td>
<td>1、拥塞控制逻辑（依靠时延来估计和响应拥塞，而不是用丢包和ECN bits。原因是：ECN标记只是表示网络拥塞，而时延表示RNIC和网络的拥塞。并且RNIC消耗ECN标记，使得它们对软件是透明的）；2、Segmentation；3、TCP Vegas算法来做拥塞响应调整拥塞窗口（RoGUE软件上使用一个拥塞窗口，结合硬件速率限制器来调整RNIC的数据包，用这两个方法一起保证稳定的拥塞控制行为）</td>
<td>当硬件重传无效的时候，响应慢就会影响吞吐率（burst流丢包），RoGUE使用一个软件上的shadow queue pair来进行重传</td>
</tr>
<tr>
<td>RNIC</td>
<td>1、高性能通信；2、精准时间戳；3、速率限制</td>
<td>当偶尔有丢包发生的时候，RoGUE首先依靠RNIC的硬件重传机制</td>
</tr>
</tbody>
</table>
<p>RoGUE在OFED用户层API上加了一层。把来自应用程序的一个很大的verb集合作为输入。</p>
<p><strong>RoGUE如何实现拥塞控制呢？</strong></p>
<ol>
<li><p>对输入数据进行segmentation</p>
</li>
<li><p>使用RTT和丢包来估算拥塞，用一个窗口来记录verbs</p>
</li>
<li><p>在硬件上进行速率限制来pace out packets</p>
</li>
</ol>
<hr>
<p><strong>为了提供低开销、高性能、拥塞控制和可靠性，需要解决以下问题</strong>：</p>
<p>Q1: 如何取segments的大小？</p>
<p>Q2: 拥塞如何估计和根据现有RNIC的能力和限制有效控制？</p>
<p>Q3: 如何适应不同的底层（RC vs UC）？</p>
<p>Q4: 对由拥塞导致的丢包如何恢复？</p>
<p><strong>A1:</strong></p>
<p>RDMA的一个主要优点是使用大segments并卸载分组化并解析到RNIC可以最大限度地减少CPU的参与和负载。 但是，大的segments还会降低来自网络的反馈的粒度，从而影响拥塞控制。</p>
<p>设计的两个重点考虑：segmentation（RoGUE传输的一个verb有多大）、signaling（RNIC通知软件一个verb完成的频率）。</p>
<p>解决方法：通过实验测试，考虑两个不同的网卡RNICs：10 Gbps ConnectX-3 Pro和100 Gbps ConnectX-4 RNIC，使用ib_read_bw OFED RDMA基准测试工具来做到线速使用不同大小的READs 用dstat工具来测量cpu利用率。此设计优先考虑CPU效率而不是更快的响应。<br>结论：综合考虑拥塞信号频率和CPU，Segmentation大小是64KB（10Gbps），256KB（100bps），每一个batch发送一次拥塞信号给软件层，这里batch就取segmentation的大小。</p>
<p>对于饥饿问题的考虑： RoGUE使用类似于TCP的拥塞窗口来避免过快地发送数据。 因此，在接收器确认先前的发送之前，不会发送新数据。 在高速网络上，拥塞窗口可能小到16KB。 当batch大小超过拥塞窗口时，如果只有一个批次入队，RNIC将会饿死，因为RoGUE在从下一batch中放进队列verbs之前等待先前batch完成的信号，并且直到最后一个数据包发送一个RTT之后才接收到这些信号。为了避免饥饿，RoGUE因此确保在仍有应用程序数据要发送时<strong>至少有2个batch入队</strong>。</p>
<p><strong>A2：</strong></p>
<p>为了控制发送速率，RoGUE依靠（1）基于RTT的拥塞控制窗口（2）硬件限速</p>
<p>因为丢包信号软件不能很快得到，所以用时延作为拥塞信号。使用了一个拥塞窗口，限制了数据包的总数，允许RoGUE ack计时一个batch中的数据包避免拥塞崩溃。但是一个segments中传输的包都以线速传输，因此RoGUE暂时可能会产生一个burst导致丢包，所以RoGUE设置了硬件限速器。综合以上来控制发送速率。</p>
<p>RTT测量方法：跟论文Timely中的一样，对于RC来说，第i个verb的RTT=收到ack的时间戳-开始传输时间戳（=max{入队时间，上一个verb收到ack的时间戳}）-传输时延（=verb的字节数/限速器的配置设置速率）</p>
<p>拥塞窗口调整方法：TCP Vegas（加性增，加性减），简单来说就是在每个batch的最后，用上面得到的当前RTT用来估计预期和实际拥塞窗口的差。</p>
<p><strong>A3：</strong></p>
<p>特定传输设计</p>
<p>RoGUE is the first approach to offer congestion control for the UC transport type. </p>
<p>支持UC传输类型非常重要，因为最近的工作表明它比RC更具可扩展性，因为UC流量可能会影响其他拥塞控制的流量，如RC或TCP流量。</p>
<ul>
<li>RC传输：对于RC上的WRITE和SEND动词，RoGUE严格遵循上述设计。 RC中的主要问题是由READ动词引起的。 首先，保持拥塞窗口是复杂的，因为在相反方向上引起WRITE和READ的拥塞。 为了克服这个问题，RoGUE为单个RC QP维护独立的READ和WRITE拥塞窗口。 其次，READ需要在远程主机上设置速率限制。 RoGUE使用一个接收器端库，该接收器端异步地将限制应用于QP，并在每次更改时使用READ速率限制将WRITE_IMM发送到远程主机。</li>
<li>UC传输：与RC传输不同，RNIC不在UC传输中生成ACK。 因此，不可能立即使用信号来计算网络RTT。 UC传输中的信号仅指示消息已在网络上发送，而不是已由远程RNIC确认。计算RTT的时候完成时间就是一个Verb中最后一个包发送的时间，这篇论文忽略这个误差。</li>
<li>不处理RD传输</li>
</ul>
<p>RoGUE必须能够在UC传输中的RTT测量期间处理分组丢失。 在批次i的测量之前到达的批次j &gt; i的RTT测量被解释为批次i中的分组丢失，并且拥塞窗口积性减小。 当所有未完成的RTT测量都被丢弃时，RoGUE使用超时来重试RTT的采样。 超时后，RoGUE将拥塞窗口重置为其初始大小，并且在成功对RTT进行采样之前不会将新批次排入队列。</p>
<p><strong>A4:</strong></p>
<p>当QP发生error state，使用shadow QP mechanism</p>
<h3 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h3><p>32台servers，用10Gbps的RNIC相连。</p>
<ol>
<li>测量CPU利用率。同时使用QP或TCP流来驱动测试平台中两台机器之间的线速流量（“客户端”发送到“服务器”），比较DCTCP、RoCE和RoGUE、RC和UC传输类型、比较 READ 和WRITE verb的情况。 对于READ，服务器将数据发送到客户端。 我们使用dstat来测量客户端和服务器上每10秒（平均5次运行）的CPU利用率。并且还对DCTCP先进行了优化。</li>
<li>从一个长时间运行的流开始，单独发送，然后添加/删除最多4个额外的流，一次一个。 测量10Gbps网络中RoGUE平均1s间隔的所有五个流的瞬时吞吐量，以及40Gbps网络中RoGUE模拟器的0.1s间隔的瞬时吞吐量。</li>
</ol>
<h3 id="5-实验结果和结论"><a href="#5-实验结果和结论" class="headerlink" title="5. 实验结果和结论"></a>5. 实验结果和结论</h3><p>角度是低能耗（低CPU）+去PFC，对性能的要求是较RoCE持平</p>
<p>没有讨论实现上的开销；忽略了UC的RTT测量时延</p>
<h3 id="最后：背景知识"><a href="#最后：背景知识" class="headerlink" title="最后：背景知识"></a>最后：背景知识</h3><p>使用RDMA，用户空间应用程序调用内核来分配NIC队列，然后建立与远程计算机的连接。 应用程序使用客户端库直接与RNIC连接，以将RDMA verbs发送到队列。</p>
<p>最常用的verb是READ，WRITE，SEND和RECV。 READ从远程主机的内存中获取数据，WRITE将数据传输到远程主机的内存中。 READ和WRITE被认为是“单方面的”，因为它们只需要发送端的主机活动：接收方的RNIC在没有软件参与的情况下处理请求。SEND是“双面的”：它们将消息传送到远程主机，其中软件将RECV verbs排入队列以接收消息。 verbs中的数据大小通常可达2GB。 WRITE_WITH_IMM和SEND_WITH_IMM是WRITE和SEND的变体，它们携带额外的4字节的立即数据，可由远程主机上的软件读取。</p>
<p>READ，WRITE和SEND被发布到发送队列。 RNIC还在建立连接时创建接收队列。 对于READ和WRITE，不需要接收队列，而对于SEND，软件必须将相应的RECV发布给它们。 所有发送和接收队列都配对，每个队列对（QP）与完成队列相关联，该完成队列表示事件完成并提供即时数据。 用户空间应用程序可以使用中断或轮询完成队列。</p>
<p>RDMA支持三种传输类型：可靠连接（RC），不可靠连接（UC）和不可靠数据报（UD）。 所有传输都支持SEND / RECV，因为它们的要求最低。 RC和UC支持WRITE，但只有RC支持READ。 在RC中，RNIC负责丢失后的重传。 相反，UC和UD中的RNIC忽略了数据包丢弃。 RNIC可以通过事件对verb的完成申请发出信号。 如果在verb完成时不需要通知应用程序，则它可以禁用信号，这会降低CPU利用率。</p>
<p>RC的workflow：</p>
<p>1、发送端主机软件将verb放进队列</p>
<p>2、发送端RNIC使用DMA从主机内存中获取要写入的数据，并通过网络以一个或多个数据包发送数据。</p>
<p>4、接收端RNIC把数据写入内存，等到收到最后一个包了之后，就发回一个ACK，发送的RNIC接收ACK</p>
<p>6、发送端选择性产生一个信号通知应用程序WRITE完成了</p>
<p>UC verb类似，除了接收端不会有ack并且信号是当verb最后一个包发送的时候会发出而不是收到ack的时候。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><em>RoGUE: RDMA over Generic Unconverged Ethernet</em>, Yanfang Le (UW-Madison), Brent Stephens (UW-Madison), Arjun Singhvi (UW-Madison), Aditya Akella (UW-Madison), Michael Swift (UW-Madison), <em>SoCC‘18</em></li>
<li><em>Revisiting Network Support for RDMA</em>, Radhika Mittal (Berkeley, USA), Alexander Shpiner (Mellanox, Israel), Aurojit Panda (ICSI and NYU, USA), Eitan Zahavi (Mellanox, Israel), Arvind Krishnamurthy (UW, USA), Sylvia Ratnasamy (Berkeley, USA), Scott Shenker (ICSI and Berkeley, USA), <em>SIGCOMM‘18</em></li>
<li><p><a href="https://dl.acm.org/citation.cfm?doid=190314.190317" target="_blank" rel="external">TCP Vegas Algorithm</a></p>
</li>
<li><p><a href="https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p537.pdf" target="_blank" rel="external"><em>TIMELY: RTT-based Congestion Control for the Datacenter</em></a>, Radhika Mittal(UC Berkeley), Vinh The Lam, Nandita Dukkipati, Emily Blem, Hassan Wassel,Monia Ghobadi(Microsoft), Amin Vahdat, Yaogong Wang, David Wetherall, David Zats, <em>SIGCOMM’2015</em></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/15/fpgas-for-dummies-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/fpgas-for-dummies-note/" itemprop="url">FPGAs For Dummies阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T14:48:35+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/计算机/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年11月15日所写，未经允许不得转载。</p>
<p>原书作者：Andrew Moore with Ron Wilson, Editor-in-Chief, Intel® Programmable Solutions Group</p>
<p><a href="https://plan.seek.intel.com/PSG_WW_NC_LPCD_FR_2018_FPGAforDummiesbook" target="_blank" rel="external"><em>FPGAs For Dummies</em></a> 是Intel官网给出的学习FPGA的入门材料。书几十页，不长，写的简单易懂，适合入门，介绍了FPGA的背景、结构、设计方法、应用，以下为一些重点摘录和笔记。</p>
<h3 id="1-关于FPGA"><a href="#1-关于FPGA" class="headerlink" title="1. 关于FPGA"></a>1. 关于FPGA</h3><p><strong>FPGA</strong>  Field programmable gate arrays，现场可编程门阵列</p>
<p>FPGA是集成电路，使设计人员能够在现场对定制的数字逻辑进行编程。 自20世纪80年代以来，FPGA一直存在，最初的构思是让所有设计团队都能够创建自定义逻辑。</p>
<p><strong>门阵列</strong>是指由半导体厂商准备出已经在硅片上形成了被称为基本单元的逻辑门的母板,通过按照用户希望的电路进行布线,在母板上形成电路的半客户定制品芯片。</p>
<h3 id="2-一个FPGA里面有什么"><a href="#2-一个FPGA里面有什么" class="headerlink" title="2. 一个FPGA里面有什么"></a>2. 一个FPGA里面有什么</h3><p>现代FPGA由可配置SRAM（static random access memory）、high-speed I/O pins、逻辑块、路由组成。</p>
<p>具体来说FPGA包括了可编程的逻辑元素叫 <strong>logic elements（LEs）</strong>、<strong>可重构互连的层次结构（它允许LE彼此物理连接）</strong>、<strong>内存块</strong>。</p>
<p><strong>基本概念</strong>：wire（导线）, logic gate（逻辑门，与或非运算）, register（寄存器）</p>
<p><strong>FPGA上经常使用的components：</strong></p>
<blockquote>
<p>1.<strong>hard IP</strong> is intellectual property built into the FPGA, such as DRAM(dynamic random access memory) controllers, PCIe(peripheral component interconnetct interface express) controllers, clock generators, and big blocks of memory.而现在FPGA已经有很多hard IP了。</p>
</blockquote>
<p>2.不经常使用的功能 例如：可以包括用于雷达或通信的高速串行收发器、信号处理的数字信号处理器（DSP）乘法器-累加器、双核ARM（ARM是微处理器设计的品牌）CPU子系统</p>
<p>今天的高端FPGA可能只有芯片面积的一半可编程逻辑，另一半可能由hard IP组成。</p>
<p>FPGA在向量数学计算方面可以<strong>并行运算</strong>，所以效率高，而microcontroller不行。</p>
<h4 id="FPGA的现代设计流程"><a href="#FPGA的现代设计流程" class="headerlink" title="FPGA的现代设计流程"></a>FPGA的现代设计流程</h4><p>定义需求➡创建架构➡实施系统➡验证</p>
<p>FPGA制造商逐渐将常见功能或知识产权类组件（IP）加入他们的产品。这些IP组件可以是嵌入芯片的硬件、提供给用户的软件，或者——就是FPGA——用户可以加入可编程逻辑的硬件设计。现在可以利用现有IP组件，替换功能块。</p>
<p>早期FGPA设计中，使用硬件描述语言HDL，HDL语言使用硬件术语导线和逻辑门来描述功能块。现在可使用OpenCL等高等级软件编程工具，即使是没有专门硬件技能的软件设计师，也能指定子系统功能、编写代码，以及生成可以载入正常FPGA设计流程的硬件描述文件。</p>
<p>对于仍然需要详细设计的功能块，设计师将使用HDL语言，Verilog是实现FGPA设计的常用HDL语言。</p>
<p>在HDL语言设计编写完成之后，下一步是<strong>编译HDL设计</strong>。在FPGA编程里，综合工具将HDL语言设计作为输入内容，将其转化成逻辑门、寄存器和导线组成的网络。</p>
<p><strong>验证系统设计</strong>：完成代码编译之后，需要进行测试，然后才可将代码配置到FPGA。FPGA测试调试通常在模拟环境下进行。模拟器是一些软件应用，这种应用程序通常可以模拟您的设计行为。模拟过程通过软件实现，并且通过软件，您能够看到每个寄存器的表现。然后，再将您的设计放入FPGA。</p>
<blockquote>
<p>开发人员大都使用一种叫做“Testbench”的工具，来验证FGPA在现实世界能否正常运行。Testbench是由自己设计，将软件仿真与实际硬件相结合，构成了实际的系统模型，该系统中包含了您的FPGA。FPGA大都包含数以万计或十万计的逻辑门，因此您不可能全部测试。Testbench主要用于测试主要设计区域中实际工作的逻辑门，以及在这些区域添加调试辅助工具，让您的设计能够按照您的意愿运行。</p>
</blockquote>
<p><strong>在系统内验证设计</strong>：运行阶段有时也被称为闭环阶段。对于任何硬件器件，都有一定的<strong>性能标准</strong>，比如<strong>功耗</strong>和<strong>速度</strong>，设计师还应该测试和确保每个网状结构（逻辑门之间的导线连接）达到时序要求。最后确保每个时钟和电源管脚都连接到您的FPGA。</p>
<h3 id="3-FPGA系统"><a href="#3-FPGA系统" class="headerlink" title="3. FPGA系统"></a>3. FPGA系统</h3><p>传统的系统设计模型：</p>
<p>架构→ · →实施 → · →整合→ · →</p>
<p><strong>系统设计与决策点</strong></p>
<p>在系统设计中，决策点是需要提出问题的点，例如：</p>
<ul>
<li>系统必须实现哪些功能？</li>
<li>能否利用我的现有设计并做出改动?</li>
<li>有多少系统需要通过软件处理？</li>
<li>我能够购买多少现成硬件？</li>
<li>是否正常运行？</li>
</ul>
<p>需求定义阶段，设计师必须考虑设计限制因素，例如：性能、功耗和尺寸等。系统的功能也很重要——包括哪些功能可见、哪些功能不可见或锁定。最后，设计师对设计进行实验。</p>
<h3 id="4-异构计算与OpenCL"><a href="#4-异构计算与OpenCL" class="headerlink" title="4. 异构计算与OpenCL"></a>4. 异构计算与OpenCL</h3><p><strong>异构计算</strong></p>
<p>数据中心内部的一个重要趋势，即计算架构的转变：从多核CPU转向异构计算。异构计算是指不止一个类型的处理器，实现一个具有专业处理能力的系统。</p>
<p><strong>平行计算</strong></p>
<p><strong>数据平行</strong></p>
<p><strong>任务平行</strong></p>
<h4 id="OpenCL"><a href="#OpenCL" class="headerlink" title="OpenCL"></a>OpenCL</h4><p>OpenCL是一个可编写程序的框架结构，这种程序可在异构平台上执行，包括CPU、GPU、DSP、FPGA以及其他类型处理器。OpenCL包括内核（在硬件设备上执行的功能）开发语言，以及让主程序能够控制内核的应用程序接口（API）开发语言。OpenCL允许进行任务平行计算和数据平行计算。</p>
<p>FPGA原本就是平行计算的。除了典型的数据平行和任务平行，FPGA还提供管道平行：可通过推拉配置生产任务，每个任务从上一个任务接受数据，并且可发生或不发生主机交互。</p>
<p>OpenCL 的优势：</p>
<ul>
<li>简单性和便利性：C语言</li>
<li>代码剖析：判断影响性能的部分</li>
<li>效率：通过OpenCL可生成达到高性能所需的逻辑</li>
<li>异构系统：通过OpenCL可开发面向FPGA、CPU、GPU以及DSP的无缝内核</li>
<li>代码重复利用：OpenCL内核允许提供”便携“代码，可以实现跨项目、种类使用</li>
</ul>
<p>今天OpenCL语言的开发和维护者是柯罗诺斯技术联盟。多数FGPA制造商都为OpenCL FPGA的开发提供SDK。</p>
<h3 id="5-FPGA的五种应用"><a href="#5-FPGA的五种应用" class="headerlink" title="5. FPGA的五种应用"></a>5. FPGA的五种应用</h3><p>Intel内嵌ARM核心的FPGA被称为“FPGA片上系统”（SoC FPGA）</p>
<ol>
<li>单设备电动控制器</li>
<li>电视广播</li>
<li>无线数据</li>
<li>自动驾驶辅助摄像头</li>
<li>高性能计算</li>
</ol>
<blockquote>
<p>协处理器”是用于补充主处理器或中央处理器(CPU)的计算机处理器。协处理器通常被用于执行浮点计算、信号处理、字符串处理、编码或与外围设备的 I/O 接口。协处理器负责密集型运算，从而解放了 CPU，使 CPU 能够专注于计算机的核心功能。</p>
<p>最新的英特尔 FPGA 不仅内嵌 DSP 功能，而且内嵌浮 点计算是硬浮点。所以，程序员们不必将程序从浮点格式转成整 数格式，就可在 FPGA 加速服务器上运行。这种能力在以下几个 方面大有可为 : </p>
<ul>
<li><p>数据应用 :数据库和金融市场提速</p>
</li>
<li><p>功能组件 :供金融市场使用的随机数字发生器，供军事和信号处理应用使用的百万点 FET 晶体管</p>
</li>
<li><p>运算法则 :SRCs CARTE、Impulse 以及 AutoESL 系统生成 算法 </p>
</li>
</ul>
</blockquote>
<hr>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p><strong>ARM</strong> Advanced RISC Machine，进阶精简指令集机器</p>
<p><strong>ASSP</strong>  application-specific standard product</p>
<p><strong>DSP</strong> digital signal processor：frees designers from reinventing the wheel each time they need to add these common pieces to their systems. </p>
<p>ASICs和ASSPs的介绍：p11</p>
<p><strong>hard IP</strong> intellectual property</p>
<p><strong>SoC </strong>system on chips，片上系统</p>
<p><strong>SDI</strong> 串行数字接口</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/20/Git-server-setup-hooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/20/Git-server-setup-hooks/" itemprop="url">Git服务器带自动化部署安装过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T21:16:27+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月20日所写，未经允许不得转载。</p>
<ul>
<li>首先安装Git</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install git</div></pre></td></tr></table></figure>
<ul>
<li>创建git用户组和用户</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">groupadd git</div><div class="line">adduser git</div><div class="line">passwd git</div></pre></td></tr></table></figure>
<ul>
<li>创建Git证书登录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /home</div><div class="line">mkdir git</div><div class="line">cd /home/git</div><div class="line">mkdir .ssh</div><div class="line">chmod 700 .ssh</div><div class="line">touch .ssh/authorized_keys</div><div class="line">chmod 600 .ssh/authorized_keys</div></pre></td></tr></table></figure>
<ul>
<li>然后把自己的客户端的Git公钥加入authorized_keys文件中，一行一个</li>
<li>初始化Git仓库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cd /home</div><div class="line">mkdir gitrepo</div><div class="line">chown git:git gitrepo</div><div class="line">cd gitrepo</div><div class="line">git init --bare test.git # 初始化裸仓库</div><div class="line">chown -R git:git /home/gitrepo</div><div class="line">Initialized empty Git repository in /home/gitrepo/test.git/</div><div class="line">chown -R git:git test.git</div></pre></td></tr></table></figure>
<ul>
<li>克隆仓库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@Server_IP:/home/gitrepo/test.git</div></pre></td></tr></table></figure>
<ul>
<li>编写自动更新钩子</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /home/gitrepo/test.git/hooks/</div><div class="line">vim post-receive</div></pre></td></tr></table></figure>
<ul>
<li>添加以下内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/sh </div><div class="line">git --work-tree=your_work_dir --git-dir=/root/gitrepo/test.git checkout -f</div></pre></td></tr></table></figure>
<ul>
<li>保存退出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x post-receive # 给钩子文件添加可执行权限</div></pre></td></tr></table></figure>
<p>如果push之后工作部署路径看不到代码的话，就手动运行一下post-receive一下，然后之后push的就都有了（这个问题纠结了我半天）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/13/Go语言字符串处理总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/Go语言字符串处理总结/" itemprop="url">Go语言字符串处理总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T20:17:51+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/Go语言/" itemprop="url" rel="index">
                    <span itemprop="name">Go语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月13日所写，未经允许不得转载。</p>
<p>正好最近用到了一些字符串，就总结了一下Golang中的字符串处理函数，主要是Golang中的strings包：</p>
<ol>
<li><code>Count(s string, str string) int</code>：计算字符串str在s中的非重叠个数。如果str为空串则返回s中的字符（非字节）个数+1。</li>
<li><code>Index(s string, str string) int</code> ：返回子串str在字符串s中第一次出现的位置。如果找不到则返回-1；如果str为空，则返回0。</li>
<li><code>LastIndex(s string, str string) int</code>： 返回子串str在字符串s中最后一次出现的位置。如果找不到则返回-1；如果str为空则返回字符串s的长度。</li>
<li><code>IndexRune(s string, r rune) int</code> ：返回字符r在字符串s中第一次出现的位置。如果找不到则返回-1。</li>
<li><code>IndexAny(s string, str string) int</code> ：返回字符串str中的任何一个字符在字符串s中第一次出现的位置。如果找不到或str为空则返回-1。</li>
<li><code>LastIndexAny(s string, str string) int</code>： 返回字符串str中的任何一个字符在字符串s中最后一次出现的位置。如果找不到或str为空则返回-1。</li>
<li><code>Contains(s string, str string) bool</code>：判断字符串s中是否包含个子串str。包含或者str为空则返回true。</li>
<li><code>ContainsAny(s string, str string) bool</code>：判断字符串s中是否包含个子串str中的任何一个字符。包含则返回true，如果str为空则返回false。</li>
<li><code>ContainsRune(s string, r rune) bool</code>：判断字符串s中是否包含字符r。</li>
<li><code>SplitN(s, str string, n int) []string</code>：以str为分隔符，将s切分成多个子串，结果中<strong>不包含</strong>str本身。如果str为空则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分，最后一个n包含了所有剩下的不切分。如果n为0，则返回nil；如果n小于0，则不限制切分个数，全部切分。</li>
<li><code>SplitAfterN(s, str string, n int) []string</code>：以str为分隔符，将s切分成多个子串，结果中<strong>包含</strong>str本身。如果str为空，则将s切分成Unicode字符列表。如果s 中没有str子串，则将整个s作为 []string 的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分。如果n为0，则返回 nil；如果 n 小于 0，则不限制切分个数，全部切分。</li>
<li><code>Split(s, str string) []string</code>：以str为分隔符，将s切分成多个子切片，结果中<strong>不包含</strong>str本身。如果str为空，则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。</li>
<li><code>SplitAfter(s, str string) []string</code>：以str为分隔符，将s切分成多个子切片，结果中<strong>包含</strong>str本身。如果 str 为空，则将 s 切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。</li>
<li><code>Fields(s string) []string</code>：以连续的空白字符为分隔符，将s切分成多个子串，结果中不包含空白字符本身。空白字符有：\t, \n, \v, \f, \r, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP) 。如果 s 中只包含空白字符，则返回一个空列表。</li>
<li><code>FieldsFunc(s string, f func(rune) bool) []string</code>：以一个或多个满足f(rune)的字符为分隔符，将s切分成多个子串，结果中不包含分隔符本身。如果s中没有满足f(rune)的字符，则返回一个空列表。</li>
<li><code>Join(s []string, str string) string</code>：将s中的子串连接成一个单独的字符串，子串之间用str分隔。</li>
<li><code>HasPrefix(s string, prefix string) bool</code>：判断字符串s是否以prefix开头。</li>
<li><code>HasSuffix(s, suffix string) bool</code> ：判断字符串s是否以prefix结尾。</li>
<li><code>Map(f func(rune) rune, s string) string</code>：将s中满足f(rune)的字符替换为f(rune)的返回值。如果f(rune)返回负数，则相应的字符将被删除。</li>
<li><code>Repeat(s string, n int) string</code>：将n个字符串s连接成一个新的字符串。</li>
<li><code>ToUpper(s string) string</code>：将s中的所有字符修改为其大写格式。对于非ASCII字符，它的大写格式需要查表转换。</li>
<li><code>ToLower(s string) string</code>：将s中的所有字符修改为其小写格式。对于非ASCII字符，它的小写格式需要查表转换。</li>
<li><code>ToTitle(s string) string</code>：将s中的所有字符修改为其Title格式，大部分字符的Title格式就是Upper格式，只有少数字符的Title格式是特殊字符。这里的ToTitle主要给Title函数调用。</li>
<li><code>TrimLeftFunc(s string, f func(rune) bool) string</code>：删除s头部<strong>连续的</strong>满足f(rune)的字符。</li>
<li><code>TrimRightFunc(s string, f func(rune) bool) string</code>：删除s尾部<strong>连续的</strong>满足f(rune)的字符。</li>
<li><code>TrimFunc(s string, f func(rune) bool) string</code>：删除s首尾<strong>连续的</strong>满足f(rune)的字符。</li>
<li><code>IndexFunc(s string, f func(rune) bool) int</code>：返回s中第一个满足f(rune) 的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。</li>
<li><code>LastIndexFunc(s string, f func(rune) bool) int</code>：返回s中最后一个满足f(rune)的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。</li>
<li><code>Trim(s string, str string) string</code>：删除s首尾连续的包含在str中的字符。</li>
<li><code>TrimLeft(s string, str string) string</code>：删除s头部连续的包含在str中的字符串。</li>
<li><code>TrimRight(s string, str string) string</code>：删除s尾部连续的包含在str中的字符串。</li>
<li><code>TrimSpace(s string) string</code>：删除s首尾连续的的空白字符。</li>
<li><code>TrimPrefix(s, prefix string) string</code>：删除s头部的prefix字符串。如果s不是以prefix开头，则返回原始s。</li>
<li><code>TrimSuffix(s, suffix string) string</code>：删除s尾部的suffix字符串。如果s不是以suffix结尾，则返回原始s。（只去掉一次，注意和TrimRight区别）</li>
<li><code>Replace(s, old, new string, n int) string</code>：返回s的副本，并将副本中的old字符串替换为new字符串，替换次数为n次，如果n为-1，则全部替换；如果 old 为空，则在副本的每个字符之间都插入一个new。</li>
<li><code>EqualFold(s1, s2 string) bool</code>：比较UTF-8编码在小写的条件下是否相等，不区分大小写，同时它还会对特殊字符进行转换。比如将“ϕ”转换为“Φ”、将“Ǆ”转换为“ǅ”等，然后再进行比较。</li>
<li>“==”比较字符串是否相等，区分大小写，返回bool。</li>
<li><code>Compare(s1 string, s2 string) int1</code>：比较字符串，区分大小写，比”==”速度快。相等为0，不相等为-1。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/13/Git与GitHub总结笔记-参考《GitHub入门与实践》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/Git与GitHub总结笔记-参考《GitHub入门与实践》/" itemprop="url">Git与GitHub总结笔记-参考《GitHub入门与实践》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T19:53:20+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月13日所写，未经允许不得转载。</p>
<p>前言：虽然已经用过一段时间自己的git服务器和github，但是看到这本书还是想深入了解一下。正好最近微软收购了Github，因此写了这篇笔记纪念一下2333，并总结了一下Git的常用命令。《GitHub入门与实践》这本书深入介绍了关于Git的知识，有利于加深对Git的理解，还是比较推荐的。</p>
<ul>
<li><p>关于GitHub</p>
<ol>
<li><p>GitHub总部：旧金山</p>
</li>
<li><p>吉祥物：Octocat</p>
</li>
<li><p>不只是Git仓库托管服务</p>
</li>
<li><p>协同工作的软件：群件（Groupware）、CRM（Customer Relationship Management，顾客关系管理）</p>
</li>
<li><p>Pull Request 是指开发者在本地对源代码进行更改后，向GitHub 中托管的Git 仓库请求合并的功能。不但能轻松查看源代码的前后差别，还可以对指定的一行代码进行评论。</p>
</li>
<li><p>GitHub Flavored Markdown（GFM）语法</p>
</li>
<li><p>@用户：输入“@ 组织名”可以让属于该组织的所有成员收到通知</p>
</li>
<li><p>输入“# 编号”，会连接到该仓库所对应的Issue 编号。</p>
</li>
<li><p>社会化编程的概念 </p>
</li>
<li><p>Issue 功能，是将一个任务或问题分配给一个Issue 进行追踪和管理</p>
<p>的功能</p>
</li>
<li><p>Wiki：开发文档或手册的编写 </p>
</li>
<li><p>Linux 的创始人Linus Torvalds 在2005 年开发了Git 的原型程序。当时，由于在Linux 内核开发中使用的既有版本管理系统的开发方许可证发生了变更，为了更换新的版本管理系统，Torvalds 开发了Git。</p>
</li>
</ol>
</li>
<li><p>Git安装</p>
<ol>
<li><p>关于windows换行符的处理</p>
<p>GitHub 中公开的代码大部分都是以Mac 或Linux 中的LF（LineFeed）换行。然而，由于Windows 中是以CRLF（Carriage Return ＋Line Feed）换行的，所以在非对应的编辑器中将不能正常显示。</p>
<p>Git 可以通过设置自动转换这些换行符。使用Windows 环境的各位，请选择推荐的“Checkout Windows-style, commit Unix-style line endings”选项。换行符在签出时会自动转换为CRLF，在提交时则会自动转换为LF。</p>
</li>
<li><p>初始设置</p>
<ul>
<li><p>首先来设置使用Git 时的姓名和邮箱地址。名字请用英文输入。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Firstname Lastname&quot;</div><div class="line">$ git config --global user.email &quot;your_email@example.com&quot;</div></pre></td></tr></table></figure>
<p>这个命令，会在“~/.gitconfig”中以如下形式输出设置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[user]</div><div class="line">name = Firstname Lastname</div><div class="line">email = your_email@example.com</div></pre></td></tr></table></figure>
<p>想更改这些信息时，可以直接编辑这个设置文件。这里设置的姓名和邮箱地址会用在Git 的提交日志中</p>
</li>
<li><p>提高命令输出的可读性 </p>
<p>将color.ui 设置为auto 可以让命令的输出拥有更高的可读性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global color.ui auto</div></pre></td></tr></table></figure>
<p>“~/.gitconfig”中会增加下面一行。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[color]</div><div class="line">ui = auto</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>GitHub</p>
<ul>
<li><p>头像</p>
<p>在GitHub 上随处可见的头像（账户独有的标识）是通过Gravatar服务显示的。</p>
</li>
<li><p>创建SSH Key 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</div></pre></td></tr></table></figure>
<p><em>Your identification has been saved in <code>/Users/your_user_directory/.ssh/id_rsa</code>.</em></p>
<p><em>Your public key has been saved in <code>/Users/your_user_directory/.ssh/id_rsa.pub</code>.</em></p>
<p>id_rsa 文件是私有密钥，id_rsa.pub 是公开密钥。 </p>
</li>
<li><p>验证：用手中的私人密钥与GitHub 进行认证和通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
</li>
<li><p>.gitignore 文件 用来描述Git 仓库中不需管理的文件与目录。 </p>
</li>
<li><p>在GitHub 上，有修正BSD 许可协议、Apache 许可协议等多种许可协议供人们选择，不过大多数软件都使用MIT 许可协议。实际使用时， 只需将LICENSE 文件加入仓库， 并在README.md 文件中声明使用了何种许可协议即可。</p>
</li>
</ul>
</li>
<li><p>自己总结了一下基本命令</p>
<ul>
<li><p><code>git init</code>初始化仓库：如果初始化成功，执行了git init命令的目录下就会生成.git 目录。这个.git 目录里存储着管理当前目录内容所需的仓库数据。在Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。</p>
</li>
<li><p><code>git status</code>查看仓库的状态。</p>
</li>
<li><p><code>git add</code>命令将文件加入暂存区。</p>
</li>
<li><p><code>git commit -m &quot;提交信息&quot;</code>将当前暂存区中的文件实际保存到仓库的历史记录中。</p>
<ul>
<li><p>记录详细提交信息的话，不加-m，执行后会启动编辑器。</p>
<p>在编辑器中记述提交信息的格式如下。</p>
<p>● 第一行：用一行文字简述提交的更改内容</p>
<p>● 第二行：空行</p>
<p>● 第三行以后：记述更改的原因和详细内容</p>
<p>在以#（井号）标为注释的Changes to be committed（要提交的更改）栏中，可以查看本次提交中包含的文件。将提交信息按格式记述完毕后，请保存并关闭编辑器，以#（井号）标为注释的行不必删除。</p>
</li>
<li><p>如果在编辑器启动后想中止提交，请将提交信息留空并直接关闭编辑器，随后提交就会被中止。</p>
</li>
<li><p>写在一起：<code>git commit -am &quot;&quot;</code></p>
</li>
</ul>
</li>
<li><p><code>git log</code>命令查看提交日志 。</p>
</li>
<li><p><code>git log --pretty=short</code>只显示提交信息的第一行 。只要在git log命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。</p>
</li>
<li><p><code>git log -p</code>查看提交所带来的改动</p>
</li>
<li><p><code>git push</code>更新仓库</p>
</li>
<li><p><code>git diff</code>查看当前工作树与暂存区的差别</p>
</li>
<li><p><code>git diff HEAD</code>查看工作树和最新提交的差别。在执行git commit命令之前先执行 git diff HEAD命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交。这里的HEAD 是指向当前分支中最新一次提交的指针。</p>
</li>
<li><p><code>git branch</code>命令可以将分支名列表显示，同时可以确认当前所在分支。“*”表示这是我们当前所在的分支。</p>
</li>
<li><p><code>git checkout -b &quot;branch name&quot;</code>以当前的master 分支为基础创建并切换到新的分支</p>
</li>
<li><p><code>git checkout -</code>用“-”（连字符）代替分支名，就可以切换至上一个分支。</p>
</li>
<li><p><code>git merge --no-ff feature-A</code>合并分支。为了在历史记录中明确记录下本次分支合并，需要创建合并提交。因此，在合并时加上–no-ff参数。随后编辑器会启动，用于录入合并提交的信息。 将编辑器中显示的内容保存，关闭编辑器。</p>
</li>
<li><p><code>git log --graph</code>以图表形式查看分支 </p>
</li>
<li><p><code>git reset</code>回溯历史版本，要让仓库的HEAD、暂存区、当前工作树回溯到指定状态，需要用</p>
<p>到git reset –hard命令。只要提供目标时间点的哈希值A就可以完全恢复至该时间点的状态。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d</div><div class="line">HEAD is now at fd0cbf0 Add index</div></pre></td></tr></table></figure>
<p>git log命令只能查看以当前状态为终点的历史日志。使用<code>git reflog</code>命令，查看当前仓库的操作日志。</p>
</li>
<li><p><code>git commit --amend</code>修改上一条提交信息，执行命令后，编辑器就会启动。</p>
</li>
<li><p><code>git rebase -i</code>压缩历史，<code>git rebase -i HEAD~2</code>选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。</p>
</li>
<li><p>错字漏字等失误称作typo，将提交信息记为”Fix typo”。 </p>
</li>
<li><p><code>git remote add</code>设置成本地仓库的远程仓库</p>
<p><code>$ git remote add origin git@github.com:github-book/git-tutorial.git</code> 按照上述格式执行<code>git remote add</code>命令之后，Git 会自动将<code>git@github.com:github-book/git-tutorial.git</code>远程仓库的名称设置为origin（标识符）。</p>
<p>或者<code>git remote add origin https://github.com/&lt;your_username&gt;/gitname.git</code></p>
</li>
<li><p><code>git push -u origin master</code>将当前分支下本地仓库中的内容推送给远程仓库，。-u参数可以在推送的同时，将origin 仓库的master分支设置为本地仓库当前分支的upstream（上游）。添加了这个参数，将来运行git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从origin 的master 分支获取内容，省去了另外添加参数的麻烦。</p>
</li>
<li><p>推送至master 以外的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout -b feature-D</div><div class="line">git push -u origin feature-D</div></pre></td></tr></table></figure>
<p> 在本地仓库中创建feature-D 分支，并将它以同名形式push 至远程仓库。 将它push 给远程仓</p>
<p>库并保持分支名称不变。</p>
</li>
<li><p><code>git branch -a</code>命令查看当前分支的相关信息。添加-a参数可以同时显示本地仓库和远程仓库的分支信息。</p>
</li>
<li><p><code>git checkout -b feature-D origin/feature-D</code>将feature-D 分支获取至本地仓库。 </p>
</li>
<li><p><code>git pull origin feature-D</code>使用git pull 命令，将本地的feature-D 分支更新到最新状态。</p>
</li>
<li><p>强行pull命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch --all	// 只是下载代码到本地，不进行合并操作</div><div class="line">git reset --hard origin/master 	// 把HEAD指向最新下载的版本</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code>- 裸库 删除git之后恢复

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git remote add origin /home/gitrepo/...</div><div class="line">git status</div><div class="line">git add .</div><div class="line">git commit</div></pre></td></tr></table></figure>
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/hexo使用总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/hexo使用总结/" itemprop="url">hexo使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T11:19:29+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/使用总结/" itemprop="url" rel="index">
                    <span itemprop="name">使用总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
             <!--test文章摘要：转载请注明文章出处-->
<ul>
<li><p>新建页面</p>
<p><code>hexo new &quot;文章name&quot;</code>或者<code>hexo n &quot;文章name&quot;</code></p>
</li>
<li><p>草稿</p>
<p><code>hexo publish</code>=<code>hexo p</code></p>
</li>
<li><p>生成</p>
<p><code>hexo generate</code>=<code>hero g</code></p>
</li>
<li><p>启动服务器预览</p>
<p><code>hexo server</code>=<code>hexo s</code></p>
</li>
<li><p>部署</p>
<p><code>hexo deploy</code>=<code>hexo d</code>或者与g合并写成<code>hexo d -g</code>，有时候需要先用<code>hexo clean</code>清除cache file</p>
</li>
<li><p>显示草稿</p>
<p><code>hexo --draft</code></p>
</li>
<li><p>设置多标签：</p>
<p>tags后面这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tags: [标签1,标签2,标签3]</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">icestrawberryxjw</p>
              <p class="site-description motion-element" itemprop="description">The most difficult thing is the decision to act, the rest is merely tenacity.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/icestrawberryxjw" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">icestrawberryxjw</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
