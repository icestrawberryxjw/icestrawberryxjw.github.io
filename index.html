<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:type" content="website">
<meta property="og:title" content="icestrawberryxjw">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="icestrawberryxjw">
<meta property="og:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="icestrawberryxjw">
<meta name="twitter:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>icestrawberryxjw</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">icestrawberryxjw</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/CplusPrimerChapter9-mem-manage-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/CplusPrimerChapter9-mem-manage-note/" itemprop="url">CplusPrimerChapter9-mem-manage-note</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T21:58:50+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ primer</em> 一书第九章的内存模型 笔记。—— Jiawei Xu 2019年3月6日</p>
<hr>
<h4 id="变量内存管理-存储持续性"><a href="#变量内存管理-存储持续性" class="headerlink" title="变量内存管理-存储持续性"></a>变量内存管理-存储持续性</h4><p>C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间。</p>
<ul>
<li><p><strong>自动存储持续性</strong>（栈）：</p>
<p>在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们的内存被释放。<strong>C++有两种存储持续性为自动的变量</strong>：局部变量和register关键字。</p>
</li>
<li><p><strong>静态存储持续性</strong>（全局变量/外部变量、static）：</p>
<p>在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为<strong>静态</strong>。它们在程序整个运行过程中都存在。</p>
<p><strong>C++有三种存储持续性为静态的变量</strong>，在整个程序执行期间存在，未被初始化的静态变量默认为0，静态数组和结果的每个元素和成员的所有位都置为0，这种变量被称为<strong>零初始化</strong>的(zero-initialized)：</p>
<ul>
<li><strong>外部链接性external linkage</strong>：可在其他文件中访问，格式：代码块外面声明</li>
<li><strong>内部链接性internal linkage</strong>：只能在当前文件中访问，格式：代码块外面声明+static限定符</li>
<li><strong>无连接性static linkage</strong>：只能在当前函数或代码块中访问，格式：代码块内声明+static限定符</li>
</ul>
</li>
<li><p><strong>动态存储持续性</strong>（堆/自由存储）：</p>
<p>用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的持续性为动态，有时候被称为自由存储(free store)或堆(heap)。</p>
</li>
<li><p><strong>线程存储持续性</strong>（C++11、并行编程、thread_local）</p>
<p>如果变量使用关键字<strong>thread_local</strong>声明的，则其生命周期与所属的线程一样长，并行编程的内容。thread_local之于线程，犹如常规静态变量之于整个程序。</p>
</li>
</ul>
<h4 id="链接性（linkage）"><a href="#链接性（linkage）" class="headerlink" title="链接性（linkage）"></a>链接性（linkage）</h4><p>描述了名称如何在不同单元间共享。链接性在外部的名称可在文件间共享，链接性在内部的名称只能由一个文件中的函数共享。</p>
<h4 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h4><p>文件作用域（作用域为全局）：从定义位置到文件结尾之间可用。</p>
<p>局部作用域（自动变量，automatic variable）：局部。</p>
<p>静态变量的作用域：全局还是局部取决于如何被定义。</p>
<p>函数原型作用域(function prototype scope)中使用的名称只在包含参数列表的括号内可用。</p>
<p>类中声明的成员的作用域：整个类。</p>
<p>在名称空间中声明的变量的作用域为整个名称空间，全局作用域是名称空间作用域的特例。</p>
<h4 id="Auto"><a href="#Auto" class="headerlink" title="Auto"></a>Auto</h4><p>C和C++11之前，用于显式地指出变量为自动存储</p>
<p>C++11中，用于自动类型推断</p>
<h4 id="寄存器变量Register"><a href="#寄存器变量Register" class="headerlink" title="寄存器变量Register"></a>寄存器变量Register</h4><p>C和C++11之前，建议编译器使用CPU寄存器来存储自动变量，旨在提高访问变量的速度；</p>
<p>C++11中，用于显式地指出变量是自动的，作用域为代码块，在代码块中声明，无链接性。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li><p>静态初始化=零初始化+常量表达式初始化（sizeof运算符也包括）</p>
<p>在编译器处理文件时初始化</p>
</li>
<li><p>动态初始化：</p>
<p>在编译后初始化</p>
</li>
<li><p>C++新增关键字constexpr</p>
<p>创建常量表达式的方式</p>
</li>
</ul>
<h4 id="外部-全局变量的C-单定义规则-One-Definition-Rule-ODR"><a href="#外部-全局变量的C-单定义规则-One-Definition-Rule-ODR" class="headerlink" title="外部/全局变量的C++单定义规则(One Definition Rule, ODR)"></a>外部/全局变量的C++单定义规则(One Definition Rule, ODR)</h4><p><strong>外部变量</strong>：链接性为外部的变量，存储持续性为静态，作用域为整个文件。也称全局变量。</p>
<p>如果要在多个文件中使用外部变量，只需要在一个文件里包含定义，但是其他文件使用的时候都要用extern声明。</p>
<p>两种外部变量声明的方式：</p>
<ul>
<li><p>定义声明/定义defining declaring/definition（给变量分配存储空间）</p>
</li>
<li><p>引用申明/声明 referencing declaration/declaration（不给变量分配存储空间）</p>
<p>方法：在变量前面用<strong>关键字extern</strong>，且不进行初始化（两个条件都要满足，否则声明为定义，会分配存储空间）</p>
<p><strong>C++中的作用域解析运算符(::)</strong>：放在变量名前，该运算符表示使用变量的全局版本（更安全，不依赖于作用域）</p>
</li>
</ul>
<p>在多文件程序中，可以在一个文件（且只能在一个文件）定义一个外部变量，使用它的其他文件必须使用关键字extern声明它。</p>
<h4 id="存储说明符"><a href="#存储说明符" class="headerlink" title="存储说明符"></a>存储说明符</h4><ul>
<li>auto（C++11之后不再是说明符）</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>thread_local（C++11新增）</li>
<li>mutable：即使结构（或类）变量为const，其某个成员也可以被修改，</li>
</ul>
<h4 id="CV-限定符"><a href="#CV-限定符" class="headerlink" title="CV-限定符"></a>CV-限定符</h4><ul>
<li>const：在C++中，const限定符对默认存储类型有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。<ul>
<li>在C++下，全局const定义就像是使用了static说明符一样。</li>
<li>可以使用extern关键字覆盖默认的内部链接性<code>extern const int states=50;</code>，鉴于单个const在多个文件间共享，因此只有一个文件可对其进行初始化。</li>
<li>在函数或代码块中声明const时，作用域为代码块。</li>
</ul>
</li>
<li>volatile：即使程序代码没有对内存单元进行修改，其值也可能发生变化。作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile。则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器不要进行这种优化。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/FreeFlow-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/FreeFlow-note/" itemprop="url">FreeFlow Software-based Virtual RDMA Networking for Containerized Clouds(NSDI 2019)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T20:29:43+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/科研论文笔记/" itemprop="url" rel="index">
                    <span itemprop="name">科研论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年2月25日所写，未经允许不得转载。</p>
<h3 id="概述-主要成果"><a href="#概述-主要成果" class="headerlink" title="概述-主要成果"></a>概述-主要成果</h3><ol>
<li>容器的优点：large-scale cloud applications, high resource efficiency, lightweight isolation。RDMA的优点：data-intensive applications, high networking performance, high throughput, low latency, low CPU utilization。</li>
<li>FreeFlow是一个software-based RDMA virtualization framework designed for containerized clouds.</li>
<li>FreeFlow满足云环境下的一些要求，例如多租户隔离，容器迁移的可移植性。</li>
<li>FreeFlow对应用透明，提供几乎裸金属RDMA的网络性能，同时CPU overhead不大。</li>
<li>Application代码修改很少 。FreeFlow在TensorFlow和Spark上测试，提供了和裸金属RDMA媲美的应用程序性能。</li>
<li>boost the performancee of real-world applications by up to 14.6 times more in throughput and about 98% lower in latency over using conventional TCP/IP virtual networking. </li>
<li>开源：<a href="https://github.com/Microsoft/Freeflow" target="_blank" rel="external">https://github.com/Microsoft/Freeflow</a></li>
</ol>
<h3 id="容器云的three-properties-in-networking"><a href="#容器云的three-properties-in-networking" class="headerlink" title="容器云的three properties in networking"></a>容器云的three properties in networking</h3><ol>
<li>Isolation：每个容器都有独立的网络命名空间，包括端口、流表、接口。</li>
<li>Portability：每个容器必须使用虚拟网络来和其他容器交互，它的虚拟IP是固定的，不管宿主机是哪个。 </li>
<li>Controllability：Orchestrators can easily enforce control plane policies 控制平面规则（比如访问控制admission control, routing）和data plane policies数据平面规则（比如QoS, metering计量），这个特性在多租户云环境尤其需要。</li>
</ol>
<p>In TCP/IP-based operations, network- ing is fully virtualized via a software (virtual) switch.</p>
<h3 id="解决问题时的Challenge"><a href="#解决问题时的Challenge" class="headerlink" title="解决问题时的Challenge"></a>解决问题时的Challenge</h3><p>很难完全虚拟化基于RDMA的网络传输。 </p>
<p>It is difficult to modify the control plane states (e.g., routes) in hardware in shared cloud environments, while it is also hard to control the data path since traffic directly goes between RAM and NIC via PCIe bus. 控制平面状态如路由等在硬件上难修改，数据平面流量走RAM和NIC。</p>
<h3 id="Goal-of-the-paper"><a href="#Goal-of-the-paper" class="headerlink" title="Goal of the paper"></a>Goal of the paper</h3><blockquote>
<p>We want cloudbased, containerized applications to be able to use RDMA as efficiently as they would in a dedicated bare-metal cluster; while at the same time achieving the isolation, portability and controllability requirements in containerized clouds.</p>
<p>The goal of FreeFlow is to <strong>provide an virtual interface inside</strong> <strong>each container</strong>, and applications can use RDMA via a virtual network on top of the virtual interface in an unmodified way.</p>
</blockquote>
<p>总结来说就是面向容器的基于软件的RDMA虚拟化 </p>
<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>Currently, there is no mature RDMA virtualization solutions for containers. </p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic1.jpg" alt="RDMA networking solutions that can be potentially used for containers."></p>
<p><strong>现有工作的缺点：</strong> </p>
<ol>
<li><p><strong>基于硬件的I/0虚拟化技术</strong></p>
<blockquote>
<p>Hardware-based I/O virtualization techniques like <strong>SR-IOV</strong> have fundamental portability limitations, since they require reconfiguration of hardware NICs and switches to support migrations of containers. </p>
</blockquote>
</li>
<li><p><strong>控制路径虚拟化解决方案</strong></p>
<blockquote>
<p>Control path virtualization solutions, such as <strong>HyV</strong>, only manipulate the control plane commands for isolation and portability, and they do not have the visibility or control of the data traffic. Because of this, they cannot flexibly support data plane policies needed by cloud providers. </p>
</blockquote>
</li>
<li><p><strong>软件RDMA</strong></p>
<blockquote>
<p>Software-emulated RDMA, e.g., <strong>SoftRoCE</strong>, can easily achieve isolation, portability, and controllability by running RDMA on top of the UDP networking stack and use existing virtual IP networking solutions, but its performance will be limited by UDP. </p>
</blockquote>
</li>
</ol>
<h3 id="FreeFlow设计思路"><a href="#FreeFlow设计思路" class="headerlink" title="FreeFlow设计思路"></a>FreeFlow设计思路</h3><p><strong>技术核心：每个server上都有一个软件虚拟交换机，类似于TCP/IP的VSwitch</strong></p>
<blockquote>
<p>The software virtual switch has the full access to both control path (e.g., address, routing) and data path (e.g., data traffic) of the communications among containers. This design philosophy is similar to existing software virtual switches used for TCP/IP networking in the containerized cloud.</p>
</blockquote>
<p><strong>设计时考虑的两点：</strong> </p>
<ol>
<li><p><strong>透明性 (设计：应用程序和FreeFlow共享内存和文件描述符+尽量少修改应用程序的代码)</strong></p>
<blockquote>
<p><strong>We want FreeFlow to be completed transparent to applications</strong>.  If FreeFlow and a container share the same memory (x4.3) and file descriptor (x4.4), any operations on the underlying physical RDMA NIC will automatically take effect inside the container. </p>
<p><strong>A further problem is that sharing resources transparently to applications is not straightforward,</strong> given that applications do not cooperatively create resources that are shareable. Wedesign methods to convert resource from non-shareable to shareable with no or minimal modifications on application code.</p>
</blockquote>
</li>
<li><p><strong>性能要求（throughput：利用零拷贝，latency：CPU自旋的共享内存进程间channel+限制CPU开销）</strong></p>
<p>提供和裸金属RDMA媲美的吞吐和延迟，吞吐的瓶颈是内存拷贝，延时的瓶颈但是inter-process communication. </p>
</li>
</ol>
<p><strong>Evaluation tools:</strong> </p>
<ul>
<li>standard microbenchmarking tools</li>
<li>real-world data-intensive applications（without any or with minimal modification）<ul>
<li>Spark</li>
<li>TensorFlow</li>
</ul>
</li>
</ul>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><h4 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h4><ol>
<li><p>host mode networking</p>
<p>容器使用宿主机的IP和端口空间，像host OS里的原始进程一样通信。</p>
<p>poor isolation（e.g.,端口冲突）and portability（e.g.,迁移到另一个主机之后必须改IP和端口）</p>
</li>
<li><p>virtual mode networking </p>
<p>namespace完全隔离，容器之间通过overlay网络的软件vSwitch通信。Orchestrators可以完全控制容器迁移，可以实施控制平面和数据平面的策略。</p>
<blockquote>
<p>Indeed, orchestrators like <strong><em>Kubernetes</em></strong> mandate the use of virtual networking mode. A number of software solutions are available to provide virtual networking fabrics for containers, such as <strong><em>Weave</em></strong>, and <strong><em>Docker Overlay</em></strong>.</p>
</blockquote>
</li>
</ol>
<h4 id="Approach-to-virtualize-RDMA-network"><a href="#Approach-to-virtualize-RDMA-network" class="headerlink" title="Approach to virtualize RDMA network"></a>Approach to virtualize RDMA network</h4><blockquote>
<p>One possible approach：the NIC runs a simple layer-2 switch</p>
<p>Use hardware-based solutions such as SR-IOV. As an example shown in Figure 1(a), <strong>with SRIOV, the NIC runs a simple layer-2 switch that merely performs VLAN forwarding</strong>. Hence, all packets generated from and destined to a virtual network have to be directly routed in the underlying physical network. Thus, migrating container C1 to Host2 requires <strong>reconfiguring the physical switch</strong> to route C1’s packets to Host2 rather than Host1.  </p>
<p>缺点： 1) 影响可移植性，迁移需要重新并配置, 2) physical sw需要维护很大一张路由表 </p>
</blockquote>
<p><strong><em>The right approach to virtualizing RDMA network for containers：use a software switch – just like it is done for virtualizing traditional TCP/IP networking.</em></strong></p>
<p>虚拟化RDMA网络的方式使用软件sw，虚拟网络路由完全每个主机里的软件switches实现，physical network只负责把数据包发给不同的主机。软件sw可以提供好的隔离和控制平面的可移植性。也可以用来实现数据平面的网络功能比如QoS和metering计量。</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic2.jpg" alt=""></p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic3.jpg" alt=""></p>
<ol>
<li><p><strong>software FreeFlow router也是一个主机上的容器</strong> </p>
<p>FreeFlow intercepts the communication between applications and physical NICs, and performs control plane and data plane policies inside the software FreeFlow router which runs as another container on the host machine. </p>
</li>
<li><p><strong>router和应用程序共享内存</strong></p>
<p>数据层面上，物理网卡访问router的内存，因为容器和router的内存是同一块物理内存，所以网卡能够直接访问应用程序的内存。</p>
</li>
</ol>
<h3 id="RDMA-API选择"><a href="#RDMA-API选择" class="headerlink" title="RDMA API选择"></a>RDMA API选择</h3><p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic5.png" alt=""></p>
<blockquote>
<p><strong>MPI</strong></p>
<p><strong>Message Passing Interface</strong> is a library specification that enables the development of paral- lel software libraries to utilize parallel computers, clusters, and heterogeneous networks. Mella- nox OFED includes the following MPI implementation over InfiniBand: </p>
<p>Open MPI – an open source MPI-2 implementation by the Open MPI Project </p>
<p>Mellanox OFED also includes MPI benchmark tests such as OSU BW/LAT, Intel MPI Bench- mark, and Presta. </p>
<p><strong>SDP</strong></p>
<p>为了充分利用 RDMA 提供的所有优势，需要使用 RDMA 语义或上层协议，比如 User-Level Direct Access Transport (uDAPL) 或 Message Passing Interface (MPI) 来编写应用程序。然而，对于 RDMA 来说，重写一个 TCP 应用程序可能非常昂贵，因此，针对这种情况开发了一个替代解决方案。该方法称之为 Direct Socket Protocol (SDP)，无需重新编码任何应用程序。</p>
<p>SDP 是一个连线协议，在 RDMA 能力的适配器和套接字之间使用。鉴于这个原因，SDP 对应用程序是透明的，而标准流套接字的实现不需要使用另一个 API 替换。DB2 应用程序和 DB2 服务器无需修改就可在 SDP 或 TCP 上运行。用户只需要在执行应用程序之前通过预加载 SDP 共享库来选择要使用的协议即可。所有关于 TCP 的设置，比如主机名、IP 地址和端口，均无需修改。</p>
<p>例如，一个使用 TCP 连接到数据库服务器的 Java 应用程序也可以使用相同 JDBC URL 在 SDP 上运行。该 SDP 库，一旦预加载之后，将根据一组在 <code>/etc/libsdp.conf</code> 中定义的规则，以及服务器接受的协议来决定必需启动哪个协议。默认规则指定 SDP 作为第一个选项，如果连接失败，SDP 库将退回到 TCP。</p>
<p>一个应用程序可以只使用 SDP，或者只使用 TCP，或者同时使用二者。例如，可以将一个应用程序配置为使用 SDP 实现 DB2 数据库连接以及使用 TCP 实现 LDAP 连接。数据库和 LDAP 服务器可以在不同的物理机器上运行，或者运行在相同的机器上但侦听不同的接口。本文稍后将讨论各种场景以及如何应用规则。</p>
<p><strong>rocket</strong></p>
<p>include <rdma rsocket.h=""></rdma></p>
<p>rsockets is a protocol over RDMA that supports a socket-level API for applications. rsocket APIs are intended to match the behavior of corresponding socket calls, except where noted. rsocket functions match the name and function signature of socket calls, with the exception that all function calls are prefixed with an ‘r’.</p>
<p><strong>iSER(iSCSI RDMA Protocol)</strong></p>
</blockquote>
<p><strong>FreeFlow选择IB Verb API（Verbs）</strong>： The Verbs library and associated drivers allow applications to read, write and monitor the three queues. Actual transfer of the data, including packetization and error recovery, is handled by the NIC. To transparently support Verbs, FreeFlow <strong>creates virtual QPs and CQs in virtual NICs</strong> and relates the operations on them with operations on real QPs and CQs in the physical NICs.</p>
<h4 id="具体架构设计"><a href="#具体架构设计" class="headerlink" title="具体架构设计"></a>具体架构设计</h4><p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic6.png" alt="FreeFlow Architecture"></p>
<ul>
<li><p>FreeFlow network library (FFL)</p>
</li>
<li><p>FreeFlow software router (FFR)</p>
</li>
<li><p>FreeFlow network orchestrator (FFO).</p>
</li>
</ul>
<p>There are various types of RDMA operations including one- and two-sided operations for data transfer, poll- and event-based mechanisms for work completion notification, and TCP/IP and RDMA-CM for the connection establishment.</p>
<p>关于RDMA： </p>
<ol>
<li><p>The Verbs library and associated drivers allow applications to read, write and <strong>monitor</strong> the three queues. Verb libs有监控工具 </p>
</li>
<li><p>Actual transfer of the data, including packetization and error recovery, is handled by the NIC. 网卡负责实际的传输，包括 packetization和错误恢复 </p>
</li>
</ol>
<p>one-sided operations such as WRITE and READ</p>
<p>two-sided operations such as SEND and RECV </p>
<p>为了透明支持Verbs，FreeFlow建了虚拟的QP和CP和物理网卡上的真实QP和CP关联. </p>
<p>Step1: 应用请求支持Verbs的网卡列表，FFL截获了call然后返回容器的虚拟网卡的文本数据。 </p>
<p>Step2: 应用在它的的虚拟网卡上创建QP和CQ，FFR在物理网卡上创建相应的队列（QP和CQ’）。等到FFR完成了队列的创建了之后，QP-IDs和其他元数据信息通过FFL转发给应用。 </p>
<p>Step3: 应用注册了一块内存mem给QP。 FFR分配了相应的的块内存s-mem在它的共享内存IPC空间，和mem的空间一样大，注册s-mem给QP’ </p>
<p>FFR返回了它使用来创造s-mem的ID（一个IPC内存的主机范围的唯一名称）。FFL用这个ID来将s-mem和自己的虚拟内存空间映射起来。 </p>
<p>Step4: 应用请求local QP地址（RDMA的GID）。地址信息将会和另一边共享  local QP和remote QP配对。这一步最后，FFR返回QP’的实际的GID。 </p>
<p>Step5: 应用和远程交换GID和QP-ID。交换信息的通道是TCP/IP或者RDMA-CM。 </p>
<p>Step6：应用使用接受端的GID把它的local QP和远程容器的QP匹配起来。 </p>
<p>Step7：应用修改了local QP的状态，修改为Ready 、Send/Receive state。FFR相应修改QP’的状态。 </p>
<p>One-sided Operation </p>
<ul>
<li>Client需要server 的GID、远程内存buffer的地址，访问内存的security key。 </li>
<li>有两个挑战： <ul>
<li>目标的内存地址mem在远程的容器的虚拟内存里面。但是本地的FFR不知道对应的另一半的s-mem。解决方案：FreeFlow在FFO中为每个FFR建立一个中心化的key-value存储，来学习应用虚拟内存空间和对应FFR虚拟内存空间的s-mem指针。 </li>
<li>远程FFR不知道什么时候把数据拷贝到应用内存里面 </li>
</ul>
</li>
<li>基于零拷贝的机制来支持one-side operation：使得mem和s-mem是一段相同的物理内存，这样FFR不需要做任何拷贝，应用可以直接得到数据 <ul>
<li>第一种方法：写新的API，ibv_malloc和ibv_free来让应用代理内存的创造和删除，缺点是需要改动app的data buffer creation的代码 </li>
<li>第二种方法：FFL截断malloc call。FFL释放va的物理内存然后指定一个FFR的物理共享内存给va，但是va必须是一个内存整页的开头，会降低host的内存利用率 </li>
<li>更推荐第一种方法 </li>
</ul>
</li>
</ul>
<p>Event-based Operations </p>
<p>从CQ中获得通知的方法： </p>
<ol>
<li>应用定期poll CQ看有没有完成的operation </li>
<li>event-based的方法，应用创建一个事件channel，将CQ放进channel中。channel包含一个文件描述符（当opeartion完成时会引发）。 </li>
</ol>
<p>在FreeFlow中，因为raw file descriptor是物理网卡创建的，FFR需要把文件描述符传给FFL，这里FFR和FFL是共享OS kernel的两个进程. </p>
<p>FFL和FFR之间的通信： </p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic4.jpg" alt=""></p>
<p>低延时通信用FastPath： 用一个cpu core 自旋，数据平面无阻塞 </p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li><p>implement FFL by modifying <strong>libibverbs (v1.2.1), libmlx4 (v1.2.1) and librdmacm (v1.1.0)</strong>. </p>
</li>
<li><p>增加了4000 lines of C code to implement FreeFlow’s logic. </p>
</li>
<li><p>implemented FFR from scratch in about 2000 lines of C++ code.  </p>
</li>
<li><p>For FFO, use ZooKeeper to store the user defined information; e.g., IP assignment, access control, resource sharing policies, and memory mapping information for one-sided operations. </p>
</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1207rdmasocketdirect/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1207rdmasocketdirect/</a></li>
<li><a href="https://linux.die.net/man/7/rsocket" target="_blank" rel="external">https://linux.die.net/man/7/rsocket</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/18/RoGUE-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/RoGUE-note/" itemprop="url">RoGUE_RDMA over Generic Unconverged Ethernet(SoCC'18)笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-18T10:49:21+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/科研论文笔记/" itemprop="url" rel="index">
                    <span itemprop="name">科研论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年11月15日所写，未经允许不得转载。</p>
<h3 id="1-问题描述和论文概括"><a href="#1-问题描述和论文概括" class="headerlink" title="1. 问题描述和论文概括"></a>1. 问题描述和论文概括</h3><p>RDMA为用户态提供了直接访问、在应用程序的buffer中传输数据的能力。RDMA旁路了开销较高的系统调用，在硬件上进行组包和包解析操作。允许单向操作，凭借一边的连接可以在硬件上完全处理而不需要主机软件的参与。因此RDMA相比于TCP/IP网络提高了端到端的时延和CPU占用。</p>
<p>RNIC：RDMA网卡</p>
<p>PFC：使用backpressure-based congestion control来给RDMA提供无损网络。PFC是的交换机或者主机当他们的buffer占用超过一定的阀值产生pause frame，然后让发送方节流。有了PFC之后，丢包只会发生在少见的bit损坏上，RNIC就可以用简单的硬件重传方案来恢复。</p>
<p>RoCE的优势：低延迟、低CPU利用率，场景：DC云基础设施服务。</p>
<p>目前RoCE、FPC的缺点：影响网络稳定性、复杂的网络管理、HOL Blocking问题、设备故障和不正确的路由可能导致整个网络死锁、Bufferbloat问题、unfair packet scheduling。</p>
<p>关于FPC问题的相关进展：</p>
<ol>
<li><p>DCQCN缓解了一部分风险，但是没有完全解决这些问题。</p>
</li>
<li><p>最近的研究关于数据中心拥塞控制，DCQCN，缓解了PFC被唤醒的频率。但是还是有问题：从其接收队列停止读取的慢速或恶意主机可以生成暂停帧并拒绝其他租户访问网络。</p>
</li>
<li><p>深入的监控通过识别是否有这样的问题会发生来解决这个问题，但是监控是有限的、不准确的、不能大规模部署。</p>
</li>
</ol>
<p>和SIGCOMM’18的思路一样：不去修复以上这些问题，而是去掉RoCE中的PFC，用新的拥塞控制和新的拥塞导致的丢包恢复方案代替。</p>
<p>该论文提出的RoGUE（RDMA over Generic Unconverged Ethernet)的理念和贡献：不需要依靠PFC。重新思考RDMA拥塞控制和恢复机制，寻找一种保持低延时低CPU优点、但是还能够容忍由于拥塞导致的丢包的方式。（从降低能耗角度），并且增加了UC的丢包恢复。</p>
<h3 id="2-设计难点和挑战"><a href="#2-设计难点和挑战" class="headerlink" title="2. 设计难点和挑战"></a>2. 设计难点和挑战</h3><p>那么问题来了，在哪里和如何实现所想要的（拥塞控制）功能？</p>
<table>
<thead>
<tr>
<th></th>
<th>想法一</th>
<th>想法二</th>
</tr>
</thead>
<tbody>
<tr>
<td>在哪里实现</td>
<td>完全用RNIC硬件实现</td>
<td>完全用软件实现</td>
</tr>
<tr>
<td>pros</td>
<td>1、管理者，特别是本地或者私有云的小规模，不能依靠RNIC提供商来推行硬件改变，因此他们需要了解传统RNIC；大的云比如google和Microsoft可以和提供商推广自定义的交换机网卡特性比如结合了拥塞控制的改进，但是对于企业小中型私有数据中心和云。他们就只能用不灵活的通用的硬件。2、刻在硬件上的方法不能处理交换机上非标准协议实现，也不能处理交换机功能的升级或者端系统拥塞控制协议；3、不利于各种算法的快速实现应用，不利于向下兼容和网络升级。数据中心拥塞控制是快速发展的，每年都有一些新的拥塞控制算法提出来。在硬件上实现拥塞控制算法会降低阻碍这些新算法的应用。4、现有的RNIC丢包恢复机制是设计用来在低错包的情况下工作的。当时PFC关掉时，在有新建连接的burst时流丢包严重，但是RNIC硬件机制恢复这些丢包时效率很低，它花几百毫秒来检测丢包然后恢复。</td>
<td>1、基于包层面的拥塞信号对软件是透明的，传统方案利用的拥塞信号例如丢包和ECN比特都是被RNIC接收，软件无法得到；2、无差别的使用软件驱动的控制（比如使用软件来调整数据包速度使其达到一个合适的速率，或者识别和恢复丢包）会严重破坏RDMA cpu和时延的效益；</td>
</tr>
<tr>
<td>cons</td>
<td>低时延、低CPU利用率、性能高</td>
<td>易于实现</td>
</tr>
</tbody>
</table>
<p>子结论一：需要平衡好硬件和软件的工作范围</p>
<p>RoGUE的实现方式：OpenFabrics Enterprise Distribution(OFED) 用户层面API之上一个中介层，它把RDMA的拥塞控制和丢包恢复功能提到了软件上，利用现有的硬件来协助软件加速性能。</p>
<h3 id="3-RoGUE设计"><a href="#3-RoGUE设计" class="headerlink" title="3. RoGUE设计"></a>3. RoGUE设计</h3><p><strong>软硬件具体分工：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>拥塞控制功能</th>
<th>丢包恢复功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>软件</td>
<td>1、拥塞控制逻辑（依靠时延来估计和响应拥塞，而不是用丢包和ECN bits。原因是：ECN标记只是表示网络拥塞，而时延表示RNIC和网络的拥塞。并且RNIC消耗ECN标记，使得它们对软件是透明的）；2、Segmentation；3、TCP Vegas算法来做拥塞响应调整拥塞窗口（RoGUE软件上使用一个拥塞窗口，结合硬件速率限制器来调整RNIC的数据包，用这两个方法一起保证稳定的拥塞控制行为）</td>
<td>当硬件重传无效的时候，响应慢就会影响吞吐率（burst流丢包），RoGUE使用一个软件上的shadow queue pair来进行重传</td>
</tr>
<tr>
<td>RNIC</td>
<td>1、高性能通信；2、精准时间戳；3、速率限制</td>
<td>当偶尔有丢包发生的时候，RoGUE首先依靠RNIC的硬件重传机制</td>
</tr>
</tbody>
</table>
<p>RoGUE在OFED用户层API上加了一层。把来自应用程序的一个很大的verb集合作为输入。</p>
<p><strong>RoGUE如何实现拥塞控制呢？</strong></p>
<ol>
<li><p>对输入数据进行segmentation</p>
</li>
<li><p>使用RTT和丢包来估算拥塞，用一个窗口来记录verbs</p>
</li>
<li><p>在硬件上进行速率限制来pace out packets</p>
</li>
</ol>
<hr>
<p><strong>为了提供低开销、高性能、拥塞控制和可靠性，需要解决以下问题</strong>：</p>
<p>Q1: 如何取segments的大小？</p>
<p>Q2: 拥塞如何估计和根据现有RNIC的能力和限制有效控制？</p>
<p>Q3: 如何适应不同的底层（RC vs UC）？</p>
<p>Q4: 对由拥塞导致的丢包如何恢复？</p>
<p><strong>A1:</strong></p>
<p>RDMA的一个主要优点是使用大segments并卸载分组化并解析到RNIC可以最大限度地减少CPU的参与和负载。 但是，大的segments还会降低来自网络的反馈的粒度，从而影响拥塞控制。</p>
<p>设计的两个重点考虑：segmentation（RoGUE传输的一个verb有多大）、signaling（RNIC通知软件一个verb完成的频率）。</p>
<p>解决方法：通过实验测试，考虑两个不同的网卡RNICs：10 Gbps ConnectX-3 Pro和100 Gbps ConnectX-4 RNIC，使用ib_read_bw OFED RDMA基准测试工具来做到线速使用不同大小的READs 用dstat工具来测量cpu利用率。此设计优先考虑CPU效率而不是更快的响应。<br>结论：综合考虑拥塞信号频率和CPU，Segmentation大小是64KB（10Gbps），256KB（100bps），每一个batch发送一次拥塞信号给软件层，这里batch就取segmentation的大小。</p>
<p>对于饥饿问题的考虑： RoGUE使用类似于TCP的拥塞窗口来避免过快地发送数据。 因此，在接收器确认先前的发送之前，不会发送新数据。 在高速网络上，拥塞窗口可能小到16KB。 当batch大小超过拥塞窗口时，如果只有一个批次入队，RNIC将会饿死，因为RoGUE在从下一batch中放进队列verbs之前等待先前batch完成的信号，并且直到最后一个数据包发送一个RTT之后才接收到这些信号。为了避免饥饿，RoGUE因此确保在仍有应用程序数据要发送时<strong>至少有2个batch入队</strong>。</p>
<p><strong>A2：</strong></p>
<p>为了控制发送速率，RoGUE依靠（1）基于RTT的拥塞控制窗口（2）硬件限速</p>
<p>因为丢包信号软件不能很快得到，所以用时延作为拥塞信号。使用了一个拥塞窗口，限制了数据包的总数，允许RoGUE ack计时一个batch中的数据包避免拥塞崩溃。但是一个segments中传输的包都以线速传输，因此RoGUE暂时可能会产生一个burst导致丢包，所以RoGUE设置了硬件限速器。综合以上来控制发送速率。</p>
<p>RTT测量方法：跟论文Timely中的一样，对于RC来说，第i个verb的RTT=收到ack的时间戳-开始传输时间戳（=max{入队时间，上一个verb收到ack的时间戳}）-传输时延（=verb的字节数/限速器的配置设置速率）</p>
<p>拥塞窗口调整方法：TCP Vegas（加性增，加性减），简单来说就是在每个batch的最后，用上面得到的当前RTT用来估计预期和实际拥塞窗口的差。</p>
<p><strong>A3：</strong></p>
<p>特定传输设计</p>
<p>RoGUE is the first approach to offer congestion control for the UC transport type. </p>
<p>支持UC传输类型非常重要，因为最近的工作表明它比RC更具可扩展性，因为UC流量可能会影响其他拥塞控制的流量，如RC或TCP流量。</p>
<ul>
<li>RC传输：对于RC上的WRITE和SEND动词，RoGUE严格遵循上述设计。 RC中的主要问题是由READ动词引起的。 首先，保持拥塞窗口是复杂的，因为在相反方向上引起WRITE和READ的拥塞。 为了克服这个问题，RoGUE为单个RC QP维护独立的READ和WRITE拥塞窗口。 其次，READ需要在远程主机上设置速率限制。 RoGUE使用一个接收器端库，该接收器端异步地将限制应用于QP，并在每次更改时使用READ速率限制将WRITE_IMM发送到远程主机。</li>
<li>UC传输：与RC传输不同，RNIC不在UC传输中生成ACK。 因此，不可能立即使用信号来计算网络RTT。 UC传输中的信号仅指示消息已在网络上发送，而不是已由远程RNIC确认。计算RTT的时候完成时间就是一个Verb中最后一个包发送的时间，这篇论文忽略这个误差。</li>
<li>不处理RD传输</li>
</ul>
<p>RoGUE必须能够在UC传输中的RTT测量期间处理分组丢失。 在批次i的测量之前到达的批次j &gt; i的RTT测量被解释为批次i中的分组丢失，并且拥塞窗口积性减小。 当所有未完成的RTT测量都被丢弃时，RoGUE使用超时来重试RTT的采样。 超时后，RoGUE将拥塞窗口重置为其初始大小，并且在成功对RTT进行采样之前不会将新批次排入队列。</p>
<p><strong>A4:</strong></p>
<p>当QP发生error state，使用shadow QP mechanism</p>
<h3 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h3><p>32台servers，用10Gbps的RNIC相连。</p>
<ol>
<li>测量CPU利用率。同时使用QP或TCP流来驱动测试平台中两台机器之间的线速流量（“客户端”发送到“服务器”），比较DCTCP、RoCE和RoGUE、RC和UC传输类型、比较 READ 和WRITE verb的情况。 对于READ，服务器将数据发送到客户端。 我们使用dstat来测量客户端和服务器上每10秒（平均5次运行）的CPU利用率。并且还对DCTCP先进行了优化。</li>
<li>从一个长时间运行的流开始，单独发送，然后添加/删除最多4个额外的流，一次一个。 测量10Gbps网络中RoGUE平均1s间隔的所有五个流的瞬时吞吐量，以及40Gbps网络中RoGUE模拟器的0.1s间隔的瞬时吞吐量。</li>
</ol>
<h3 id="5-实验结果和结论"><a href="#5-实验结果和结论" class="headerlink" title="5. 实验结果和结论"></a>5. 实验结果和结论</h3><p>角度是低能耗（低CPU）+去PFC，对性能的要求是较RoCE持平</p>
<p>没有讨论实现上的开销；忽略了UC的RTT测量时延</p>
<h3 id="最后：背景知识"><a href="#最后：背景知识" class="headerlink" title="最后：背景知识"></a>最后：背景知识</h3><p>使用RDMA，用户空间应用程序调用内核来分配NIC队列，然后建立与远程计算机的连接。 应用程序使用客户端库直接与RNIC连接，以将RDMA verbs发送到队列。</p>
<p>最常用的verb是READ，WRITE，SEND和RECV。 READ从远程主机的内存中获取数据，WRITE将数据传输到远程主机的内存中。 READ和WRITE被认为是“单方面的”，因为它们只需要发送端的主机活动：接收方的RNIC在没有软件参与的情况下处理请求。SEND是“双面的”：它们将消息传送到远程主机，其中软件将RECV verbs排入队列以接收消息。 verbs中的数据大小通常可达2GB。 WRITE_WITH_IMM和SEND_WITH_IMM是WRITE和SEND的变体，它们携带额外的4字节的立即数据，可由远程主机上的软件读取。</p>
<p>READ，WRITE和SEND被发布到发送队列。 RNIC还在建立连接时创建接收队列。 对于READ和WRITE，不需要接收队列，而对于SEND，软件必须将相应的RECV发布给它们。 所有发送和接收队列都配对，每个队列对（QP）与完成队列相关联，该完成队列表示事件完成并提供即时数据。 用户空间应用程序可以使用中断或轮询完成队列。</p>
<p>RDMA支持三种传输类型：可靠连接（RC），不可靠连接（UC）和不可靠数据报（UD）。 所有传输都支持SEND / RECV，因为它们的要求最低。 RC和UC支持WRITE，但只有RC支持READ。 在RC中，RNIC负责丢失后的重传。 相反，UC和UD中的RNIC忽略了数据包丢弃。 RNIC可以通过事件对verb的完成申请发出信号。 如果在verb完成时不需要通知应用程序，则它可以禁用信号，这会降低CPU利用率。</p>
<p>RC的workflow：</p>
<p>1、发送端主机软件将verb放进队列</p>
<p>2、发送端RNIC使用DMA从主机内存中获取要写入的数据，并通过网络以一个或多个数据包发送数据。</p>
<p>4、接收端RNIC把数据写入内存，等到收到最后一个包了之后，就发回一个ACK，发送的RNIC接收ACK</p>
<p>6、发送端选择性产生一个信号通知应用程序WRITE完成了</p>
<p>UC verb类似，除了接收端不会有ack并且信号是当verb最后一个包发送的时候会发出而不是收到ack的时候。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><em>RoGUE: RDMA over Generic Unconverged Ethernet</em>, Yanfang Le (UW-Madison), Brent Stephens (UW-Madison), Arjun Singhvi (UW-Madison), Aditya Akella (UW-Madison), Michael Swift (UW-Madison), <em>SoCC‘18</em></li>
<li><em>Revisiting Network Support for RDMA</em>, Radhika Mittal (Berkeley, USA), Alexander Shpiner (Mellanox, Israel), Aurojit Panda (ICSI and NYU, USA), Eitan Zahavi (Mellanox, Israel), Arvind Krishnamurthy (UW, USA), Sylvia Ratnasamy (Berkeley, USA), Scott Shenker (ICSI and Berkeley, USA), <em>SIGCOMM‘18</em></li>
<li><p><a href="https://dl.acm.org/citation.cfm?doid=190314.190317" target="_blank" rel="external">TCP Vegas Algorithm</a></p>
</li>
<li><p><a href="https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p537.pdf" target="_blank" rel="external"><em>TIMELY: RTT-based Congestion Control for the Datacenter</em></a>, Radhika Mittal(UC Berkeley), Vinh The Lam, Nandita Dukkipati, Emily Blem, Hassan Wassel,Monia Ghobadi(Microsoft), Amin Vahdat, Yaogong Wang, David Wetherall, David Zats, <em>SIGCOMM’2015</em></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/15/fpgas-for-dummies-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/fpgas-for-dummies-note/" itemprop="url">FPGAs For Dummies阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T14:48:35+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/计算机/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年11月15日所写，未经允许不得转载。</p>
<p>原书作者：Andrew Moore with Ron Wilson, Editor-in-Chief, Intel® Programmable Solutions Group</p>
<p><a href="https://plan.seek.intel.com/PSG_WW_NC_LPCD_FR_2018_FPGAforDummiesbook" target="_blank" rel="external"><em>FPGAs For Dummies</em></a> 是Intel官网给出的学习FPGA的入门材料。书几十页，不长，写的简单易懂，适合入门，介绍了FPGA的背景、结构、设计方法、应用，以下为一些重点摘录和笔记。</p>
<h3 id="1-关于FPGA"><a href="#1-关于FPGA" class="headerlink" title="1. 关于FPGA"></a>1. 关于FPGA</h3><p><strong>FPGA</strong>  Field programmable gate arrays，现场可编程门阵列</p>
<p>FPGA是集成电路，使设计人员能够在现场对定制的数字逻辑进行编程。 自20世纪80年代以来，FPGA一直存在，最初的构思是让所有设计团队都能够创建自定义逻辑。</p>
<p><strong>门阵列</strong>是指由半导体厂商准备出已经在硅片上形成了被称为基本单元的逻辑门的母板,通过按照用户希望的电路进行布线,在母板上形成电路的半客户定制品芯片。</p>
<h3 id="2-一个FPGA里面有什么"><a href="#2-一个FPGA里面有什么" class="headerlink" title="2. 一个FPGA里面有什么"></a>2. 一个FPGA里面有什么</h3><p>现代FPGA由可配置SRAM（static random access memory）、high-speed I/O pins、逻辑块、路由组成。</p>
<p>具体来说FPGA包括了可编程的逻辑元素叫 <strong>logic elements（LEs）</strong>、<strong>可重构互连的层次结构（它允许LE彼此物理连接）</strong>、<strong>内存块</strong>。</p>
<p><strong>基本概念</strong>：wire（导线）, logic gate（逻辑门，与或非运算）, register（寄存器）</p>
<p><strong>FPGA上经常使用的components：</strong></p>
<blockquote>
<p>1.<strong>hard IP</strong> is intellectual property built into the FPGA, such as DRAM(dynamic random access memory) controllers, PCIe(peripheral component interconnetct interface express) controllers, clock generators, and big blocks of memory.而现在FPGA已经有很多hard IP了。</p>
</blockquote>
<p>2.不经常使用的功能 例如：可以包括用于雷达或通信的高速串行收发器、信号处理的数字信号处理器（DSP）乘法器-累加器、双核ARM（ARM是微处理器设计的品牌）CPU子系统</p>
<p>今天的高端FPGA可能只有芯片面积的一半可编程逻辑，另一半可能由hard IP组成。</p>
<p>FPGA在向量数学计算方面可以<strong>并行运算</strong>，所以效率高，而microcontroller不行。</p>
<h4 id="FPGA的现代设计流程"><a href="#FPGA的现代设计流程" class="headerlink" title="FPGA的现代设计流程"></a>FPGA的现代设计流程</h4><p>定义需求➡创建架构➡实施系统➡验证</p>
<p>FPGA制造商逐渐将常见功能或知识产权类组件（IP）加入他们的产品。这些IP组件可以是嵌入芯片的硬件、提供给用户的软件，或者——就是FPGA——用户可以加入可编程逻辑的硬件设计。现在可以利用现有IP组件，替换功能块。</p>
<p>早期FGPA设计中，使用硬件描述语言HDL，HDL语言使用硬件术语导线和逻辑门来描述功能块。现在可使用OpenCL等高等级软件编程工具，即使是没有专门硬件技能的软件设计师，也能指定子系统功能、编写代码，以及生成可以载入正常FPGA设计流程的硬件描述文件。</p>
<p>对于仍然需要详细设计的功能块，设计师将使用HDL语言，Verilog是实现FGPA设计的常用HDL语言。</p>
<p>在HDL语言设计编写完成之后，下一步是<strong>编译HDL设计</strong>。在FPGA编程里，综合工具将HDL语言设计作为输入内容，将其转化成逻辑门、寄存器和导线组成的网络。</p>
<p><strong>验证系统设计</strong>：完成代码编译之后，需要进行测试，然后才可将代码配置到FPGA。FPGA测试调试通常在模拟环境下进行。模拟器是一些软件应用，这种应用程序通常可以模拟您的设计行为。模拟过程通过软件实现，并且通过软件，您能够看到每个寄存器的表现。然后，再将您的设计放入FPGA。</p>
<blockquote>
<p>开发人员大都使用一种叫做“Testbench”的工具，来验证FGPA在现实世界能否正常运行。Testbench是由自己设计，将软件仿真与实际硬件相结合，构成了实际的系统模型，该系统中包含了您的FPGA。FPGA大都包含数以万计或十万计的逻辑门，因此您不可能全部测试。Testbench主要用于测试主要设计区域中实际工作的逻辑门，以及在这些区域添加调试辅助工具，让您的设计能够按照您的意愿运行。</p>
</blockquote>
<p><strong>在系统内验证设计</strong>：运行阶段有时也被称为闭环阶段。对于任何硬件器件，都有一定的<strong>性能标准</strong>，比如<strong>功耗</strong>和<strong>速度</strong>，设计师还应该测试和确保每个网状结构（逻辑门之间的导线连接）达到时序要求。最后确保每个时钟和电源管脚都连接到您的FPGA。</p>
<h3 id="3-FPGA系统"><a href="#3-FPGA系统" class="headerlink" title="3. FPGA系统"></a>3. FPGA系统</h3><p>传统的系统设计模型：</p>
<p>架构→ · →实施 → · →整合→ · →</p>
<p><strong>系统设计与决策点</strong></p>
<p>在系统设计中，决策点是需要提出问题的点，例如：</p>
<ul>
<li>系统必须实现哪些功能？</li>
<li>能否利用我的现有设计并做出改动?</li>
<li>有多少系统需要通过软件处理？</li>
<li>我能够购买多少现成硬件？</li>
<li>是否正常运行？</li>
</ul>
<p>需求定义阶段，设计师必须考虑设计限制因素，例如：性能、功耗和尺寸等。系统的功能也很重要——包括哪些功能可见、哪些功能不可见或锁定。最后，设计师对设计进行实验。</p>
<h3 id="4-异构计算与OpenCL"><a href="#4-异构计算与OpenCL" class="headerlink" title="4. 异构计算与OpenCL"></a>4. 异构计算与OpenCL</h3><p><strong>异构计算</strong></p>
<p>数据中心内部的一个重要趋势，即计算架构的转变：从多核CPU转向异构计算。异构计算是指不止一个类型的处理器，实现一个具有专业处理能力的系统。</p>
<p><strong>平行计算</strong></p>
<p><strong>数据平行</strong></p>
<p><strong>任务平行</strong></p>
<h4 id="OpenCL"><a href="#OpenCL" class="headerlink" title="OpenCL"></a>OpenCL</h4><p>OpenCL是一个可编写程序的框架结构，这种程序可在异构平台上执行，包括CPU、GPU、DSP、FPGA以及其他类型处理器。OpenCL包括内核（在硬件设备上执行的功能）开发语言，以及让主程序能够控制内核的应用程序接口（API）开发语言。OpenCL允许进行任务平行计算和数据平行计算。</p>
<p>FPGA原本就是平行计算的。除了典型的数据平行和任务平行，FPGA还提供管道平行：可通过推拉配置生产任务，每个任务从上一个任务接受数据，并且可发生或不发生主机交互。</p>
<p>OpenCL 的优势：</p>
<ul>
<li>简单性和便利性：C语言</li>
<li>代码剖析：判断影响性能的部分</li>
<li>效率：通过OpenCL可生成达到高性能所需的逻辑</li>
<li>异构系统：通过OpenCL可开发面向FPGA、CPU、GPU以及DSP的无缝内核</li>
<li>代码重复利用：OpenCL内核允许提供”便携“代码，可以实现跨项目、种类使用</li>
</ul>
<p>今天OpenCL语言的开发和维护者是柯罗诺斯技术联盟。多数FGPA制造商都为OpenCL FPGA的开发提供SDK。</p>
<h3 id="5-FPGA的五种应用"><a href="#5-FPGA的五种应用" class="headerlink" title="5. FPGA的五种应用"></a>5. FPGA的五种应用</h3><p>Intel内嵌ARM核心的FPGA被称为“FPGA片上系统”（SoC FPGA）</p>
<ol>
<li>单设备电动控制器</li>
<li>电视广播</li>
<li>无线数据</li>
<li>自动驾驶辅助摄像头</li>
<li>高性能计算</li>
</ol>
<blockquote>
<p>协处理器”是用于补充主处理器或中央处理器(CPU)的计算机处理器。协处理器通常被用于执行浮点计算、信号处理、字符串处理、编码或与外围设备的 I/O 接口。协处理器负责密集型运算，从而解放了 CPU，使 CPU 能够专注于计算机的核心功能。</p>
<p>最新的英特尔 FPGA 不仅内嵌 DSP 功能，而且内嵌浮 点计算是硬浮点。所以，程序员们不必将程序从浮点格式转成整 数格式，就可在 FPGA 加速服务器上运行。这种能力在以下几个 方面大有可为 : </p>
<ul>
<li><p>数据应用 :数据库和金融市场提速</p>
</li>
<li><p>功能组件 :供金融市场使用的随机数字发生器，供军事和信号处理应用使用的百万点 FET 晶体管</p>
</li>
<li><p>运算法则 :SRCs CARTE、Impulse 以及 AutoESL 系统生成 算法 </p>
</li>
</ul>
</blockquote>
<hr>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p><strong>ARM</strong> Advanced RISC Machine，进阶精简指令集机器</p>
<p><strong>ASSP</strong>  application-specific standard product</p>
<p><strong>DSP</strong> digital signal processor：frees designers from reinventing the wheel each time they need to add these common pieces to their systems. </p>
<p>ASICs和ASSPs的介绍：p11</p>
<p><strong>hard IP</strong> intellectual property</p>
<p><strong>SoC </strong>system on chips，片上系统</p>
<p><strong>SDI</strong> 串行数字接口</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/20/Git-server-setup-hooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/20/Git-server-setup-hooks/" itemprop="url">Git服务器带自动化部署安装过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T21:16:27+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月20日所写，未经允许不得转载。</p>
<ul>
<li>首先安装Git</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install git</div></pre></td></tr></table></figure>
<ul>
<li>创建git用户组和用户</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">groupadd git</div><div class="line">adduser git</div><div class="line">passwd git</div></pre></td></tr></table></figure>
<ul>
<li>创建Git证书登录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /home</div><div class="line">mkdir git</div><div class="line">cd /home/git</div><div class="line">mkdir .ssh</div><div class="line">chmod 700 .ssh</div><div class="line">touch .ssh/authorized_keys</div><div class="line">chmod 600 .ssh/authorized_keys</div></pre></td></tr></table></figure>
<ul>
<li>然后把自己的客户端的Git公钥加入authorized_keys文件中，一行一个</li>
<li>初始化Git仓库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cd /home</div><div class="line">mkdir gitrepo</div><div class="line">chown git:git gitrepo</div><div class="line">cd gitrepo</div><div class="line">git init --bare test.git # 初始化裸仓库</div><div class="line">chown -R git:git /home/gitrepo</div><div class="line">Initialized empty Git repository in /home/gitrepo/test.git/</div><div class="line">chown -R git:git test.git</div></pre></td></tr></table></figure>
<ul>
<li>克隆仓库</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone git@Server_IP:/home/gitrepo/test.git</div></pre></td></tr></table></figure>
<ul>
<li>编写自动更新钩子</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /home/gitrepo/test.git/hooks/</div><div class="line">vim post-receive</div></pre></td></tr></table></figure>
<ul>
<li>添加以下内容</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/sh </div><div class="line">git --work-tree=your_work_dir --git-dir=/root/gitrepo/test.git checkout -f</div></pre></td></tr></table></figure>
<ul>
<li>保存退出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x post-receive # 给钩子文件添加可执行权限</div></pre></td></tr></table></figure>
<p>如果push之后工作部署路径看不到代码的话，就手动运行一下post-receive一下，然后之后push的就都有了（这个问题纠结了我半天）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/13/Go语言字符串处理总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/Go语言字符串处理总结/" itemprop="url">Go语言字符串处理总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T20:17:51+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/Go语言/" itemprop="url" rel="index">
                    <span itemprop="name">Go语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月13日所写，未经允许不得转载。</p>
<p>正好最近用到了一些字符串，就总结了一下Golang中的字符串处理函数，主要是Golang中的strings包：</p>
<ol>
<li><code>Count(s string, str string) int</code>：计算字符串str在s中的非重叠个数。如果str为空串则返回s中的字符（非字节）个数+1。</li>
<li><code>Index(s string, str string) int</code> ：返回子串str在字符串s中第一次出现的位置。如果找不到则返回-1；如果str为空，则返回0。</li>
<li><code>LastIndex(s string, str string) int</code>： 返回子串str在字符串s中最后一次出现的位置。如果找不到则返回-1；如果str为空则返回字符串s的长度。</li>
<li><code>IndexRune(s string, r rune) int</code> ：返回字符r在字符串s中第一次出现的位置。如果找不到则返回-1。</li>
<li><code>IndexAny(s string, str string) int</code> ：返回字符串str中的任何一个字符在字符串s中第一次出现的位置。如果找不到或str为空则返回-1。</li>
<li><code>LastIndexAny(s string, str string) int</code>： 返回字符串str中的任何一个字符在字符串s中最后一次出现的位置。如果找不到或str为空则返回-1。</li>
<li><code>Contains(s string, str string) bool</code>：判断字符串s中是否包含个子串str。包含或者str为空则返回true。</li>
<li><code>ContainsAny(s string, str string) bool</code>：判断字符串s中是否包含个子串str中的任何一个字符。包含则返回true，如果str为空则返回false。</li>
<li><code>ContainsRune(s string, r rune) bool</code>：判断字符串s中是否包含字符r。</li>
<li><code>SplitN(s, str string, n int) []string</code>：以str为分隔符，将s切分成多个子串，结果中<strong>不包含</strong>str本身。如果str为空则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分，最后一个n包含了所有剩下的不切分。如果n为0，则返回nil；如果n小于0，则不限制切分个数，全部切分。</li>
<li><code>SplitAfterN(s, str string, n int) []string</code>：以str为分隔符，将s切分成多个子串，结果中<strong>包含</strong>str本身。如果str为空，则将s切分成Unicode字符列表。如果s 中没有str子串，则将整个s作为 []string 的第一个元素返回。参数n表示最多切分出几个子串，超出的部分将不再切分。如果n为0，则返回 nil；如果 n 小于 0，则不限制切分个数，全部切分。</li>
<li><code>Split(s, str string) []string</code>：以str为分隔符，将s切分成多个子切片，结果中<strong>不包含</strong>str本身。如果str为空，则将s切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。</li>
<li><code>SplitAfter(s, str string) []string</code>：以str为分隔符，将s切分成多个子切片，结果中<strong>包含</strong>str本身。如果 str 为空，则将 s 切分成Unicode字符列表。如果s中没有str子串，则将整个s作为[]string的第一个元素返回。</li>
<li><code>Fields(s string) []string</code>：以连续的空白字符为分隔符，将s切分成多个子串，结果中不包含空白字符本身。空白字符有：\t, \n, \v, \f, \r, ‘ ‘, U+0085 (NEL), U+00A0 (NBSP) 。如果 s 中只包含空白字符，则返回一个空列表。</li>
<li><code>FieldsFunc(s string, f func(rune) bool) []string</code>：以一个或多个满足f(rune)的字符为分隔符，将s切分成多个子串，结果中不包含分隔符本身。如果s中没有满足f(rune)的字符，则返回一个空列表。</li>
<li><code>Join(s []string, str string) string</code>：将s中的子串连接成一个单独的字符串，子串之间用str分隔。</li>
<li><code>HasPrefix(s string, prefix string) bool</code>：判断字符串s是否以prefix开头。</li>
<li><code>HasSuffix(s, suffix string) bool</code> ：判断字符串s是否以prefix结尾。</li>
<li><code>Map(f func(rune) rune, s string) string</code>：将s中满足f(rune)的字符替换为f(rune)的返回值。如果f(rune)返回负数，则相应的字符将被删除。</li>
<li><code>Repeat(s string, n int) string</code>：将n个字符串s连接成一个新的字符串。</li>
<li><code>ToUpper(s string) string</code>：将s中的所有字符修改为其大写格式。对于非ASCII字符，它的大写格式需要查表转换。</li>
<li><code>ToLower(s string) string</code>：将s中的所有字符修改为其小写格式。对于非ASCII字符，它的小写格式需要查表转换。</li>
<li><code>ToTitle(s string) string</code>：将s中的所有字符修改为其Title格式，大部分字符的Title格式就是Upper格式，只有少数字符的Title格式是特殊字符。这里的ToTitle主要给Title函数调用。</li>
<li><code>TrimLeftFunc(s string, f func(rune) bool) string</code>：删除s头部<strong>连续的</strong>满足f(rune)的字符。</li>
<li><code>TrimRightFunc(s string, f func(rune) bool) string</code>：删除s尾部<strong>连续的</strong>满足f(rune)的字符。</li>
<li><code>TrimFunc(s string, f func(rune) bool) string</code>：删除s首尾<strong>连续的</strong>满足f(rune)的字符。</li>
<li><code>IndexFunc(s string, f func(rune) bool) int</code>：返回s中第一个满足f(rune) 的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。</li>
<li><code>LastIndexFunc(s string, f func(rune) bool) int</code>：返回s中最后一个满足f(rune)的字符的字节位置。如果没有满足 f(rune) 的字符，则返回 -1。</li>
<li><code>Trim(s string, str string) string</code>：删除s首尾连续的包含在str中的字符。</li>
<li><code>TrimLeft(s string, str string) string</code>：删除s头部连续的包含在str中的字符串。</li>
<li><code>TrimRight(s string, str string) string</code>：删除s尾部连续的包含在str中的字符串。</li>
<li><code>TrimSpace(s string) string</code>：删除s首尾连续的的空白字符。</li>
<li><code>TrimPrefix(s, prefix string) string</code>：删除s头部的prefix字符串。如果s不是以prefix开头，则返回原始s。</li>
<li><code>TrimSuffix(s, suffix string) string</code>：删除s尾部的suffix字符串。如果s不是以suffix结尾，则返回原始s。（只去掉一次，注意和TrimRight区别）</li>
<li><code>Replace(s, old, new string, n int) string</code>：返回s的副本，并将副本中的old字符串替换为new字符串，替换次数为n次，如果n为-1，则全部替换；如果 old 为空，则在副本的每个字符之间都插入一个new。</li>
<li><code>EqualFold(s1, s2 string) bool</code>：比较UTF-8编码在小写的条件下是否相等，不区分大小写，同时它还会对特殊字符进行转换。比如将“ϕ”转换为“Φ”、将“Ǆ”转换为“ǅ”等，然后再进行比较。</li>
<li>“==”比较字符串是否相等，区分大小写，返回bool。</li>
<li><code>Compare(s1 string, s2 string) int1</code>：比较字符串，区分大小写，比”==”速度快。相等为0，不相等为-1。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/13/Git与GitHub总结笔记-参考《GitHub入门与实践》/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/13/Git与GitHub总结笔记-参考《GitHub入门与实践》/" itemprop="url">Git与GitHub总结笔记-参考《GitHub入门与实践》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-13T19:53:20+08:00">
                2018-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月13日所写，未经允许不得转载。</p>
<p>前言：虽然已经用过一段时间自己的git服务器和github，但是看到这本书还是想深入了解一下。正好最近微软收购了Github，因此写了这篇笔记纪念一下2333，并总结了一下Git的常用命令。《GitHub入门与实践》这本书深入介绍了关于Git的知识，有利于加深对Git的理解，还是比较推荐的。</p>
<ul>
<li><p>关于GitHub</p>
<ol>
<li><p>GitHub总部：旧金山</p>
</li>
<li><p>吉祥物：Octocat</p>
</li>
<li><p>不只是Git仓库托管服务</p>
</li>
<li><p>协同工作的软件：群件（Groupware）、CRM（Customer Relationship Management，顾客关系管理）</p>
</li>
<li><p>Pull Request 是指开发者在本地对源代码进行更改后，向GitHub 中托管的Git 仓库请求合并的功能。不但能轻松查看源代码的前后差别，还可以对指定的一行代码进行评论。</p>
</li>
<li><p>GitHub Flavored Markdown（GFM）语法</p>
</li>
<li><p>@用户：输入“@ 组织名”可以让属于该组织的所有成员收到通知</p>
</li>
<li><p>输入“# 编号”，会连接到该仓库所对应的Issue 编号。</p>
</li>
<li><p>社会化编程的概念 </p>
</li>
<li><p>Issue 功能，是将一个任务或问题分配给一个Issue 进行追踪和管理</p>
<p>的功能</p>
</li>
<li><p>Wiki：开发文档或手册的编写 </p>
</li>
<li><p>Linux 的创始人Linus Torvalds 在2005 年开发了Git 的原型程序。当时，由于在Linux 内核开发中使用的既有版本管理系统的开发方许可证发生了变更，为了更换新的版本管理系统，Torvalds 开发了Git。</p>
</li>
</ol>
</li>
<li><p>Git安装</p>
<ol>
<li><p>关于windows换行符的处理</p>
<p>GitHub 中公开的代码大部分都是以Mac 或Linux 中的LF（LineFeed）换行。然而，由于Windows 中是以CRLF（Carriage Return ＋Line Feed）换行的，所以在非对应的编辑器中将不能正常显示。</p>
<p>Git 可以通过设置自动转换这些换行符。使用Windows 环境的各位，请选择推荐的“Checkout Windows-style, commit Unix-style line endings”选项。换行符在签出时会自动转换为CRLF，在提交时则会自动转换为LF。</p>
</li>
<li><p>初始设置</p>
<ul>
<li><p>首先来设置使用Git 时的姓名和邮箱地址。名字请用英文输入。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Firstname Lastname&quot;</div><div class="line">$ git config --global user.email &quot;your_email@example.com&quot;</div></pre></td></tr></table></figure>
<p>这个命令，会在“~/.gitconfig”中以如下形式输出设置文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[user]</div><div class="line">name = Firstname Lastname</div><div class="line">email = your_email@example.com</div></pre></td></tr></table></figure>
<p>想更改这些信息时，可以直接编辑这个设置文件。这里设置的姓名和邮箱地址会用在Git 的提交日志中</p>
</li>
<li><p>提高命令输出的可读性 </p>
<p>将color.ui 设置为auto 可以让命令的输出拥有更高的可读性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global color.ui auto</div></pre></td></tr></table></figure>
<p>“~/.gitconfig”中会增加下面一行。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[color]</div><div class="line">ui = auto</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>GitHub</p>
<ul>
<li><p>头像</p>
<p>在GitHub 上随处可见的头像（账户独有的标识）是通过Gravatar服务显示的。</p>
</li>
<li><p>创建SSH Key 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</div></pre></td></tr></table></figure>
<p><em>Your identification has been saved in <code>/Users/your_user_directory/.ssh/id_rsa</code>.</em></p>
<p><em>Your public key has been saved in <code>/Users/your_user_directory/.ssh/id_rsa.pub</code>.</em></p>
<p>id_rsa 文件是私有密钥，id_rsa.pub 是公开密钥。 </p>
</li>
<li><p>验证：用手中的私人密钥与GitHub 进行认证和通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
</li>
<li><p>.gitignore 文件 用来描述Git 仓库中不需管理的文件与目录。 </p>
</li>
<li><p>在GitHub 上，有修正BSD 许可协议、Apache 许可协议等多种许可协议供人们选择，不过大多数软件都使用MIT 许可协议。实际使用时， 只需将LICENSE 文件加入仓库， 并在README.md 文件中声明使用了何种许可协议即可。</p>
</li>
</ul>
</li>
<li><p>自己总结了一下基本命令</p>
<ul>
<li><p><code>git init</code>初始化仓库：如果初始化成功，执行了git init命令的目录下就会生成.git 目录。这个.git 目录里存储着管理当前目录内容所需的仓库数据。在Git 中，我们将这个目录的内容称为“附属于该仓库的工作树”。</p>
</li>
<li><p><code>git status</code>查看仓库的状态。</p>
</li>
<li><p><code>git add</code>命令将文件加入暂存区。</p>
</li>
<li><p><code>git commit -m &quot;提交信息&quot;</code>将当前暂存区中的文件实际保存到仓库的历史记录中。</p>
<ul>
<li><p>记录详细提交信息的话，不加-m，执行后会启动编辑器。</p>
<p>在编辑器中记述提交信息的格式如下。</p>
<p>● 第一行：用一行文字简述提交的更改内容</p>
<p>● 第二行：空行</p>
<p>● 第三行以后：记述更改的原因和详细内容</p>
<p>在以#（井号）标为注释的Changes to be committed（要提交的更改）栏中，可以查看本次提交中包含的文件。将提交信息按格式记述完毕后，请保存并关闭编辑器，以#（井号）标为注释的行不必删除。</p>
</li>
<li><p>如果在编辑器启动后想中止提交，请将提交信息留空并直接关闭编辑器，随后提交就会被中止。</p>
</li>
<li><p>写在一起：<code>git commit -am &quot;&quot;</code></p>
</li>
</ul>
</li>
<li><p><code>git log</code>命令查看提交日志 。</p>
</li>
<li><p><code>git log --pretty=short</code>只显示提交信息的第一行 。只要在git log命令后加上目录名，便会只显示该目录下的日志。如果加的是文件名，就会只显示与该文件相关的日志。</p>
</li>
<li><p><code>git log -p</code>查看提交所带来的改动</p>
</li>
<li><p><code>git push</code>更新仓库</p>
</li>
<li><p><code>git diff</code>查看当前工作树与暂存区的差别</p>
</li>
<li><p><code>git diff HEAD</code>查看工作树和最新提交的差别。在执行git commit命令之前先执行 git diff HEAD命令，查看本次提交与上次提交之间有什么差别，等确认完毕后再进行提交。这里的HEAD 是指向当前分支中最新一次提交的指针。</p>
</li>
<li><p><code>git branch</code>命令可以将分支名列表显示，同时可以确认当前所在分支。“*”表示这是我们当前所在的分支。</p>
</li>
<li><p><code>git checkout -b &quot;branch name&quot;</code>以当前的master 分支为基础创建并切换到新的分支</p>
</li>
<li><p><code>git checkout -</code>用“-”（连字符）代替分支名，就可以切换至上一个分支。</p>
</li>
<li><p><code>git merge --no-ff feature-A</code>合并分支。为了在历史记录中明确记录下本次分支合并，需要创建合并提交。因此，在合并时加上–no-ff参数。随后编辑器会启动，用于录入合并提交的信息。 将编辑器中显示的内容保存，关闭编辑器。</p>
</li>
<li><p><code>git log --graph</code>以图表形式查看分支 </p>
</li>
<li><p><code>git reset</code>回溯历史版本，要让仓库的HEAD、暂存区、当前工作树回溯到指定状态，需要用</p>
<p>到git reset –hard命令。只要提供目标时间点的哈希值A就可以完全恢复至该时间点的状态。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git reset --hard fd0cbf0d4a25f747230694d95cac1be72d33441d</div><div class="line">HEAD is now at fd0cbf0 Add index</div></pre></td></tr></table></figure>
<p>git log命令只能查看以当前状态为终点的历史日志。使用<code>git reflog</code>命令，查看当前仓库的操作日志。</p>
</li>
<li><p><code>git commit --amend</code>修改上一条提交信息，执行命令后，编辑器就会启动。</p>
</li>
<li><p><code>git rebase -i</code>压缩历史，<code>git rebase -i HEAD~2</code>选定当前分支中包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开。</p>
</li>
<li><p>错字漏字等失误称作typo，将提交信息记为”Fix typo”。 </p>
</li>
<li><p><code>git remote add</code>设置成本地仓库的远程仓库</p>
<p><code>$ git remote add origin git@github.com:github-book/git-tutorial.git</code> 按照上述格式执行<code>git remote add</code>命令之后，Git 会自动将<code>git@github.com:github-book/git-tutorial.git</code>远程仓库的名称设置为origin（标识符）。</p>
<p>或者<code>git remote add origin https://github.com/&lt;your_username&gt;/gitname.git</code></p>
</li>
<li><p><code>git push -u origin master</code>将当前分支下本地仓库中的内容推送给远程仓库，。-u参数可以在推送的同时，将origin 仓库的master分支设置为本地仓库当前分支的upstream（上游）。添加了这个参数，将来运行git pull命令从远程仓库获取内容时，本地仓库的这个分支就可以直接从origin 的master 分支获取内容，省去了另外添加参数的麻烦。</p>
</li>
<li><p>推送至master 以外的分支：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout -b feature-D</div><div class="line">git push -u origin feature-D</div></pre></td></tr></table></figure>
<p> 在本地仓库中创建feature-D 分支，并将它以同名形式push 至远程仓库。 将它push 给远程仓</p>
<p>库并保持分支名称不变。</p>
</li>
<li><p><code>git branch -a</code>命令查看当前分支的相关信息。添加-a参数可以同时显示本地仓库和远程仓库的分支信息。</p>
</li>
<li><p><code>git checkout -b feature-D origin/feature-D</code>将feature-D 分支获取至本地仓库。 </p>
</li>
<li><p><code>git pull origin feature-D</code>使用git pull 命令，将本地的feature-D 分支更新到最新状态。</p>
</li>
<li><p>强行pull命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch --all	// 只是下载代码到本地，不进行合并操作</div><div class="line">git reset --hard origin/master 	// 把HEAD指向最新下载的版本</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/06/hexo使用总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/06/hexo使用总结/" itemprop="url">hexo使用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-06T11:19:29+08:00">
                2018-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/使用总结/" itemprop="url" rel="index">
                    <span itemprop="name">使用总结</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
             <!--test文章摘要：转载请注明文章出处-->
<ul>
<li><p>新建页面</p>
<p><code>hexo new &quot;文章name&quot;</code>或者<code>hexo n &quot;文章name&quot;</code></p>
</li>
<li><p>草稿</p>
<p><code>hexo publish</code>=<code>hexo p</code></p>
</li>
<li><p>生成</p>
<p><code>hexo generate</code>=<code>hero g</code></p>
</li>
<li><p>启动服务器预览</p>
<p><code>hexo server</code>=<code>hexo s</code></p>
</li>
<li><p>部署</p>
<p><code>hexo deploy</code>=<code>hexo d</code>或者与g合并写成<code>hexo d -g</code>，有时候需要先用<code>hexo clean</code>清除cache file</p>
</li>
<li><p>显示草稿</p>
<p><code>hexo --draft</code></p>
</li>
<li><p>设置多标签：</p>
<p>tags后面这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tags: [标签1,标签2,标签3]</div></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/Voyager-Complete-Container-State-Migration-ICDCS-2017/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/Voyager-Complete-Container-State-Migration-ICDCS-2017/" itemprop="url">Voyager-Complete Container State Migration (ICDCS 2017)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T12:14:30+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/科研论文笔记/" itemprop="url" rel="index">
                    <span itemprop="name">科研论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年3月22日所写，未经允许不得转载。</p>
<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><ul>
<li><p>容器虚拟化的优点</p>
<ol>
<li>内存小</li>
<li>启动快</li>
</ol>
</li>
<li><p>建立PaaS、SaaS云</p>
</li>
<li><p>本文提出Voyager及时动态容器迁移服务</p>
</li>
<li><p>基于Open Container Initiative(OCI) principles</p>
<p>  OCI的使命是推动围绕容器技术制定一套共同的、最小的、开放的标准和规范。</p>
<p>  governing principles of the OCI：</p>
<ul>
<li>Technology leadership</li>
<li>Influence through contribution</li>
<li>Limited scope, limited politics</li>
<li>Minimalist structure</li>
<li>Representative leadership</li>
<li>Adherence to anti-trust regulations</li>
</ul>
</li>
<li><p>Voyager是一种文件系统无关、提供商无关的迁移服务，提供一致的全系统的迁移</p>
</li>
<li>将CRIU检查点/恢复用户空间（Checkpoint/Restore in Userspace）和联合挂载数据联合能力（Data federation capabilities of union mounts）结合起来最小化迁移停机时间</li>
<li><p><strong>概念1—CRIU检查点/恢复用户空间（Checkpoint/Restore in Userspace）</strong></p>
<blockquote>
<p>检查点/恢复用户空间（或CRIU）是Linux操作系统的软件工具，为Linux实现检查点/恢复功能。 使用此工具，您可以冻结正在运行的应用程序（或其中的一部分），并将其检查为磁盘上的文件集合。 然后，您可以使用这些文件来恢复应用程序，并在冻结期间完全运行它。 有了这个功能，应用程序实时迁移，快照，远程调试，以及其他许多事情都是可能的。</p>
</blockquote>
</li>
<li><p>利用源和目的主机之间数据的联合视图，Voyager容器可以立刻在目标主机上恢复操作，在后台实施磁盘状态转移，以按需的方式（Copy-on-Write）或者通过lazy replication</p>
</li>
</ul>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul>
<li><p>现有的迁移服务的缺陷</p>
<ul>
<li>提供仅内存的迁移</li>
<li>依靠指定文件系统去迁移持久性存储（migrate persistent storage ）</li>
</ul>
</li>
<li><p><strong>概念2—数据联合</strong></p>
<p>  从不同的源汇聚数据到一个虚拟的数据库，用数据联合软件建立的这个虚拟数据库不包含数据本身，它包含的是实际数据的信息和位置，实际的数据仍在原来的位置。</p>
<p>  数据联合技术可以被用作数据仓库，以节省建立一个永久的物理的关系型数据库的代价。</p>
<blockquote>
<p>Data federation software is programming that provides an organization with the ability to aggregate data from disparate sources in a virtual database so it can be used for business intelligence (BI) or other analysis. The virtual database created by data federation software doesn’t contain the data itself. Instead, it contains information about the actual data and its location (see metadata). The actual data is left in place.</p>
<p>Data federation technology can be used in place of a data warehouse to save the cost of creating a permanent, physical relational database. It can also be used as an enhancement to add fields or attributes that are not supported by the data warehouse application programming interface (API). This approach is especially useful if some of an organization’s data is stored offsite by a third-party cloud service provider. It allows the person performing the analysis to aggregate and organize data quickly without having to request synchronization logic or copy the data until it’s absolutely necessary.</p>
<p>Making a single call to multiple data sources and then integrating and organizing the data in a middleware layer is also called data virtualization, enterprise information integration (EII) and information-as-a-service, depending on the vendor.</p>
</blockquote>
</li>
<li><p>Enhancements中开源的部分</p>
<ul>
<li>内存迁移</li>
<li>符合OCI规则</li>
<li>支持多数据存储类型（rootfs、本地和网络附加数据卷）</li>
</ul>
</li>
</ul>
<h1 id="Background-and-相关工作"><a href="#Background-and-相关工作" class="headerlink" title="Background and 相关工作"></a>Background and 相关工作</h1><h2 id="VM迁移"><a href="#VM迁移" class="headerlink" title="VM迁移"></a>VM迁移</h2><p>不同的供应商使用不同的虚拟磁盘（vDisk）格式（例如vmdk、VHD、qcow2）来封装一个虚拟机的持久性状态，通过专有系统管理程序辅助（例如vMotion、Hyper-V动态迁移、第三方工具）或通过hypervisor之间的显式vDisk转化来迁移。</p>
<p>已有VMs上的提供商不可知的基于文件的迁移方案，例如I2Map和racemi，但是需要在系统中安装额外的agent。</p>
<h2 id="容器迁移"><a href="#容器迁移" class="headerlink" title="容器迁移"></a>容器迁移</h2><ul>
<li>容器被OCI标准化，制定一个容器镜像格式的工业标准——一个文件包或rootfs和多数据卷，这些是主机文件系统上重要的目录</li>
<li>可以为容器设计一个通用的基于文件的迁移方案。</li>
<li>有些容器云提供VM来放容器，主要是减少对容器安全性和隔离性的担心，其他的是直接在云主机上运行容器。为了迁移安装VM违反了使用容器进行应用部署的优势。</li>
<li>尽管看上去对于无状态的容器化应用来说，容器迁移是冗余的，但是对于有些状态微服务应用（例如Mysql、cassandra）、消息代理（kafka）、状态协调服务（zookeeper）来说是有意义的。</li>
<li>标准框架：Kubernetes StatefulSet</li>
<li>状态容器的可移植性——已有的解决方案：ClusterHQ’s Flocker, Virtuozzo, Picocenter<ul>
<li>Flocker<ol>
<li>主要是一个主要针对容器的数据管理解决方案。</li>
<li>通过重新附加网络存储器的方式支持网络附加存储（NAS）后端（如Amazon EBS，Openstack Cinder，VMware vSphere等）的迁移。</li>
<li>本地附加数据卷的迁移仅支持ZFS文件系统。</li>
<li>对比：Voyager是一个通用的文件系统不可知、提供商不可知的迁移解决方案。</li>
</ol>
</li>
<li>Virtuozzo<ol>
<li>是一个裸机虚拟化解决方案，包括容器虚拟化</li>
<li>促进了容器动态迁移的零停机时间</li>
<li>在迁移过程中，首先向目标主机转移容器文件系统和虚拟内存，一旦转移完成之后，它将冻结所有容器进程和关闭网络，然后把内存状态dump到文件中，拷贝dump文件到目标主机。</li>
<li>任何在最后一次转移之后改变的内存和磁盘块都迁移到目标主机，然后容器恢复。</li>
<li>隐含的假设是变化的内存页和磁盘块的数量（<em>deltas</em>）很小，因此中断时间是微小的。（缺陷）但是对于数据密集型应用，这些<em>deltas</em>特别是持久性数据变化可能很大。</li>
<li>对比：Voyager和它两方面不同：a. Voyager是一个及时零拷贝迁移解决方案，在将整个数据拷贝到目标主机之前立刻迁移容器。b. Voyager不需要Virtuozzo的第二次数据转移的任务，因此应用停机时间会更小。c. Voyager提供一些特性比如说数据联合访问、双带宽数据复制、遵循OCI原则，这些事现有的容器迁移解决方案不具备的。</li>
</ol>
</li>
<li>Picocenter<ol>
<li>一个允许换出对象存储云里面不活跃的容器、按需求换进（活跃的容器）的系统。</li>
<li>它使用CRIU来获取和迁移内存状态和持久性状态的<em>btrfs</em>文件系统快照。</li>
<li>提了一个内存的<em>ActiveSet</em>功能：内存中的页被恢复为容器访问 and lazily。</li>
<li>同样也是一个特定于文件系统的解决方案，并未针对容器迁移用例进行优化。（缺陷）</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>CRIU Page server model</strong></p>
<p><a href="https://criu.org/Page_server" target="_blank" rel="external">https://criu.org/Page_server</a></p>
<blockquote>
<p><strong>Page server</strong> is a component of CRIU that allows to copy (rather than dump) user memory to a destination system during the course of live migration. It is also used for <strong>lazy migration</strong>.</p>
</blockquote>
<p>Page server： 在动态迁移期间，允许拷贝用户内存 到 目的系统而不是dump的方式。</p>
<p><strong>Lazy migration</strong></p>
<p><a href="https://criu.org/Lazy_migration" target="_blank" rel="external">https://criu.org/Lazy_migration</a></p>
<blockquote>
<p>Lazy, or post-copy memory migration, allows to minimize application downtime. Unlike pre-copy memory migration, lazy migration does not copy the task’s memory, but rather keeps the memory pages at the source node. Only the minimal task state required to start the application is copied to the destination node and the task is resumed there. When the task accesses missing memory pages, criu processes the page faults, transfers the required page from the source node and injects it into the running task address space.</p>
</blockquote>
<p>定义：不像pre-copy memory migration，lazy migration不拷贝task的内存，将内存页还留在源节点。只拷贝启动应用需要的最小的任务状态到目的节点，然而任务在目的节点恢复。如果task需要访问缺少的内存页，CRIU就处理缺页，从源节点传送需要的页，将它插入到正在运行的task的地址空间。</p>
<h1 id="设计和实现"><a href="#设计和实现" class="headerlink" title="设计和实现"></a>设计和实现</h1><ul>
<li><p>容器的镜像存储方式有两种：rootfs 和 数据卷</p>
<ol>
<li>根据OCI规范，每个容器镜像都存储在一个文件系统包中，它在解包后变成主机文件系统中的另一个目录——rootfs。在容器初始化的时候，所有运行时的环境改变（如，新的包的安装）以及数据改变（如应用程序状态和日志）在默认情况下会被存放在rootfs中。因为运行时状态会动态改变，因此在本地文件系统中托管rootfs也符合性能观点。</li>
<li>主机文件系统的任何目录都可以绑定挂载到容器内作为数据卷。这样的一个卷也可以是一个挂载在主机上的网络附属文件系统。类似地，尽管很少，任何主机上的块设备也可以映射到容器中。对于不稳定的状态，容器会通过cgroups共享控制主机的内存。</li>
</ol>
</li>
<li><p>容器迁移的步骤</p>
<ol>
<li>发现该容器的所有数据终端、移动它们的状态和内存状态，并保持源主机和目标主机之间的一致。</li>
<li>内存中的状态迁移可以在用户空间内通过CRIU来实现。</li>
<li>同样，任何网络附属存储可以通过把它从源主机中卸载，并将其挂载到目标主机上来实现。</li>
<li>Voyager提供了用户空间级的文件系统无关的本地持续性容器状态迁移，同时保证跨这些状态的一致性，以及最小化应用程序的停机时间。</li>
<li>图1展示了完整的Voyager的编排框架。我们主要是跨三个不同的数据存储来迁移容器状态，即内存中、本地文件系统、网络文件系统。</li>
</ol>
</li>
</ul>
<p>总结：步骤是 内存状态迁移-&gt;CRIU实现，NAS-&gt;(un)mount实现</p>
<h2 id="三种迁移："><a href="#三种迁移：" class="headerlink" title="三种迁移："></a>三种迁移：</h2><h3 id="A-In-memory状态迁移："><a href="#A-In-memory状态迁移：" class="headerlink" title="A. In-memory状态迁移："></a>A. In-memory状态迁移：</h3><p>++这一部分的主要工作++：为优化checkpoint内存的时间，在<em>action script</em>中提供了一个回调方法</p>
<ul>
<li>运行中的容器有很多内存的状态（如开放文件描述符、网络套接字、应用程序数据结构、缓存的数据）。</li>
<li>我们使用开源的linux工具CRIU来checkpoint和dump这些状态到文件中，之后我们就可以迁移并恢复这些文件。<ul>
<li>在检查期间，CRIU将一个正在运行的容器冻结，以保证一致性；</li>
<li>然后把它的内存状态转存到一系列文件中。转存的总大小取决于进程的页映射的大小。（例如，一个MySQL的容器在它初始化之后立即被检查，创建一个页映射的转存，大小为117MB，所有其他资源的转存文件占250KB。）</li>
<li><strong><em>checkpoint内存的时间被计入应用程序的宕机时间，因此优化它很重要。</em></strong><ul>
<li>在Voyager中，我们使用<em>tmpfs</em>来存储转存文件，以避免任何更慢的磁盘事务。</li>
<li>我们进一步使用CRIU的pagemap server模型，在这个模型中，在checkpoint的时候，pagemap镜像会被直接转存到目标主机上，因此可以避免源主机的存储跳跃。CRIU同样提供了一个叫做<em>action script</em> 动作脚本的结构，它可以允许在一个容器被checkpoint之后和解冻之前执行任意脚本。<strong>我们在<em>action script</em> 动作脚本中提供了一个回调方法</strong>，用来通知Voyager checkpoint的状态，以便Voyager可以执行某个清楚的检查，之后停止源主机上的容器，并将其在目标主机上恢复。</li>
<li>一旦容器初始化之后，Voyager在目标主机上启动一个lazy migration进程，会在后面描述。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="B-本地文件系统迁移"><a href="#B-本地文件系统迁移" class="headerlink" title="B. 本地文件系统迁移"></a>B. 本地文件系统迁移</h3><p><strong><em>关于迁移时应用程序的停机时间的一个最重要的贡献因素是数据复制。</em></strong></p>
<p>已经有一些优化技术：</p>
<p>转移增量的文件系统快照，并执行实际的失败（当增量的变化足够小的时候）。</p>
<p>缺陷：<br>​    </p>
<ul>
<li>对于数据密集型应用，寻找这样的一个优化的变化窗口可能会很难。</li>
<li>这样的技术更适合有计划的虚拟机迁移，因为实际的迁移可能会过段时间再进行。对于容器，它们在本质上非常灵活，其生命周期与虚拟机相比要相对更短。</li>
</ul>
<p>这一部分的主要工作：Voyager当前的目标在于对其进行“及时的（jit）”迁移。通过在源和目标主机之间使用双频带数据传输：借助数据联合实现带内传输，借助懒散复制实现带外传输。</p>
<h4 id="1）数据联合"><a href="#1）数据联合" class="headerlink" title="1）数据联合"></a>1）数据联合</h4><p>++这里的目标++是要使源主机上的容器数据在目标主机上可访问，而不需要实际地预先复制任何数据，这样的联合逻辑使得迁移的容器的远程读和本地写成为可能。<br>Voyager用一个在源主机和目的主机之间的文件系统的联合挂载来实现数据联邦。这个联合的停机时间为零，因为它在内存checkpoint之前被编排。一旦它的内存状态被在目标主机上恢复，这个容器就可以通过联合挂载的 <em>rootfs</em> 访问它的持久性数据。</p>
<p><strong>如图1：</strong></p>
<ol>
<li>首先，一个容器的 <em>rootfs</em>（如 <em>/var/contA</em>）是从源主机中导出的网络文件系统（NFS）</li>
<li>然后将其挂载到目标主机上，作为一个只读的 <em>mnt/nfsA</em>。</li>
<li>之后在目标主机上建立两个新的文件夹<ul>
<li><em>/var/lazyStoreA</em> 用来托管懒散复制的数据</li>
<li><em>/var/active</em> 用来托管任何更新过的或者新写入的数据</li>
</ul>
</li>
<li>使用目标主机的<em>rootfs</em> */var/contA中的AuFS联合挂载文件系统，这三个文件夹会以步骤3中描述的顺序被访问</li>
<li>Voyager的联合能力在其他联合文件系统中也同样可以应用。</li>
</ol>
<ol>
<li>最初的时候，最下面的NFS目录分支和lazyStore分支都被标记为只读的，只有活跃的分支有读写权限。</li>
<li>每个由迁移的容器新创建的文件都被托管于active目录。</li>
<li>任何对现有文件的更新都会首先通过NFS分支转移到active分支，然后再将其本地化更新。因此，这个active分支充当了一个写时复制（CoW）目录。任何进一步的读或更新都被本地化处理。</li>
<li>唯一一个与active分支或lazyStore分支不符合的文件读取（在下面讨论）是通过NFS路由到源主机文件系统。Voyager使用目标主机中NFS客户端缓存来优化网络中的这些读取。</li>
</ol>
<h4 id="2）Lazy-replication"><a href="#2）Lazy-replication" class="headerlink" title="2）Lazy replication"></a>2）Lazy replication</h4><p>一旦容器通过联邦恢复了对数据的访问，Voyager就启动一个lazy replicator，用来在后台转移数据。复制器首先会遍历源主机上的容器的rootfs来计算所有文件的joblist，之后开始将它们复制到lazyStore。我们在active目录中使用了inotify（步骤7，一种文件变化通知机制），用来监控和通知复制器（步骤8）关于已经通过CoW被传输到目标主机上的文件，以便于复制器可以将它们从joblist中移除，从而避免任何冗余的网络副本。复制器最开始会在lazyStore里面用一个临时的名字.filename.part来创建文件，以避免向容器提供一个中间传输的不完整的视图。一旦复制完成，这个文件会被用它的真实名字重命名。任何后续的容器对该文件的读取都由lazyStore支持完成，同时避免NFS分支。当复制器完成所有文件的复制时，最低的NFS分支被从联邦中移除，lazyStore被标记为读写。在这个时候，Voyager将容器迁移标记为完成。</p>
<h4 id="3）调整"><a href="#3）调整" class="headerlink" title="3）调整"></a>3）调整</h4><p>使用一个双频段传输信道允许系统管理员指定一个流优先于其他流。带外的懒散复制率可以被限制，以避免任何的主要联邦流的网络瓶颈。同样的，如果主机有多个网络端口的话，更快的端口可以被联邦用来挂载NFS，而较慢的可以用来进行懒散的复制。</p>
<h3 id="C-网络文件系统迁移"><a href="#C-网络文件系统迁移" class="headerlink" title="C. 网络文件系统迁移"></a>C. 网络文件系统迁移</h3><p>对于任何网络文件存储，Voyager简单地执行网络附加存储（NAS）份额的卸载和挂载，伴随着主机访问权限和防火墙配置。类似地，分布式系统部署，借助于它们的设计，使它们很容易迁移。</p>
<h3 id="D-未来的enhancements"><a href="#D-未来的enhancements" class="headerlink" title="D. 未来的enhancements"></a>D. 未来的enhancements</h3><p>有很多正在进行的努力，来进一步减小应用程序的停机时间，并且包含了下列特征：<br>1）在Voyager，应用程序的停机时间只会在内存检查点/恢复时发生，而数据复制是不会引起停机时间的。因此，我们正在探索减小pagemap大小的方法，通过在检查点之前进行页面刷新（同步）或者其他应用特定的容器内部的垃圾回收。同样，对于特定的冗余资源选择性地放弃检查点可能会有很大帮助。<br>2）现在的Voyager实现了恰好及时地迁移。我们最近刚刚将CRIU的增量内存检查点能力合并到Voyager当中，我们计划讲这些改变提交回与runc OCI一致的运行时间。同时，我们也在探索对计划的迁移进行增量磁盘检查点。<br>3）对于带外的懒散复制，我们计划去提供一个过滤器，可以用来使用户为文件模式指定常规的表达式。例如，*.log，tmp*。这些文件会在复制的时候被忽略掉，以避免冗余的网络传输。</p>
<h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>实验设置：我们将我们的实验构建与两台Ubuntu 14.04.5 LTS虚拟机上，分别作为容器的源和目标主机。没太虚拟机配置了4个vCPU，4GB的内存以及25GB的磁盘，文件系统是ext4.这些虚拟机是在同一个数据中心里，平均网络带宽是2.5Gbps。我们用docker-runc（借助docker-1.12.3）运行我们的容器，这是一个docker的OCI依从的容器运行时间。对于内存迁移，我们使用最新的CRIU版本2.8。我们从docker hub中选择最流行的有状态的数据库——MySQL5.7.15作为我们的测试应用程序。最后，我们使用标准的雅虎云服务基准（YCSB）基准测试工具来测试MySQL在不同工作量模式下的性能。</p>
<h2 id="从三个维度来评估Voyager：一致性、应用停机时间和性能开销。"><a href="#从三个维度来评估Voyager：一致性、应用停机时间和性能开销。" class="headerlink" title="从三个维度来评估Voyager：一致性、应用停机时间和性能开销。"></a>从三个维度来评估Voyager：一致性、应用停机时间和性能开销。</h2><h3 id="A-一致性"><a href="#A-一致性" class="headerlink" title="A. 一致性"></a>A. 一致性</h3><p>Voyager是一个对于应用容器的完全的状态迁移解决方案。因此，一旦这个容器被迁移了，保证应用程勋运行时间状态被正确恢复是至关重要的。为了测量一致性，我们设计了两个数据点：</p>
<p>1）MySQL服务器在开始时执行一系列初始化任务，包括加载配置、初始化数据目录、系统表空间以及相关的管理InnoDB表需要的在内存中的数据结构等。因此，作为第一个数据点，我们在MySQL数据库中插入一些记录，然后用Voyager迁移该容器。然后我们验证一个MySQL客户端可以连接到迁移的服务器并对存在的记录进行查询而不出错。这验证了这个应用及其内存数据结构和持续性表空间可以被一致性地恢复。</p>
<p>2）对于我们的第二个数据点的评估，我们在同一个MySQL容器中嵌入了一个测试客户端。我们首先在数据库中插入了10K的人的记录，带有从1开始增加的索引1.这个客户端程序由人的索引1和磁盘上的空文件初始化。它有一个周期性的函数，连接数据库，用下一个索引查询一个人的记录（姓名，年龄），将姓名接到文件末尾并修正平均年龄。我们开始这个客户端程序，将这个容器在程序执行过程到一半时迁移，通过与没有迁移的启动的期望输出进行对比，保证每次客户端程序在目标主机上完成任务，并得到准确的统计。</p>
<h3 id="B-应用停机时间"><a href="#B-应用停机时间" class="headerlink" title="B. 应用停机时间"></a>B. 应用停机时间</h3><p>最小化应用的停机时间是一个生产云中的总要标准，别不为了维持服务水平协议（SLA）和业务连续性。Voyager对于持续性状态的转移没有增加应用程序的停机时间，借助于它的数据联邦和目的主机与源主机之间的懒散的复制来实现。这样的话停机时间只受限于借助于CRIU进行的内存中的状态转移的时间。我们通过检查点和恢复这个容器的内存中的进程转储的时间来测量这个时间。</p>
<p>检查点：在检查点，CRIU将容器冻结，来保证一致性，并将进程的在内存中的状态转储。在Voyager，我们用一个远程的页服务器来将这个进程的pagemap直接转出到目标主机的tmpfs中。因此，检查点时间包括了收集进程树、冻结它、收集进程的资源（如，文件描述器、内存映射、计时器和线程），并将资源写到转储文件中，借助网络放到远程页服务器上。如图2a中所示，我们在不同阶段验证MySQL容器的检查点时间，这些阶段有着不同的记录数量，结果表现为一个增长的pagemap转储文件大小，从117MB到250MB。检查点时间随着应用程序的内存状态线性增加。在微服务架构中，我们可以期望单个容器的内存用量少于1GB，将检查点时间限制到低于2秒。</p>
<p>恢复：在恢复阶段，CRIU读取转储的文件，解析共享的资源，复刻进程树并恢复进程资源。图2a展示了MySQL容器的恢复时间。正如我们看到的那样，对于一个小于250MB的转储文件大小，恢复时间在约0.7-0.8秒。<br>因此，在Voyager前一种，总的期望的应用程序停机时间在2-3秒。我们最近将CRIU的增量内存检查点能力包含到Voyager中，这可以显著降低应用程序的停机时间。作为未来的工作，我们计划对这个优化进行评估，并且还要用CRIU来衡量每个资源粒度的检查点和恢复时间，以便我们可以优先考虑和优化个人资源。</p>
<h3 id="C-性能开销"><a href="#C-性能开销" class="headerlink" title="C. 性能开销"></a>C. 性能开销</h3><p>在Voyager中，一旦一个容器在目标主机上继续了，它就立即对其持续性数据存储有了访问权限，通过Voyager的数据联邦层，这个层会引发性能开销，我们用YCSB来测量不同类型的工作量profile，包括读、插入、更新和浏览。对于每个profile，在YCSB的加载阶段，我们在一个数据库表中插入1M的数据，之后在运行阶段，我们进行1M记录的各类型的操作。这些记录是使用基于流行的长尾访问模式的齐夫定律分发来访问的。对于每个工作量profile，我们每10秒测量一次平均应用吞吐量（操作数/秒）。每个实验在两个应用状态执行：</p>
<p>1）基准线：迁移前源主机的应用程序状态</p>
<p>2）联邦：迁移后在目标主机上的应用程序状态，可以通过联邦层访问数据。<br>对于普通的应用程序的读写工作量模式，我们观察稳定状态的到0~3%的开销。对单个工作量profile的性能影响的讨论如下：</p>
<ul>
<li><p>读</p>
<p>  图2c展示了数据读取的基准测试结果。最开始的时候较低的吞吐量是因为是在缓存预热阶段，之后到了稳定状态阶段，我们观察到相对稳定的性能。每个通过联邦层读取操作都通过NFS进行对源主机的数据的访问。结果，在联邦阶段，读取吞吐量在缓冲预热时下降了约20%，在稳定阶段下降了约1%。</p>
</li>
<li><p>扫描</p>
<p>  图2d展示了扫描的结果。与读取不同，读取中一个zipfian模式会频繁访问受欢迎的记录，而扫描中会按顺序访问记录，从一个随机选择的记录的键开始，生成更加独特的读取请求。因此，即使在稳定阶段，对于NFS中的读取访问，我们也记录了一个约10%的性能开销。</p>
</li>
<li><p>更新</p>
<p>  在联合状态，一个更新操作本质上是一个写时复制的操作，即一个文件通过NFS被从源主机上读取，然后在目标主机上复制，之后本地更新。MySQL通过分开的.ibd数据文件存储InnoDB表和索引。因此，在联邦状态，当一个记录被更新时，各自的索引和表空间文件在目标主机上被写时复制了。之后，每个后续的对该记录的更新都被本地化完成。结果如图2e，我们观察到，在开始的时候有一个约75%的性能开销，而在稳定状态更新性能与基准线持平。</p>
</li>
<li><p>插入</p>
<p>  在联合状态，每个写操作都导致新文件的生成在本地进行。因此我们观察到了基准线和联邦状态的相似的性能结果，如图2f。表的大小会将索引插入的速度减慢logN（假设是B+树索引），因此对于两个状态都观察到了稳定的性能下降。</p>
</li>
<li><p>读取/更新/插入</p>
<p>  在这个profile中，我们将IP工作量分成60:20:20，对应读取:更新:插入。如图2b，我们观察到，在最开始的时候，由于更新时的文件复制和NFS对读取的访问，性能开销约为65%，而稳定状态约为3%。</p>
</li>
</ul>
<h3 id="D-应用容器：-启动和恢复"><a href="#D-应用容器：-启动和恢复" class="headerlink" title="D. 应用容器： 启动和恢复"></a>D. 应用容器： 启动和恢复</h3><p>与VM对比，容器有更快的启动时间。但是，容器中的应用程序同样也会有它们自己的启动或初始化时间，这个时间范围可能从毫秒到几秒。我们测量两个应用的平均初始化时间，即MySQL和elasticsearch。两个应用的平均初始化时间分别为：MySQL：10s，elasticsearch：7s。之后我们对这些应用容器再起初始化后立即进行检查点操作，并在同一主机上恢复它们。两个的恢复时间都少于500ms，远小于它们的启动时间。在有些平台上，应用程序会通过恢复它们的状态来初始化，而rootfs被通过数据联邦和懒散复制提供，我们正在探索将Voyager应用于这些平台上。</p>
<h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>实验表明：</p>
<ul>
<li>数据更新/写入期间无开销</li>
<li>读 1%</li>
<li>扫描 10%</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>我们展示了本工作中Voyager的设计和实现。Voyager在用了一个跨源和目标主机的数据联合，以保证应用程序可以在目标主机上“恰好及时地”继续进行，过程中有远程读数据和本地写数据的访问。这样一个联合框架的性能开销经过估计，对于普通的读写工作量，开销在1-3%内。我们致力于开源以及进一步优化我们的工作以支持容器的增量迁移，优化内存检验知识/回复和设计策略驱动的懒散复制以降低网络开销。</p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><p>关于pre-copy和post-copy：<a href="http://www.infoq.com/cn/articles/container-live-migration" target="_blank" rel="external">http://www.infoq.com/cn/articles/container-live-migration</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/21/Live-Video-Analytics-at-Scale-with-Approximation-and-Delay-Tolerance-NSDI-2017/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/21/Live-Video-Analytics-at-Scale-with-Approximation-and-Delay-Tolerance-NSDI-2017/" itemprop="url">Live Video Analytics at Scale with Approximation and Delay-Tolerance(NSDI2017)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-21T23:39:09+08:00">
                2018-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/科研论文笔记/" itemprop="url" rel="index">
                    <span itemprop="name">科研论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年3月21日所写，未经允许不得转载。</p>
<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><ul>
<li>研究对象： video cameras、监控视频</li>
<li>一个视频分析系统 —— 处理上千条实况视频流的分析查询</li>
<li>侧重于资源管理</li>
<li>考虑了视频分析的两个特性：<ul>
<li>多维配置条件下的资源质量权衡</li>
<li>质量和延迟目标的多样性</li>
</ul>
</li>
<li>系统组成分为两个部分<ul>
<li>offline profiler：生成查询 resource-quality profile</li>
<li>online scheduler：为查询分配资源 来 maximize performance on quality and lag</li>
</ul>
</li>
</ul>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p><strong>主要需求</strong>：对实况视频流的高效分析</p>
<p><strong>现状</strong>：</p>
<ul>
<li>有大量的集群在分析实况视频</li>
<li>监控摄像头和集群之间的带宽足够</li>
<li>不同的场景下分析的需求不同，例如：<ul>
<li>有些需要跑很长时间：为控制交通信号灯持续时间，统计汽车数量</li>
<li>有些是短时间的爆发：读取AMBER警报中的车辆牌照（注：美国城市中识别儿童绑架者警报）</li>
</ul>
</li>
<li>视频分析的资源需求很高<ul>
<li>目标跟踪：the best tracker in the VOT Challenge处理的效率很低</li>
<li>最精确的深度神经网络对对象识别需要30GFlops来处理一帧</li>
</ul>
</li>
</ul>
<p>由于处理代价大和视频流速度高，视频分析查询的资源管理很重要。</p>
<h2 id="related-work"><a href="#related-work" class="headerlink" title="related work"></a>related work</h2><p>流处理生产系统Storm、StreamScope、Flink, Trill and Spark Streaming和集群管理器Yarn and Mesos 的对多查询的资源分配方式是：<br><strong>only based on resource fairness</strong></p>
<p>产生的问题是：尽管简单, 但是对查询质量和延迟不可知导致 fair sharing 很难实现</p>
<h2 id="研究过程"><a href="#研究过程" class="headerlink" title="研究过程"></a>研究过程</h2><p>考虑了视频分析的两个特性：</p>
<h3 id="1-资源质量权衡"><a href="#1-资源质量权衡" class="headerlink" title="1. 资源质量权衡"></a>1. 资源质量权衡</h3><h4 id="一些定义："><a href="#一些定义：" class="headerlink" title="一些定义："></a>一些定义：</h4><ul>
<li><p><strong>knobs：视觉算法包括各种各样的参数</strong></p>
<p>  Example of knobs：</p>
<ol>
<li>video resolution：视频分辨率</li>
<li>frame rate：帧频</li>
<li>internal algorithmic parameters,such as the size of the sliding window to search for objects in object detectors：内部算法的参数，例如在对象检测器中搜索对象的滑动窗口大小</li>
</ol>
</li>
<li><p><strong>a query configuration（一个查询配置）：</strong> </p>
<p>  knob值的组合，配置的空间随knob的个数成指数级增长。可以通过改变配置减少资源需求（例如，改变分辨率和滑动窗口大小）但是同时也会降低输出质量。</p>
</li>
</ul>
<h3 id="2-质量和时延目标的多样性"><a href="#2-质量和时延目标的多样性" class="headerlink" title="2. 质量和时延目标的多样性"></a>2. 质量和时延目标的多样性</h3><p>不同的查询需要的实时产生结果，但是有些允许有延迟。这就允许在资源短缺期间临时重新分配来自可以容忍延迟的查询的一些资源。</p>
<p>视频分析查询有不同的质量、延迟要求:</p>
<ul>
<li>统计汽车数量来控制红绿灯：moderate quality (approximate car counts)、low lag</li>
<li>收费公路上的车牌号阅读器：high quality、tolerate lag</li>
<li>AMBER Alerts的车牌阅读器：high quality、no lag</li>
</ul>
<h3 id="3-处理查询的过程分析"><a href="#3-处理查询的过程分析" class="headerlink" title="3. 处理查询的过程分析"></a>3. 处理查询的过程分析</h3><p>提交视频分析查询–&gt;转换,即对输入视频的帧进行视觉信号处理</p>
<p>generated profiles + lag and quality goals——&gt;(经scheduler) allocate resources, pick configuration(knob values) </p>
<p><strong>难点：</strong></p>
<ol>
<li>对一个查询配置的资源需求和质量的无分析模型，可选配置数量太多</li>
<li>对于单个查询的质量和延迟目标的表达，以及集群中的所有查询的质量和延迟目标的表达都是非平凡的。 </li>
<li>决定资源分配和配置是一个在计算上的难度与查询和knob数量呈指数型关系。</li>
</ol>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Offline-profiler："><a href="#Offline-profiler：" class="headerlink" title="Offline profiler："></a>Offline profiler：</h3><ul>
<li>没有穷举整个配置组合空间</li>
<li>采用贪心搜索、特定区域取样</li>
<li>使用profilers的Pareto boundary来计算knob configurations</li>
</ul>
<p><strong>一些定义：</strong></p>
<ol>
<li>utility function:<br> encode quality and lag goals of a query<br> Utility = achieved quality 和lag 的加权组合 + penalties for     violating the goals<br> penalties允许查询有优先级<br> 一个集群所有查询的性能目标是：使得最小的utility最大化（实现公平：max-min） / 最大化总的utility（实现性能）</li>
<li>Lag<br> 最后到达的帧的时间与最后处理的帧的时间差</li>
<li>quality<br> F1 score属于[0.1]（精确度和查全率的调和平均数） with reference to a labeled ground truth</li>
</ol>
<h4 id="如何估计资源-质量profile"><a href="#如何估计资源-质量profile" class="headerlink" title="如何估计资源-质量profile"></a>如何估计资源-质量profile</h4><ol>
<li>用户提交一个新的查询之后，首先立刻运行一个默认profile（曾在别的摄像头上使用过）</li>
<li>同时将这条查询运行offline profiling phase</li>
<li>查询profiler有两个目标：<ul>
<li>从资源-质量空间中，选择配置的小的子集（Pareto boundary）</li>
<li>计算查询profile， P~k~，即选择配置的资源需求和结果质量</li>
<li>profile根据一个贴了标签的数据集计算或者使用这个视频的原始部分，与一个黄金查询配置有关</li>
</ul>
</li>
</ol>
<h3 id="online-scheduler："><a href="#online-scheduler：" class="headerlink" title="online scheduler："></a>online scheduler：</h3><p>任务：</p>
<ul>
<li>预测延迟——使用Model-Predictive Control来预测未来一段时间的查询延迟</li>
<li>在utility function中使用这个预测延迟</li>
<li>考虑落后的查询的catch up</li>
<li>处理在资源-质量profiles中对于资源使用不可避免的不准确</li>
</ul>
<p>主要做的事情是资源管理，考虑当个查询和集群范围的性能目标，周期性的做两件事：资源分配和查询安排</p>
<ul>
<li>periodically (e.g.,every second)<ul>
<li>considers all running queries</li>
<li>adjusts their resource allocation, machine placement, and configurations based on their profiles</li>
<li>changes in demand and/or capacity (see Figure 4)</li>
</ul>
</li>
<li>We encode the quality and lag requirements of each individual query into its utility function</li>
<li>The performance goal across all queries in a cluster is specified either as maximizing the minimum utility or the sum of utilities</li>
</ul>
<h4 id="1-资源分配阶段"><a href="#1-资源分配阶段" class="headerlink" title="1. 资源分配阶段"></a>1. 资源分配阶段</h4><p>调度器假设集群是一个资源集合，使用一个有效的启发式算法调整查询分配和配置来最大化集群范围上的性能</p>
<p>总体功能：</p>
<blockquote>
<p>Given a profile P~k~ and a utility function U~k~ for each query k, the scheduler allocates resources a~k~ to the queries and picks their query configuration (c~k~ 属于 P~k~).</p>
</blockquote>
<p><strong><em>The scheduler runs periodically (e.g., every few seconds) and reacts to arrival of new queries, changes in query demand and lag, and changes in resource capacity (e.g., due to other highpriority non-VideoStorm jobs).</em></strong></p>
<p>如果分配的资源比查询的需求少的化，查询延迟会随着时间累计，因此目标是提高未来一段时间的性能。</p>
<ul>
<li>建模</li>
</ul>
<p>使用Model—Predictive Control（MPC）框架公式化这个调度问题。<br>一段时间范围<em>T</em>的集群性能 设为 查询配置和分配的函数。</p>
<p>每一步都选择配置和分配来最大化未来的性能。</p>
<p>为了预测未来的性能，需要预测查询的延迟。将预测延迟放入效用方程中来获得预测效用。</p>
<ul>
<li>调度启发法<ul>
<li>最大化效用和是一个背包问题 </li>
</ul>
</li>
</ul>
<h4 id="2-查询安排阶段"><a href="#2-查询安排阶段" class="headerlink" title="2. 查询安排阶段"></a>2. 查询安排阶段</h4><p>调度器将新的查询安排给集群中的机器，考虑迁移现有的查询</p>
<h3 id="starting-point-for-solution"><a href="#starting-point-for-solution" class="headerlink" title="starting point for solution"></a>starting point for solution</h3><p>一开始考虑streaming databases with approximation</p>
<ul>
<li>这种方法只考虑了数据流的采样率，用建立好的分析模型计算质量和资源需求</li>
<li>视觉查询是负责的黑盒，有很多knob，没有已知的分析模型</li>
<li>一次只优化一个查询（本文调度多个并发查询）</li>
</ul>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="VideoStorm-集群包括："><a href="#VideoStorm-集群包括：" class="headerlink" title="VideoStorm 集群包括："></a>VideoStorm 集群包括：</h3><ul>
<li>a centralized manager：包括profiler和scheduler</li>
<li>a set of worker machines: execute queries，解码视频、提取背景探测目标、发送给别的机器跟踪和分类（假设监控摄像头到几群的带宽足够）<ul>
<li>every runs a machine manager: 启动worker progress来进行变换；周期想VideoStorm Manager 汇报资源利用率以及正在运行的变换的状态。scheduler用这些信息为查询分配资源。</li>
<li>VideoStorm Manager和machine Manager不在查询data path上，在控制流</li>
</ul>
</li>
<li>a query: 一个实况视频的DAG变换，每个变换处理一个时间顺序信息流并将其传输到下一级<ul>
<li>每个变换包括一个id和class_name, input_transform_id指定该变换的输入来源。</li>
<li>Source transforms，例如Decoder，不指定input transform，直接与监控摄像头相连（指定IP和端口）</li>
<li>每个变换包括可选的knobs或者说parameters，例如：<ul>
<li>车牌的最大最小窗口大小</li>
<li>OpenALPRazolam变换的搜索的步长（the step increments to search between these sizes for the OpenALPR transform）</li>
<li>值可以动态更新的knobs以@符号开头</li>
</ul>
</li>
</ul>
</li>
<li>scheduler：performance-based scheduling<ol>
<li>尽量给质量能提高多的查询分配更多的资源</li>
<li>运行有built-up lag的查询在处理过程中catch up</li>
<li>根据分配的资源调整查询配置</li>
</ol>
</li>
</ul>
<h3 id="现实生活中的视频查询"><a href="#现实生活中的视频查询" class="headerlink" title="现实生活中的视频查询"></a>现实生活中的视频查询</h3><p>四种现实生活查询场景的资源-质量profiles：</p>
<h4 id="1-车牌阅读器查询"><a href="#1-车牌阅读器查询" class="headerlink" title="1. 车牌阅读器查询"></a>1. 车牌阅读器查询</h4><h5 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h5><ul>
<li>帧分辨率和采样率是重要的knob</li>
<li>使用OpenALPR library</li>
<li>用MinSize扫描车牌图像-&gt;积性增加大小-&gt;重复这一过程直到达到MaxSize</li>
</ul>
<ul>
<li>本文使用F1 score在一个贴了标签的数据集上估算了每种knob配置的质量（F1 score是准确度和查全率的调和平均数，在机器学习中很常用）</li>
<li>0和1 代表了最低和最高质量</li>
</ul>
<p>10分钟视频、414种配置车牌查询资源-质量 花了 20天</p>
<h5 id="配置的贪心探索"><a href="#配置的贪心探索" class="headerlink" title="配置的贪心探索"></a>配置的贪心探索</h5><p>爬山法得到baseline profiler</p>
<p>online profiler= baseline profiler k=3 cache imtermediate results in the query’s DAG and reuse them in evaluating configurations with overlapping knob values</p>
<p><strong>Pareto boundary</strong></p>
<p>online profiles最上面的黑线</p>
<h4 id="2-汽车计数器"><a href="#2-汽车计数器" class="headerlink" title="2. 汽车计数器"></a>2. 汽车计数器</h4><p>即使分辨率和采样率低，结果通常质量高</p>
<h4 id="3-DNN分类器"><a href="#3-DNN分类器" class="headerlink" title="3. DNN分类器"></a>3. DNN分类器</h4><ul>
<li>包括对象探测和分类</li>
<li>使用ImageNet数据集，将对象分为1000类</li>
</ul>
<p><strong>another knob——compression factor</strong><br>​    </p>
<h4 id="4-对象跟踪"><a href="#4-对象跟踪" class="headerlink" title="4. 对象跟踪"></a>4. 对象跟踪</h4><ul>
<li>抽象背景、识别前景对象，在多帧之间使用mapping metric（<strong>a key knob</strong>） 跟踪对象<ul>
<li>Objects across frames can be mapped to each other using metrics such as distance moved (DIST), color histogram similarity (HIST), or matched over SIFT and SURF features.</li>
</ul>
</li>
</ul>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>部署在一个有101台机器的Azure集群上</p>
<ul>
<li>offline 3.5* less CPU</li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><ul>
<li>上千条查询——几百毫秒</li>
<li>80% in quality of real-world queries</li>
<li>7* better lag</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">icestrawberryxjw</p>
              <p class="site-description motion-element" itemprop="description">The most difficult thing is the decision to act, the rest is merely tenacity.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/icestrawberryxjw" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">icestrawberryxjw</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
