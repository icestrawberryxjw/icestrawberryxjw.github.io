<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:type" content="website">
<meta property="og:title" content="icestrawberryxjw">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="icestrawberryxjw">
<meta property="og:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="icestrawberryxjw">
<meta name="twitter:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>icestrawberryxjw</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">icestrawberryxjw</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/Book-list-2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/Book-list-2019/" itemprop="url">2019年书单</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T11:06:36+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/书单/" itemprop="url" rel="index">
                    <span itemprop="name">书单</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h3><ol>
<li>高性能计算的问题解决之道——Linux态势感知方法、实用工具及实践技巧<ul>
<li>状态：阅读中</li>
<li>英文书名：<em>Problem-solving in High Performance Computing——A Situational Awareness Approach with Linux</em></li>
<li>作者：Igor Ljubuncic，曾任Intel工程计算部门的操作系统架构师，为全球高性能Linux计算环境提供解决方案；曾任Rackspace云计算中心的熟悉工程师；目前是一名自由作家和商业顾问</li>
<li>译：张文力</li>
<li>出版社：机械工业出版社</li>
<li><a href="">笔记链接</a></li>
</ul>
</li>
<li><p>Docker容器与容器云（第二版）</p>
<ul>
<li>状态：阅读中</li>
<li>作者：浙江大学SEL实验室</li>
<li>出版社：人民邮电出版社</li>
</ul>
</li>
<li><p>深度探索C++对象模型</p>
<ul>
<li>状态：阅读中</li>
<li>作者：Stanley B. Lippman</li>
<li>译：侯捷</li>
<li>出版社：电子工业出版社</li>
</ul>
</li>
</ol>
<h3 id="非技术类"><a href="#非技术类" class="headerlink" title="非技术类"></a>非技术类</h3><ol>
<li>人性的弱点<ul>
<li>状态：阅读中</li>
<li>作者：戴尔·卡耐基(Dale Carnegie),1888-1955</li>
<li>译：陶朦</li>
<li>出版社：天津人民出版社</li>
</ul>
</li>
<li>平衡的智慧——家庭、信仰和工作的优先次序原则<ul>
<li>状态：已读完</li>
<li>作者：帕特·基辛格(Pat Gelsinger)著，英特尔首席技术官</li>
<li>译：高路杜霞</li>
<li>出版社：中国商业出版社</li>
</ul>
</li>
<li>富爸爸穷爸爸<ul>
<li>状态：阅读中</li>
<li>作者：罗伯特·清崎（英文名：Robert Toru Kiyosaki），莱希特</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/Problem-solving-In-High-Performance-Computing-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/Problem-solving-In-High-Performance-Computing-notes/" itemprop="url">高性能计算的问题解决之道-笔记-更新中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T10:55:07+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/计算机/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年5月9日所写，未经允许不得转载。</p>
<h3 id="关于书"><a href="#关于书" class="headerlink" title="关于书"></a>关于书</h3><ul>
<li><p>中文书名：《高性能计算的问题解决之道——Linux态势感知方法、实用工具及实践技巧》</p>
</li>
<li><p>英文书名：<em>Problem-solving in High Performance Computing——A Situational Awareness Approach with Linux</em></p>
</li>
<li>作者：Igor Ljubuncic，曾任Intel工程计算部门的操作系统架构师，为全球高性能Linux计算环境提供解决方案；曾任Rackspace云计算中心的熟悉工程师；目前是一名自由作家和商业顾问</li>
<li>出版社：机械工业出版社</li>
<li>简介/关键词：<ul>
<li>高性能计算、大规模系统、故障停机</li>
<li>整体态势感知方法：数学模型、最佳实践、监控配置</li>
<li>在数据中心应该如何解决问题，方法论</li>
<li>解决问题和研究的基本方法，常见陷阱</li>
<li>常见应用程序和工具，建立起报告的症状与软硬件资源的实际行为之间的联系</li>
<li>分析、刻画(profile)应用程序，以及分析内核本身</li>
<li>内核崩溃分析和内核调试器的使用，kdump</li>
<li>建立稳健有效的监测环境的考虑因素、方法、工具</li>
<li>版本控制、配置管理方面</li>
</ul>
</li>
</ul>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="在一个数据中心如何动手解决问题"><a href="#在一个数据中心如何动手解决问题" class="headerlink" title="在一个数据中心如何动手解决问题"></a>在一个数据中心如何动手解决问题</h4><ol>
<li><p>MTTF(Mean Time to Failure)：系统平均无故障时间</p>
</li>
<li><p>问题的识别：健康的怀疑态度、挑战惯例；探寻工具没有看到的问题；仔细留意现象。</p>
</li>
<li><p>问题的分类：</p>
<ul>
<li>真正的问题：与监控工具关联，预先分析过。</li>
<li>误报的问题：由系统管理链的前述环节所引起的误报，包括人为和机器原因。</li>
<li>虚假的问题：只对环境有间接影响的实际问题，但如果无人值守可能有显著影响。</li>
</ul>
</li>
<li><p>使解决问题成为一门学科，而不是一个不稳定的随机的努力。</p>
<p>面对问题，优先从简单熟悉的部分开始，不要上来做最坏的假设。过多的知识可能会导致误区。</p>
</li>
<li><p>事件通常有一个最大响应时间。服务级别协议SLA(service-level agreement)决定支持团队应该以多快的速度提供问题的解决方案。</p>
</li>
<li><p>停机规模、问题严重性、业务需求通常趋于零变化。</p>
<p>从不能忽视的问题开始，以正确的分类跟进。要确保琐碎的可预测的问题转化为自动化(快速、熟悉、高度可见、便于管理过程中的理解)，集中智慧和技能去处理其余那些反反复复看似怪异的案例。</p>
</li>
<li><p>问题的再现</p>
<ul>
<li><p>隔离问题：实际绘制一张环境图示，用确定的、程式化的方式去捕获问题</p>
</li>
<li><p>偶发性问题需要特殊处理</p>
<p>形成正反馈环路：减少未知因素的数目→显著地限制可能的空间→减少那些可能会出现的问题的发生→允许投入适量的精力去定义有用的、有意义的监控规则和阈值。</p>
</li>
</ul>
</li>
<li><p>学会根据情况暂停，重新设定研究，重新来过，放手，求教于别人or彻底去尝试别的问题，然后再回到这个问题。</p>
</li>
<li><p>Linux内核在发生kernel panic时会打印oops信息，把目前的寄存器状态、堆栈内容，以及完整的call trace都显示出来。然后用objdump反汇编工具找出出错的地方。</p>
</li>
<li><p>透明大页面：THP, Transparent Huge Pages</p>
</li>
<li><p>分析情况时，严格控制环境改变，减少环境的熵，如果改变，确保你知道预期结果是什么。</p>
</li>
<li><p>挑战</p>
<ul>
<li>业务环境中的制约因素</li>
<li>需要关注核心问题，而不是容易看到的那些</li>
<li>人会倾向于关注熟悉的和已知的问题</li>
<li>监控工具会向易于量化的参数产生偏差</li>
<li>对于大多数系统而言，大部分指标不能告诉你内部机制</li>
</ul>
</li>
</ol>
<h4 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h4><ol>
<li><p>工作流程：识别问题，隔离问题，因果关系，改变环境</p>
</li>
<li><p>隔离问题：第一步是迁移问题，从生产环境迁移到一个隔离的测试配置。重新运行获得结果所需要的最小集。</p>
</li>
<li><p>监控在大多数情况下是反应性的，充其量它会确认你所察觉到的正常状态的变化，但并不知道为什么它已经改变。避免假设，逻辑流程中需要嵌入事实和数字。</p>
</li>
<li><p>辨别是程序错误还是特性。</p>
</li>
<li><p>建立明确的基准</p>
<p>能够将现有的性能和系统运行状态与旧有的基线作比较是一个非常重要的能力，这将有助于保持你对环境的认识和控制。</p>
</li>
<li><p>必需指标：性能和行为</p>
</li>
<li><p>一次一个变量</p>
</li>
<li><p>线性复杂度的问题：研究、记录、建立数学公式映射问题和解决方案</p>
<p>非线性问题：理解导致它们表现的触发器</p>
</li>
</ol>
<h4 id="获取系统信息工具"><a href="#获取系统信息工具" class="headerlink" title="获取系统信息工具"></a>获取系统信息工具</h4><ol>
<li><p><code>uptime</code> 命令：收集和报告系统负载情况、系统运行了多长时间以及当前登陆的用户数。</p>
<p>系统负载是系统执行的计算工作量的度量，输出中从右到左依次是最后1分钟、5分钟、15分钟的平均值。</p>
<ul>
<li>完全空闲的系统的负载数量为0.00.</li>
<li>使用或等待CPU的每个进程将负载数量递增1，负载量为1.00转换为单个CPU内核的完全利用。</li>
<li>高负载值不一定转化为实际工作负载。相反，它们表示等待CPU的进程的平均数以及处于不间断睡眠状态(D状态，产生D状态的原因出现uninterruptible sleep状态的进程一般是因为在等待IO，例如磁盘IO、网络IO等。)的进程数。</li>
</ul>
</li>
<li><p><code>top</code>命令：提供正在运行系统的动态实时视图，默认情况下每3s刷新一次。</p>
<ul>
<li><p><code>Tasks</code>字段列出系统上的任务总数(进程)、处于睡眠状态的个数、已被主动停止或正在追踪的进程、僵尸进程。</p>
</li>
<li><p><code>CPU(s)</code>：</p>
<ul>
<li>在用户空间中完成的计算标记为%us</li>
<li>系统调用活动的百分比列在%sy下</li>
<li>nice进程(即具有修改的调度优先级的进程)的比例显示在%ni下</li>
<li>I/O活动(包括磁盘和网络)都反映在%wa中，CPU等待时间是存储和网络吞吐量的指示，即使CPU计算可能很低，也可能直接影响主机的负载和响应能力。</li>
<li>硬件和软件中断以%hi和%si标记</li>
<li>%st是指虚拟机管理程序从虚拟机中窃取的时间，因此它只与虚拟化环境相关。</li>
</ul>
<p>根据经验，非常高的%sy值通常表示内核空间中的问题。例如，可能存在显著的内存抖动，驱动程序可能会行为时常，或者其中一个组件可能存在硬件问题。</p>
<p>非常高百分比的nice进程也意味着存在问题，因为可能由于用户偏好的优先级导致资源争用。</p>
<p>如果遇到%wa值超过10%，则通常表示与性能相关的问题，这可能导致远程文件系统响应缓慢、网络拥塞、大量写入请求或交换引起的本地磁盘活动，以及类似的问题。</p>
</li>
<li><p><code>Mem</code>和<code>Swap</code>：当前内存子系统的使用情况</p>
<ul>
<li>free：虚拟内存中的空闲内存</li>
<li>buffers：用于内存块设备的I/O缓冲区页面</li>
<li>cached：页面缓存，包含需要写入磁盘的脏页面和最近读取请求中使用的页面。虽然缓存大小可能非常大，但是如果正在运行的程序请求额外的内存，它将会收缩。因此处于所有实际目的，用户可将缓存的内存视为空闲内存。</li>
</ul>
<p>释放所有缓存的操作可能需要一些时间才能完成，因为系统忙于将更改提交到磁盘。</p>
<p><code>echo 3&gt; /proc/sys/vm/drop_caches</code></p>
<p>强调缓存机制的另一种方法是下载、编译和运行memhog程序，这个工具使用在命令行中指定大量的内存，然后释放它，<code>./memhog 2048M</code></p>
<p>top命令从/proc树收集信息，<code>cat /proc/meminfo</code></p>
</li>
<li><p>top锁定进程的默认显示包含其他有用的信息，包括任务运行的用户名、优先级、nice值、请求的内存分配、实际使用情况、共享内存、进程状态、CPU百分比、总可用物理内存的百分比、CPU时间和简短的命令行。在交互模式下工作时，可以用<code>-f</code>来更改字段。</p>
</li>
<li><p>几个有用的快捷方式</p>
<ul>
<li><code>-b</code>，在批处理模式下运行top</li>
<li><code>-d</code>，更改刷新延迟(默认是3s)</li>
<li><code>-u</code>，只显示匹配给定的UID或用户名的进程</li>
<li><code>-p</code>，监控最多20个进程、以逗号分隔的一个列表</li>
<li><code>-r</code>，以匹配的PID重调进程的优先级。正的值将降低进程优先级，某些负值只能由根进程使用，标准用户不能重调哪些属于其他用户的进程。</li>
<li><code>-k</code>，以匹配的PID杀死进程。默认情况下，使用SIGTERM</li>
<li><code>-q</code>，退出</li>
</ul>
</li>
<li><p>区域命令，影响信息的显示方式</p>
<ul>
<li><code>t</code>，将根据任务状态显示进程</li>
<li><code>m</code>，将根据内存和交换使用情况以自顶向下的方式显示它们</li>
<li><code>1</code>，将切换CPU信息以单行显示所有内核，或单独显示</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ps</code>命令：</p>
<p>接收几个符号系统中的选项，包括BSD、UNIX和GNU，分别以无前缀、以单个破折号作为前缀、以两个破折号作为前缀来区分。</p>
<p>显示系统上的每个进程<code>ps -ef</code></p>
<p>BSD语法：<code>ps aux</code></p>
<p>一些选项：</p>
<ul>
<li><code>-e|-A</code>：显示所有进程</li>
<li><code>-u|--user</code>：只显示属于列举UID的任务</li>
<li><code>-p|--pid</code>：通过其标识符(PID)选择特定的进程</li>
<li><code>-ppid</code>：通过父进程选择</li>
<li><code>-o</code>：用户指定的格式，以空格或逗号分隔值。</li>
</ul>
<p>一些UNIX语法的列名含义：</p>
<ul>
<li><code>TID</code>：线程ID，也称为轻量级进程(LWP)</li>
<li><code>Rtprio</code>：实时优先级</li>
<li><code>NI</code>：静态优先级</li>
<li><code>PRI</code>：动态优先级</li>
<li><code>PSR</code>：任务当前分配的处理器号</li>
<li><code>WCHAN</code>：进程正在等待的最后一个内核函数(等待通道)。当调试进程似乎被卡住或停滞的时候，可能有用。</li>
</ul>
<p>BSD语法的列名含义：</p>
<ul>
<li><code>VSZ</code>：虚拟内存大小</li>
<li><code>RSS</code>：驻留集大小</li>
<li><code>STAT</code>：为每个显示的PID展示多字符的进程状态，”s”是指部门主管，”N”用于优先级较低的进程，”l”表示进程是多线程的。</li>
<li><code>START</code>：指令启动的时间，只有过去一年中启动的进程才显示年份信息</li>
<li><code>COMMAND</code>：进程命令行，直到打印缓冲区的最大宽度，通常是标准输出。内核线程记为方括号，它们的内存和CPU使用率将为0.</li>
</ul>
</li>
</ol>
<h4 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h4><ol>
<li>日志的默认位置在<code>/var/log</code>下，标准系统日志通常是<code>/var/log/messages</code>或<code>/var/log/syslog</code></li>
<li>研究流程应该是证据驱动的。</li>
<li>一般来说，你可能不想更改服务器上的日志记录策略。但是你可以更改服务将其信息报告给系统日志的方式。使用NFS作为示例，如果正在排查似乎与网络存储相关的问题，那么可以暂时提升NFS服务或客户端的调试级别，收集额外信息，然后再将值还原到其原始状态。例如：<code>echo 32767 &gt;/proc/sys/sunrpc/nfs_debug</code>。在/proc下工作并立即对系统行为进行更改，是用来尝试隔离问题的一种非常有用的方法，也是可以提高性能和稳定性的测试场景。</li>
<li><code>/var/log/kernellog</code>，该日志文件包含重新启动后内核打印的消息，与dmesg命令提供的数据相当，还可以获得时间戳，这在关联问题时可以用到。</li>
<li>系统在启动顺序中提供的数据以及之前启动的数据：<code>boot.msg</code>，<code>boot.omsg</code></li>
<li>其他有用的日志：cron、cups（Common UNIX Printing System，通用Unix打印系统）、audits（The Linux Audit Subsystem is a system to Collect information regarding events occurring on the system(s)<br>Kernel events (syscall events)）、mail、samba。</li>
</ol>
<p>更新中。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/RDMA-2-Communication-Operations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/07/RDMA-2-Communication-Operations/" itemprop="url">RDMA-2-通信操作相关概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-07T13:55:37+08:00">
                2019-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/RDMA/" itemprop="url" rel="index">
                    <span itemprop="name">RDMA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年5月7日所写，未经允许不得转载。</p>
<h3 id="RDMA-Communication-Operations"><a href="#RDMA-Communication-Operations" class="headerlink" title="RDMA Communication Operations"></a>RDMA Communication Operations</h3><ol>
<li><p><strong>Send(发送)/Send With Immdiate(带立即数据发送)</strong></p>
<p>Send操作允许发送数据到一个远程QP的receive queue中。Receiver必须已经提前post一个receiver buffer来接受数据。Sender无法控制数据会放到远程主机的什么地方。</p>
<p>带立即数据发送：通过线路发送消息和4字节的带外数据。立即值作为接受通知的一部分展现给receiver，但是不包含在data buffer中。</p>
</li>
<li><p><strong>Receive</strong></p>
<p>接手主机被通知一个data buffer已经被接收了，可能带有一个inline immediate value。</p>
</li>
<li><p><strong>Read</strong></p>
<p>caller指定远程虚拟地址和拷贝到本地的内存地址。在执行RDMA操作之前，远程主机必须提供适当的访问它内存的permission。一旦设置了这些permissions，RDMA read操作在进行时就不会通知远程主机。对于RDMA read和write，远程端不会意识到这些操作已经完成(除了permissions和resources的准备阶段)。</p>
</li>
<li><p><strong>Write/Write With Immdiate</strong></p>
<p>write操作进行时不会通知远程主机。</p>
<p>带立即数据的write操作，会通知远程主机immediate value。</p>
</li>
<li><p><strong>Atomic Fetch and Add/ Atomic Compare and Swap</strong></p>
<p>这些是RDMA操作的扩展。</p>
<p>Atomic fetch and add操作原子进行往一个特定虚拟地址上增加的指定的值。</p>
<p>Atomic compare and swap操作原子比较一个特定虚拟地址的值，如果相等，那么改成一个指定的值。</p>
</li>
</ol>
<h3 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h3><p>建立一个QP的时候可以选择不同的传输模式。</p>
<p>这个API不支持RD。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">UD</th>
<th style="text-align:center">UC</th>
<th style="text-align:center">RC</th>
<th style="text-align:center">RD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Send(with immediate)</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">Receive</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">RDMA Write(with immediate)</td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">RDMA read</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">Atomic: Fetch and Add/Cmp and Swap</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">Max message size</td>
<td style="text-align:center">MTU</td>
<td style="text-align:center">1GB</td>
<td style="text-align:center">1GB</td>
<td style="text-align:center">1GB</td>
</tr>
</tbody>
</table>
<ol>
<li><p><strong>Reliable Connection(RC)</strong></p>
<ul>
<li><p>一个QP只和一个QP关联。</p>
</li>
<li><p>可靠传输、有序。</p>
</li>
<li><p>一个RC连接类似TCP连接。</p>
</li>
</ul>
</li>
<li><p><strong>Unreliable Connection(UC)</strong></p>
<ul>
<li><p>一个QP只和一个QP关联。</p>
</li>
<li><p>连接不可靠，可能会丢包。</p>
</li>
<li><p>错误的消息不会retry，错误处理需要有上层协议提供。</p>
</li>
</ul>
</li>
<li><p><strong>Unreliable Datagram(UD)</strong></p>
<ul>
<li><p>一个QP可能从其他QP接收或者向另其他QP发送单包消息。</p>
</li>
<li><p>不保证有序和送达。</p>
</li>
<li><p>receiver可能会丢弃包。</p>
</li>
<li>支持多播(一对多)。</li>
<li>一个UD连接类似于一个UDP连接。</li>
</ul>
</li>
</ol>
<h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><ol>
<li><p><strong>Send Request(SR)</strong></p>
<p>一个SR定义了发送多少数据、从哪里发、发送方式、发到哪里。</p>
<p>实现接口：<code>struct ib_send_wr</code></p>
</li>
<li><p><strong>Receive Request(RR)</strong></p>
<p>一个RR定义了buffers，即非RDMA操作数据将要接收到哪里。如果没有定义buffer并且一个发送端试图进行一个send操作或者一个RDMA write with immediate，那么一个Receive Not Ready(RNR) error将会被发送。</p>
<p>实现接口：<code>struct ibv_recv_wr</code></p>
</li>
<li><p><strong>Completion Queue</strong></p>
<p>一个完成队列是一个对象，包含已经提交给Work Queues（WQ）中的完成了的work requests。每个完成的意思是一个特定的WR结束了(既可能是成功完成的WR，也可能是没有成功完成的WR)。</p>
<p>一个CQ是一种机制，通知应用关于结束的Work Requests的信息(状态、操作码、大小、来源)。</p>
<p>CQs有n个Completion Queue Entries(CQE)，当CQ被创建的时候，指定CQE的数量。</p>
<p>当一个CQE被poll的时候，它就会从CQ中删除。</p>
<p>CQ是CQE的FIFO队列。</p>
<p>CQ可以是发送队列、接收队列或者两者皆是。</p>
</li>
<li><p><strong>Memeory Registration</strong></p>
<p>内存注册是一种机制，允许一个应用程序使用虚拟地址向网卡把一系列虚拟上连续的内存位置或者一系列物理上连续的内存位置描述成一个虚拟上的连续缓冲区。</p>
<p>注册过程固定内存页(来防止页被换出，保持物理地址和虚拟地址的映射)。</p>
<p>在注册过程中，OS会检查被注册块的permissions。</p>
<p>注册过程将虚拟地址表写到网卡中。</p>
<p>当注册内存的时候，设定域的操作权限，有local write, remote read, remote write, atomic, bind。</p>
<p>每个MR(内存域)有一个remote和local key(r_key, l_key)。local keys是本地HCA用来访问本地内存，例如说在一个接受操作中。Remote keys是给远程HCA来允许远程进程在RDMA操作中对系统内存进行访问。</p>
<p>同一个内存buffer可以被注册多次(即便是用不同的访问权限)，并且每次注册都会生成不同的keys。</p>
<p>接口：<code>struct ibv_mr</code></p>
</li>
<li><p><strong>Memory Window</strong></p>
<p>一个MW允许应用程序对远程访问内存有灵活的控制。</p>
<p>适用于：</p>
<ul>
<li>应用程序希望动态授予/撤回远程访问一个注册的域的权利，避免像注册/撤销注册/重复注册那样的性能开销。</li>
<li>应用程序想要授予不同的远程agent不同的远程访问权限，或者在一个注册域的不同范围授予这些权限。</li>
</ul>
<p>将MW关联一个MR的操作叫做Binding。</p>
<p>不同的MW可以重叠同一个MR(用不同的访问允许事件)。</p>
</li>
<li><p><strong>Address Vector</strong></p>
<p>地址向量是一个对象，描述了本地节点和远程节点的路由。</p>
<p>在每个UC/RC QP的QP context中有一个地址向量。</p>
<p>在UD QP中，地址向量应该在每个提交发送请求中定义。</p>
<p>接口：<code>struct ibv_ah</code></p>
</li>
<li><p><strong>Global Routing Header(GRH)</strong></p>
<p>用在子网之间的路由，当使用RoCE时，GRH是用来子网内路由的，是一个mandatory，为了让应用程序支持IB和RoCE。</p>
<p>当UD QP使用全局路由时，receiver buffer的前40个字节包含了GRH，这个区域用来存储全局路由信息，这样一个地址向量就能够产生来响应接收的数据包。如果UD使用了GRH，那么RR是应该始终有额外40字节。</p>
<p>接口：<code>struct ibv_grh</code></p>
</li>
<li><p><strong>Protection Domain</strong></p>
<p>是一个对象，里面的组件只能在其中互相交互。包含的组件有AH、QP、MR、SRQ。</p>
<p>保护域用来关联QP和内存域与内存窗口，作为一种允许和控制网卡访问主机系统内存的方式。</p>
<p>保护域也用来关联UD QP和AH，作为一种控制UD 目的地访问的方式。</p>
<p>接口：<code>struct ibv_pd</code></p>
</li>
<li><p><strong>Asynchronous Events</strong></p>
<p>网卡可能会发送异步事想件来通知SW关于在系统中发生的事件。</p>
<p>有两种异步事件类型：</p>
<ul>
<li>affiliated events：发生在个人的对象(CQ、QP、SRQ)。这些事件将会发送给一个特定的进程。</li>
<li>unaffiliated events：发生在全局对象上(网卡，端口错误)。这些事件将会发送给所有的进程。</li>
</ul>
</li>
<li><p><strong>Scatter Gather</strong></p>
<p>使用scatter gather elements收集/分发数据，包括：</p>
<ul>
<li>Address：将要gather或者scatter的本地数据buffer的地址。</li>
<li>Size：要读或者写的数据的大小。</li>
<li>L_key：MR的local key，注册了这段buffer。</li>
</ul>
<p>接口：<code>struct ibv_sge</code></p>
</li>
<li><p><strong>Polling</strong></p>
<p>轮询CQ是否完成是为了获得一个已提交的WR的信息。</p>
<p>如果在一个WR中有一个带有bad status的完成，那么剩下的completions都是坏的，并且工作队列将会被移动到error state。</p>
<p>每个被轮询没有completion的WR都是outstanding的。</p>
<p>只有在一个WR有一个completion之后，发送/接收buffer可能会被使用/复用/释放。</p>
<p>completion status总是应该被检查。</p>
<p>当一个CQE被轮询，就会从CQ中移除.</p>
<p>轮询操作接口：<code>ibv_poll_cq</code></p>
</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>RDMA Aware Programming User Manual.pdf</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/wireshark-lua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/wireshark-lua/" itemprop="url">Wireshark配置Lua插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-28T14:35:44+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/wireshark/" itemprop="url" rel="index">
                    <span itemprop="name">wireshark</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/wireshark/lua/" itemprop="url" rel="index">
                    <span itemprop="name">lua</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年4月28日所写，未经允许不得转载。</p>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>在wireshark的安装目录下面编辑init.lua文件，例如mac上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /Applications/Wireshark.app/Contents/Resources/share/wireshark/init.lua</div></pre></td></tr></table></figure>
<p>最后一行如果没有加添加，否则修改：<code>dofile(&quot;YOURFILEPATH.lua&quot;)</code>，里面写绝对路径。</p>
<p>然后重启wireshark。</p>
<p>注：DATA_DIR表示全局配置路径，USER_DIR表示用户配置路径。可以通过菜单<code>About Wireshark</code>-&gt;<code>Folders</code>查看路径。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://wiki.wireshark.org/Lua/" target="_blank" rel="external">https://wiki.wireshark.org/Lua/</a></p>
<p><a href="https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.html" target="_blank" rel="external">https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/19/RDMA-concepts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/19/RDMA-concepts/" itemprop="url">RDMA-1-基础术语</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-19T21:15:16+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/RDMA/" itemprop="url" rel="index">
                    <span itemprop="name">RDMA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年4月19日所写，未经允许不得转载。</p>
<h3 id="RDMA相关术语"><a href="#RDMA相关术语" class="headerlink" title="RDMA相关术语"></a>RDMA相关术语</h3><ol>
<li>Access Layer：用于访问互连结构（VPI，InfiniBand，以太网，FCoE）的低层操作系统基础设施。 它包括支持上层网络协议、中间件和管理代理所需的所有基本传输服务。</li>
<li>AH (Address Handle，地址句柄)：一个对象，UD QP中用于描述到远程端的路径。</li>
<li>CA (Channel Adapter，通道适配器)：终止一个Infiniband链路的设备，执行传输层的功能。</li>
<li>CI (Channel Interface，通道接口)：通过组合网络适配器，相关固件和设备驱动程序软件实现向动词消费者呈现通道。</li>
<li>CM (Communication Manager)：负责建立、维护释放RC、UC QP服务类型的通信。Service ID Resolution Protocol允许UD服务的用户放置QP来支持他们想要的服务。</li>
<li>Compare &amp; Swap：指示远程QP读取一个64位的值，将它和提供的比较值比较，如果相等，使用QP中的交换值替代。</li>
<li>CQ(Completion Queue)：一个先进先出的完成队列，包括CQE。</li>
<li>CQE(Completion Queue Entry)：CQ中的一个条目，描述了完成的WR的信息，例如状态、大小等。</li>
<li>DMA(Direct Memory Access)：允许硬件直接获取、放置内存中的数据，绕过CPU。</li>
<li>Fetch &amp; Add：指示远程的QP读取一个64位的值并加上QP中的数据值之后替代。</li>
<li>GUID(Globally Unique IDentifier)：64位的数唯一标识一台设备或者一个子网的一个组件。</li>
<li>GID(Global IDentifier)：一个128位的书用来表示一个网络适配器的端口、一个路由器的端口或者一个多播组。</li>
<li>GRH(Global Routing Header)：一个包头用来发送数据包跨过一个子网边界，也用来发送多播消息。</li>
<li>Join operation：一个IB端口要收到多播数据包必须通过发送一个请求给SA显式加入一个多播组。</li>
<li>lkey：一旦MR注册完会收到一个lkey被本地WR用来识别内存域和它相关的权限。</li>
<li>LID(Local IDentifier)：子网管理器分配一个一个16位的地址给端节点，每个LID在它的子网内都是唯一的。</li>
<li>LLE(Low Latency Ethernet)：允许以太网上的IB传输的CEE上的RDMA服务。</li>
<li>NA(Network Adapter)：终止链路的设备，执行传输层功能。</li>
<li>MGID(Multicast Group ID)：IB多播组，用MGID标识，由SM管理。SM把一个MLID和每个MGID联系起来，显式的设置互连的IB交换机，确保加入到多播组的所有端口都收到了数据包。</li>
<li>MR(Memory Region)：已经注册了访问的权限的一段连续内存buffer，这些buffer需要注册来让网络适配器使用它们。在注册过程中，L_Key和R_Key会被创建并和已经创建的内存域关联。</li>
<li>MTU(Maximum Transfer Unit)：一个端口可以发送或接受的一个数据包payload的最大大小(不包括headers)。</li>
<li>MW(Memory Window)：分配的资源——在绑定到现有内存注册中的指定区域后启用远程访问。每个内存窗口都一个关联的窗口句柄，一系列访问权限和当前的R_Key。</li>
<li>Outstanding Work Request：那些已经提交到工作队列但是没有poll通知完成的。</li>
<li>pkey(Partition key)：pkey标识了端口属于的partition。一个pkey约类似于以太网的VLAN ID。用来指向一个在端口的partition key表里的一个条目。每个端口都被子网管理器（SM）指派了至少一个pkey。</li>
<li>PD(Protection Domain)：独立WQ的pair(发送队列和接收队列)包在一起放在一个对象里，目的是传输数据一个网络中节点之间的数据。Posts用来初始化发送和接收数据。有三种QP类型：<strong>UD Unreliable Datagram</strong>，<strong>UC Ureliable Connection</strong>，<strong>RC Reliable Connection</strong>。</li>
<li>RC(Reliable Connection)：一个QP传输服务类型，基于一个面向连接的协议。一个QP(Queue pair)和另外一个单个QP。这些消息将以可靠的方式发送(包括正确性和信息顺序)。</li>
<li>RDMA_CM(Remote Direct Memeory Access Communication Manager)：API，用来建立可靠、面向连接的和不可靠的数据报的数据传输。它提供了一个RDMA传输中性接口，用于建立连接。API基于sockets，但是适用于基于QP的语义：通信必须通过一个特定的RDMA设备，数据传输基于消息。</li>
<li>Requestor：连接中初始化一次数据传输的一方(通过提交一个发送请求)。</li>
<li>Responder：连接中响应从请求方来的命令（可能包括一个写到响应方的内存或从响应方内存读取的请求，以及最后请求响应者接受消息的的命令）的那一方。</li>
<li>rkey：MR一注册就会收到的数字，用来对即将到来的RDMA操作加以限制。</li>
<li>RNR(Receiver Not Ready)：一个RC QP中的流，双方连接已经有了但是接受方还没有RR。</li>
<li>RQ(Receive Queue)：工作队列维护着用户提交的RR。</li>
<li>RR(Receive Request)：提交给一个RQ的WR，描述了使用一个发送操作码的即将到来的数据将会写到哪里。同时一个带有immediate的RDMA Write将会消耗一个RR。</li>
<li>RTR(Ready To Receive)：一种QP的状态，一个RR可以被post或者被处理。</li>
<li>RTS(Ready To Send)：一种QP的状态，一个SR可以被post或者被处理。</li>
<li>SA(Subnet Administrator)：用来查询或者处理子网管理数据的接口。</li>
<li>SGE(Scatter/Gather Elements)：S/G元素数组，S/G元素存在于一个WR ，根据使用的操作码或者从多个缓存中收集数据，把它们作为一个单独的流发送，或者把一个单独流分解成到几个缓存中。</li>
<li>SM(Subnet Manager)：配置和管理子网的实体；发现网络拓扑；制定LID；决定路由方案设置路由表；一个master SM和几个可能的slaves(Standby mode)；管理交换机路由表，从而建立通过结构的路径。</li>
<li>SQ(Send Queue)：一个工作队列，维护了用户提交的SR。</li>
<li>SR(Send Request)：发送给一个SQ的WR，描述了多少数据将会被传输、它的方向和方式(操作码)。</li>
<li>SRQ(Shared Receive Queue)：一个含有WQE的队列，里面有即将到来的来自于任何与它相关联的RC/UC/UD的QP。SRQ可以关联超过一个QP。</li>
<li>TCA(Target Channel Adapter)：一个通道适配器不需要支持verbs，通常在I/O设备中使用。</li>
<li>UC(Unreliable Connection)：一种QP传输服务类型，基于面向连接的协议，QP会关联另一个单独的QP。这种QP不执行可靠协议，消息可能会丢失。</li>
<li>UD(Unreliable Datagram)：一种QP传输服务类型，其中消息可以是一个数据包长度，每个UD QP可以从子网中的另一个UD QP发送/接收消息。消息可能会丢失，订单无法保证。UD QP是唯一支持多播消息的类型。 UD数据包的消息大小限制为路径MTU。</li>
<li>Verbs：一个网络适配器功能的抽象描述。任何应用程序可以使用这些verbs，创建/管理需要对象来使用RDMA进行数据传输。</li>
<li>VPI（Virtual Protocol Interface）：允许用户改变二层协议的端口。</li>
<li>WQ(Work Queue)：发送队列或者消息队列的一种。</li>
<li>WQE：发音为”wookie”，一个工作队列里的一个元素。</li>
<li>WR(Work Request)：用户提交到工作队列的一个请求。</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="http://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf" target="_blank" rel="external">RDMA aware programming user manual.pdf</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/CplusPrimer-object-and-class-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/CplusPrimer-object-and-class-note/" itemprop="url">C++ Primer Plus 第十章对象和类笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T15:51:18+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ Primer Plus</em> 第十章对象和类笔记整理。—— Jiawei Xu 2019年3月7日</p>
<p><strong>关键字：</strong>类、结构、定点表示法、构造函数、析构函数、const成员函数、this指针、类作用域</p>
<ol>
<li><p>数据项通常放在私有部分，组成类接口的成员函数放在公有部分。——数据隐藏</p>
</li>
<li><p>不必在类声明中使用关键字private，因为这是类对象的默认访问控制。</p>
</li>
<li><p><strong>类class和结构struct</strong>之间的唯一区别：结构的默认访问类型是public，而类为private。C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象（常被称为普通老式数据（POD, Plain Old Data）结构）。</p>
</li>
<li><p>cout使用定点表示法：<code>std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield;</code></p>
<p>显示三位小数：<code>std::cout.precision(3);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::streamsize prec = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">3</span>); <span class="comment">//保存</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.precision(prec); 	<span class="comment">//reset</span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::ios_base::fmtflags orig = <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed); <span class="comment">//保存原始flags</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(org, <span class="built_in">std</span>::ios_base::floatfield); <span class="comment">//floatfield包括定点表示法标记和科学表示法标记</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>类的构造函数</strong></p>
<ul>
<li><p>构造函数的原型和函数头虽然没有返回值，但没有被声明为void类型。原型位于类声明的<strong>公有</strong>部分。</p>
</li>
<li><p>构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，<strong>参数名不能与类成员相同</strong>。一种常见的做法是在数据成员名中使用 m<em> 前缀，另一种是，在成员名中使用后缀 </em>。</p>
</li>
<li><p><strong>两种使用构造函数来创建并初始化对象的方式：</strong></p>
<ol>
<li><p>显式地调用构造函数，如：</p>
<p><code>Stock food = Stock (&quot;World Cabbage&quot;, 250, 1.25);</code></p>
<p><strong>C++标准允许编译器使用两种方法来执行：一种是和下面的2一样，另一种方式是允许调用构造函数来创建一个临时变量，然后将该临时对象复制到food中，并丢弃它。</strong></p>
</li>
<li><p>隐式地调用构造函数，如：</p>
<p><code>Stock garment(&quot;Furry Mason&quot;, 50, 2.5);</code></p>
<p>这种格式更紧凑，等价于显式调用<code>Stock garment = Stock(&quot;Furry Mason&quot;, 50, 2.5);</code></p>
</li>
<li><p>每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数，将构造函数和new一起使用的方法：</p>
<p><code>Stock *pstock = new Stock(&quot;Electroshock Games&quot;, 18, 19.0);</code>创建一个Stock对象，将其初始化为参数提供的值，并将对象的地址赋给pstock指针。</p>
</li>
</ol>
</li>
<li><p>无法适用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。</p>
</li>
<li><p><strong>默认构造函数</strong></p>
<ol>
<li><p>用于下面这种声明的构造函数：<code>Stock fluffy_the_cat;</code></p>
<p>如果没有提供任何构造函数，则C++将自动提供默认构造函数。对于Stock类来说，默认构造函数可能如下：<code>Stock::Stock() {}</code></p>
</li>
<li><p>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。原因：想禁止创建未初始化的对象。</p>
</li>
<li><p>定义默认构造函数的方式有两种，不要同时使用，用户定义的默认构造函数通常给所有成员提供隐式初始化。在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数：</p>
<ul>
<li><p>1）给已有构造函数的所有参数提供默认值：</p>
<p><code>Stock(const string &amp; co = &quot;Error&quot;, int n = 0, double pr = 0.0&quot;);</code></p>
</li>
<li><p>2）通过函数重载来定义另一个构造函数——一个没有参数的构造函数：</p>
<p><code>Stock();</code></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>构造函数的作用：</p>
<ol>
<li>用于初始化新对象</li>
<li>通过让构造程序创建一个新的、临时的对象，然后将其内容复制给一个对象来实现。随后程序调用析构函数，已删除该临时对象。有些编译器可能要过一段时间才删除临时变量，因此析构函数的调用将延迟。</li>
</ol>
</li>
<li><p>如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。<strong>通常这种方式的效率更高。</strong></p>
<p><code>Stock stock2 = Stock(&quot;Buffo Objects&quot;, 2, 2.0);</code></p>
<p><code>stock1 = Stock(&quot;Nifty Foods&quot;, 10, 50.0);</code></p>
<p>第一句是初始化，它创建有指定值的的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值，像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象。</p>
</li>
</ul>
</li>
<li><p><strong>类的析构函数</strong></p>
<ul>
<li>析构函数也可以没有返回值和声明类型。析构函数没有参数。原型必须类似于：<code>~Stock();</code>。</li>
<li>通常不应正在代码中显示地调用析构函数。如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用。如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中 ，当使用delete来释放内存时，其析构函数将自动被调用。最后，程序可以创建临时对象来完成该特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。</li>
</ul>
</li>
<li><p>在C++11中，可以将列表初始化语法用于类。只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起。</p>
</li>
<li><p><strong>const成员函数</strong></p>
<p>应尽可能将const引用和指针用作函数形参一样，只要类方法不修改调用函数，就应将其声明为const。</p>
<p><code>const Stock &amp; Stock::topval(const Stock &amp; s) const</code> 三个const的意义：1：返回类型为const的引用 2：将函数参数声明为const引用或指向const的指针保证调用对象不被修改。该函数不会修改被显示地访问的对象；3：该函数不会修改被隐式地访问的对象。</p>
</li>
<li><p><strong>this指针</strong></p>
<p>每个成员函数（包括构造函数和析构函数）都有一个this指针，this指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式 *this 。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。</p>
<p>*this是对象本身，this是对象的地址。</p>
</li>
<li><p>对象数组</p>
<p>初始化对象数组的方案是，首先使用默认构造函数创建数字元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中，因此，要创建类对象数组，则这个类必须有默认构造函数。例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">4</span>;</div><div class="line">Stock stocks[STKS] = &#123;</div><div class="line">    Stock(<span class="string">"NanoSmart"</span>, <span class="number">12.5</span>, <span class="number">20</span>),</div><div class="line">    Stock();</div><div class="line">    Stock(<span class="string">"Monolithic Obelisks"</span>, <span class="number">130</span>, <span class="number">3.25</span>),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>类作用域</strong></p>
<p>使符号常量的作用域为类很有用。常量对于所有对象来说都是相同的，因此可创建一个由所有对象共享的常量。有两种方式：</p>
<ul>
<li><p>1）在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整个型常量提供作用域为整个类的符号名称。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    	<span class="keyword">enum</span> &#123;Months = <span class="number">12</span>&#125;;</div><div class="line">    	<span class="keyword">double</span> costs[Months];</div><div class="line">    	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用枚举只是为了创建符号常量，并不打算创建枚举类型的变量，因此不需要提供枚举名。</p>
<p>用这种方式枚举不会创建类数据成员，也就是说，所有对象中都不包含枚举。</p>
</li>
<li><p>2）另一种在类中定义常量的方式——使用关键字static：例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</div><div class="line">    	<span class="keyword">double</span> costs[Months];</div><div class="line">    	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。因为，只有一个Months常量，被所有Bakery对象共享。C++98中，只能用这种技术声明值为整数或枚举的静态常量，而不能存储double常量。C++11没有这种限制。</p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/07/CplusPrimer-namespace-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/CplusPrimer-namespace-note/" itemprop="url">C++ Primer Plus 命名空间笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T15:20:34+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ Primer Plus</em> 名称空间 笔记整理。—— Jiawei Xu 2019年3月7日</p>
<p><strong>using声明</strong>使特定的标识符可用，<strong>using编译指令</strong>使整个名称空间可用。</p>
<p><strong>名称空间指导原则：</strong></p>
<ol>
<li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li>
<li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li>
<li>如果开发了一个函数库或类库，将其放在一个名称空间中。</li>
<li>不要在头文件中使用using编译指令。这样会掩盖要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理编译指令#include之后。</li>
<li>导入名称时，首选使用作用域解析运算符或using声明的方法。</li>
<li>对于using声明，首选将其作用域设置为局部而不是全局。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/ip-conf-file-inconsistency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/ip-conf-file-inconsistency/" itemprop="url">解决Centos网卡IP和配置文件不符的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T22:15:45+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月9日所写，未经允许不得转载。</p>
<p>昨天发现连不上自己的服务器了，以为是网卡没起来或者网线被别人重插了，后来看了一下发现网卡起来了，ip也配的是对的，再ifconfig下，发现居然网卡em1用的是网卡em2的配置文件。如图：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060901.png" alt="2018060901"></p>
<p>并且，修改em2的配置文件中的ip，em1会相应变化，推测em1和em2互用了对方的配置文件= =。</p>
<p>使用nmcli查看，确实如此：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060902.png" alt="2018060902"></p>
<p>在别的正常的服务器上，是这样的：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060903.png" alt="2018060903"></p>
<p><strong>验证了我的猜测，下面是解决方案：</strong></p>
<p>Red Hat Enterprise Linux 7 与 CentOS 7 中默认的网络服务由 NetworkManager 提供，这是动态控制及配置网络的守护进程，它用于保持当前网络设备及连接处于工作状态，同时也支持传统的 ifcfg 类型的配置文件。可以用<strong>命令行工具 nmcli</strong> 来控制 NetworkManager，相应的也有一个<strong>图形化的配置工具nmtui</strong>。</p>
<p>NetworkManager 可以用于以下类型的连接：Ethernet，VLANS，Bridges，Bonds，Teams，Wi-Fi，mobile boradband（如移动3G）以及 IP-over-InfiniBand。针对与这些网络类型，NetworkManager 可以配置他们的网络别名，IP 地址，静态路由，DNS，VPN连接以及很多其它的特殊参数。 </p>
<p><strong>一些Network Manager中的概念：</strong></p>
<ul>
<li>device叫网络接口，是物理设备</li>
<li>connection是连接，偏重于逻辑设置</li>
<li>多个connection可以应用到同一个device，但同一时间只能启用其中一个connection。这样的好处是针对一个网络接口，我们可以设置多个网络连接，比如静态IP和动态IP，再根据需要up相应的connection。</li>
</ul>
<p><strong>nmcli的具体用法可以参考manpage，下面是常用命令（单词可以不写全，比如connection写成con）：</strong></p>
<ol>
<li><p>nmcli modifiy命令修改网卡的具体配置，实际上编辑的是<code>/etc/sysconfig/network-scripts/ifcfg-*</code>文件。在不想使用该文件时，可以通过delete删除对应的连接：<code>nmcli connection delete ens3</code>。默认情况下通过nmcli add 或 modify的操作只是修改了配置文件，并不会立即生效，想要生效启用，需要通过“nmcli conn up 接口名” 来启用对应的配置。 </p>
</li>
<li><p><code>nmcli -p con up em1 ifname em1</code>修改设备连接的配置文件，<strong>只用这个来修改网卡使用的配置文件的话重启网卡之后就会无效！</strong>因为默认的网卡和配置文件之间的连接没有删除。</p>
</li>
<li><p><code>nmcli -p connection show &quot;em1&quot;</code> 显示em1连接配置集详情 </p>
</li>
<li><p><code>nmcli -p -m multiline -f all con show</code> 显示NetworkManager 连接配置集</p>
</li>
<li><p><code>nmcli -f name,autoconnect c s</code></p>
</li>
<li><p><code>nmcli connection show</code>查看当前的连接，terminal里未启用的是黄色，启用的是绿色。</p>
</li>
<li><p><code>nmcli connection show --active</code>仅查看活跃连接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# nmcli connection show --active</div><div class="line">名称    UUID                                  类型            设备   </div><div class="line">em2     c67732e2-be50-4589-ad40-4537da423795  802-3-ethernet  em1    </div><div class="line">virbr0  4c0b2e32-9e55-472f-8693-03fda6c95847  bridge          virbr0`</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="解决步骤："><a href="#解决步骤：" class="headerlink" title="解决步骤："></a><strong>解决步骤</strong>：</h3><p>一开始以为网卡的配置是单纯找对应网卡名称的配置文件，现在才知道是将网卡设备和逻辑接口连接起来，然后使用逻辑接口的配置文件。</p>
<p>首先使用<code>nmcli connection delete CONNECTION_NAME</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection delete em2     //把网卡em1和配置文件ifcfg-em2的连接断开</div></pre></td></tr></table></figure>
<p>下一步，把网卡em1和接口em1匹配起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection add ifname em1 con-name em1 type ethernet //建立网卡em1和逻辑接口em1的连接</div></pre></td></tr></table></figure>
<p>然后，使用<code>nmcli connection show</code>就可以看到增加了一条连接信息，显示黄色说明还没有启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nmcli connection delete be36eaf2011de-43ab-9ff6-58b32796a444 //删掉下图绿色下面一行的未启动的网卡em2和逻辑接口em1的连接</div><div class="line">nmcli connection add ifname em2 con-name em2 type ethernet //建立网卡em2和逻辑接口em2的连接</div></pre></td></tr></table></figure>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060904.jpg" alt="2018060904"></p>
<p>但是，因为刚刚建立网卡em1和逻辑接口em1的时候，网卡em2和逻辑接口em1的连接还没删除，所以在/etc/sysconfig/network-scripts里面会出现ifcfg-em1-1，把文件名改成ifcfg-em1，需要在里面配置好静态ip、网关等信息然后保存。</p>
<p>再次用<code>nmcli connection show</code>查看，发现网卡em1和逻辑接口em1连接了，网卡em2和逻辑接口em2连接了，原来的连接断开了。但是em1的连接没有启用（红色）。</p>
<p>用nmtui编辑连接后，ifcfg文件也会有相应的改动；手工修改ifcfg后，nmtui中也能看到。<br>但是，<strong>不论用nmtui还是直接修改ifcfg文件，想让新的配置生效，需要load连接配置文件并重新up连接。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nmcli con load /etc/sysconfig/network-scripts/ifcfg-em1</div><div class="line">nmcli con load /etc/sysconfig/network-scripts/ifcfg-em2</div><div class="line">nmcli con up em1</div></pre></td></tr></table></figure>
<p>再次用<code>nmcli connection show</code>查看，发现网卡em1和逻辑接口em1连接启用了（显示绿色）</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060905.jpg" alt="2018060905"></p>
<p>服务器重启之后，配置依然有效，至此解决。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cnblogs.com/panblack/p/Centos7-WhatsNew-02-networking.html" target="_blank" rel="external">https://www.cnblogs.com/panblack/p/Centos7-WhatsNew-02-networking.html</a></li>
<li>nmcli(1) Linux man page</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/promiscuous-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/promiscuous-mode/" itemprop="url">关于网卡的混杂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T22:13:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月9日所写，未经允许不得转载。</p>
<p>tcpdump的一个副作用就是可以让网卡进入混杂模式。每次tcpdump，都会在/var/log/messages里看到这样：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060907.png" alt="2018060907"></p>
<p>实际上，网卡是否处于PROMISC模式，ifconfig（ip link show也是如此）并不是最直接的判断依据，换句话说就是ifconfig能看到PROMISC标记表示一定处于混杂模式，但处于混杂模式并不一定能看到PROMISC标记。内核判断网卡是否处于混杂模式是看<code>/sys/class/net/ifname/flags</code>的值，如果置位了0x100，则处于混杂模式。</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060906.png" alt="2018060906"></p>
<ul>
<li><strong>混杂模式的ifconfig和ip link show都按看不到的问题</strong></li>
</ul>
<p><a href="http://seclists.org/bugtraq/2002/Jul/302有这样的解释" target="_blank" rel="external">http://seclists.org/bugtraq/2002/Jul/302有这样的解释</a></p>
<blockquote>
<p>This is a well knwon issue and C. Grenier and I have understood why<br>very recently. In fact, this due to the changing of the handling of<br>promiscuous mode in kernel space.</p>
<p>With kernel 2.0, one had to perform the following to set the interface<br>to promiscuous mode:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">strncpy</span>(ifr.ifr_name, <span class="string">"eth0"</span>, IFNAMSIZ);</div><div class="line">&gt; ioctl(sock, SIOCGIFFLAGS, &amp;ifr);</div><div class="line">&gt; ifr.ifr_flags |= IFF_PROMISC;</div><div class="line">&gt; ioctl(sock, SIOCSIFFLAGS, &amp;ifr);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The trouble was that the promiscuous mode was handled by a flag.  Each<br>time a process sets this mode, the flag is set. But if another process<br>removes this mode, the flag is cleared. Rather bad behavior.</p>
<p>Since kernel 2.2, a processus must ask to enter in a membership of<br>process (setsockopt(…, PACKET_ADD_MEMBERSHIP,…)) using the<br>interface in promiscuous mode. A counter is then increased. One a<br>process of the membership does not need the promiscuous mode anymore,<br>it drops the membership (setsockopt(…, PACKET_DROP_MEMBERSHIP, …))<br>the counter is decreased, and promiscuous mode is disabled as soon as<br>the counter is 0. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq</span> <span class="title">mr</span>;</span></div><div class="line">&gt; ...</div><div class="line">&gt; <span class="built_in">memset</span>(mr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mr));</div><div class="line">&gt; mr.mr_ifindex = ifr.ifr_ifindex;</div><div class="line">&gt; mr.mr_type =  PACKET_MR_PROMISC;</div><div class="line">&gt; setsockopt(sock, SOL_PACKET, PACKET_ADD_MEMBERSHIP, (<span class="keyword">char</span> *)&amp;mr, <span class="keyword">sizeof</span>(mr));</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The call to ioctl(SIOCGIFFLAGS) reports only promiscuous mode sets by<br>ioctl(SIOCSIFFLAGS).</p>
</blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://ieevee.com/tech/2016/11/24/promisc.html" target="_blank" rel="external">https://ieevee.com/tech/2016/11/24/promisc.html</a></li>
<li><a href="http://seclists.org/bugtraq/2002/Jul/302" target="_blank" rel="external">http://seclists.org/bugtraq/2002/Jul/302</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/CplusPrimerChapter9-mem-manage-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/CplusPrimerChapter9-mem-manage-note/" itemprop="url">C++内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T21:58:50+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ Primer Plus</em> 第九章的内存模型 笔记整理。—— Jiawei Xu 2019年3月6日</p>
<hr>
<p><strong>关键字：</strong>存储持续性、链接性、作用域、初始化、单定义规则、存储说明符（auto, register, static, extern, mutable, thread_local）、CV限定符（const, volatile）、名称修饰/矫正/C++语言链接性</p>
<h4 id="变量内存管理-存储持续性"><a href="#变量内存管理-存储持续性" class="headerlink" title="变量内存管理-存储持续性"></a>变量内存管理-存储持续性</h4><p>C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间。</p>
<ul>
<li><p><strong>自动存储持续性</strong>（栈）：</p>
<p>在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们的内存被释放。<strong>C++有两种存储持续性为自动的变量</strong>：局部变量和register关键字。</p>
</li>
<li><p><strong>静态存储持续性</strong>（全局变量/外部变量、static）：</p>
<p>在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为<strong>静态</strong>。它们在程序整个运行过程中都存在。</p>
<p><strong>C++有三种存储持续性为静态的变量</strong>，在整个程序执行期间存在，未被初始化的静态变量默认为0，静态数组和结果的每个元素和成员的所有位都置为0，这种变量被称为<strong>零初始化</strong>的(zero-initialized)：</p>
<ul>
<li><strong>外部链接性external linkage</strong>：可在其他文件中访问，格式：代码块外面声明</li>
<li><strong>内部链接性internal linkage</strong>：只能在当前文件中访问，格式：代码块外面声明+static限定符</li>
<li><strong>无连接性static linkage</strong>：只能在当前函数或代码块中访问，格式：代码块内声明+static限定符</li>
</ul>
</li>
<li><p><strong>动态存储持续性</strong>（堆/自由存储）：</p>
<p>用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的持续性为动态，有时候被称为自由存储(free store)或堆(heap)。</p>
</li>
<li><p><strong>线程存储持续性</strong>（C++11、并行编程、thread_local）</p>
<p>如果变量使用关键字<strong>thread_local</strong>声明的，则其生命周期与所属的线程一样长，并行编程的内容。thread_local之于线程，犹如常规静态变量之于整个程序。</p>
</li>
</ul>
<h4 id="链接性（linkage）"><a href="#链接性（linkage）" class="headerlink" title="链接性（linkage）"></a>链接性（linkage）</h4><p>描述了名称如何在不同单元间共享。链接性在外部的名称可在文件间共享，链接性在内部的名称只能由一个文件中的函数共享。</p>
<h4 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h4><p>文件作用域（作用域为全局）：从定义位置到文件结尾之间可用。</p>
<p>局部作用域（自动变量，automatic variable）：局部。</p>
<p>静态变量的作用域：全局还是局部取决于如何被定义。</p>
<p>函数原型作用域(function prototype scope)中使用的名称只在包含参数列表的括号内可用。</p>
<p>类中声明的成员的作用域：整个类。</p>
<p>在名称空间中声明的变量的作用域为整个名称空间，全局作用域是名称空间作用域的特例。</p>
<h4 id="Auto"><a href="#Auto" class="headerlink" title="Auto"></a>Auto</h4><p>C和C++11之前，用于显式地指出变量为自动存储</p>
<p>C++11中，用于自动类型推断</p>
<h4 id="寄存器变量Register"><a href="#寄存器变量Register" class="headerlink" title="寄存器变量Register"></a>寄存器变量Register</h4><p>C和C++11之前，建议编译器使用CPU寄存器来存储自动变量，旨在提高访问变量的速度；</p>
<p>C++11中，用于显式地指出变量是自动的，作用域为代码块，在代码块中声明，无链接性。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li><p>静态初始化=零初始化+常量表达式初始化（sizeof运算符也包括）</p>
<p>在编译器处理文件时初始化</p>
</li>
<li><p>动态初始化：</p>
<p>在编译后初始化</p>
</li>
<li><p>C++新增关键字constexpr</p>
<p>创建常量表达式的方式</p>
</li>
</ul>
<h4 id="外部-全局变量的C-单定义规则-One-Definition-Rule-ODR"><a href="#外部-全局变量的C-单定义规则-One-Definition-Rule-ODR" class="headerlink" title="外部/全局变量的C++单定义规则(One Definition Rule, ODR)"></a>外部/全局变量的C++单定义规则(One Definition Rule, ODR)</h4><p><strong>外部变量</strong>：链接性为外部的变量，存储持续性为静态，作用域为整个文件。也称全局变量。</p>
<p>如果要在多个文件中使用外部变量，只需要在一个文件里包含定义，但是其他文件使用的时候都要用extern声明。</p>
<p>两种外部变量声明的方式：</p>
<ul>
<li><p>定义声明/定义defining declaring/definition（给变量分配存储空间）</p>
</li>
<li><p>引用申明/声明 referencing declaration/declaration（不给变量分配存储空间）</p>
<p>方法：在变量前面用<strong>关键字extern</strong>，且不进行初始化（两个条件都要满足，否则声明为定义，会分配存储空间）</p>
<p><strong>C++中的作用域解析运算符(::)</strong>：放在变量名前，该运算符表示使用变量的全局版本（更安全，不依赖于作用域）</p>
</li>
</ul>
<p>在多文件程序中，可以在一个文件（且只能在一个文件）定义一个外部变量，使用它的其他文件必须使用关键字extern声明它。</p>
<h4 id="存储说明符"><a href="#存储说明符" class="headerlink" title="存储说明符"></a>存储说明符</h4><ul>
<li>auto（C++11之后不再是说明符）</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>thread_local（C++11新增）</li>
<li>mutable：即使结构（或类）变量为const，其某个成员也可以被修改，</li>
</ul>
<h4 id="CV-限定符"><a href="#CV-限定符" class="headerlink" title="CV-限定符"></a>CV-限定符</h4><ul>
<li>const：在C++中，const限定符对默认存储类型有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。<ul>
<li>在C++下，全局const定义就像是使用了static说明符一样。</li>
<li>可以使用extern关键字覆盖默认的内部链接性<code>extern const int states=50;</code>，鉴于单个const在多个文件间共享，因此只有一个文件可对其进行初始化。</li>
<li>在函数或代码块中声明const时，作用域为代码块。</li>
</ul>
</li>
<li>volatile：即使程序代码没有对内存单元进行修改，其值也可能发生变化。作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile。则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器不要进行这种优化。</li>
</ul>
<h4 id="函数链接性"><a href="#函数链接性" class="headerlink" title="函数链接性"></a>函数链接性</h4><ul>
<li><p>所有函数的存储持续性都自动为静态的。默认情况下，函数的链接性为外部的，可以在文件间共享。、</p>
</li>
<li><p>可以使用static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字。于是，可以在其他文件中定义同名的函数，和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义。</p>
</li>
<li>单定义规则也适用于非内联函数，对于每个非内联函数，程序只能包含一个定义。对于链接性为外部的函数来说，多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。</li>
</ul>
<h4 id="C-查找函数定义的顺序"><a href="#C-查找函数定义的顺序" class="headerlink" title="C++查找函数定义的顺序"></a>C++查找函数定义的顺序</h4><ul>
<li>静态函数：本文件</li>
<li>所有程序文件-&gt;没找到的话，在库中搜索</li>
</ul>
<h4 id="名称矫正-名称修饰-C-语言链接"><a href="#名称矫正-名称修饰-C-语言链接" class="headerlink" title="名称矫正/名称修饰/C++语言链接"></a>名称矫正/名称修饰/C++语言链接</h4><p>在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称，这种方法被称为C++语言链接（C++ language linkage）。方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; void spiff(int)  //使用C语言链接性</div><div class="line">extern void spiff(int) 		//使用C++语言链接性</div><div class="line">extern &quot;C++&quot; void spiff(int) 		//使用C++语言链接性</div></pre></td></tr></table></figure>
<h4 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h4><p>含义：使用C++运算符new(或C函数malloc())分配的内存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">icestrawberryxjw</p>
              <p class="site-description motion-element" itemprop="description">The most difficult thing is the decision to act, the rest is merely tenacity.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/icestrawberryxjw" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">icestrawberryxjw</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
