<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:type" content="website">
<meta property="og:title" content="icestrawberryxjw">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="icestrawberryxjw">
<meta property="og:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="icestrawberryxjw">
<meta name="twitter:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>icestrawberryxjw</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">icestrawberryxjw</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/23/ubuntu-network-config-problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/23/ubuntu-network-config-problem/" itemprop="url">ubuntu14.04.6网络配置不生效的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-23T13:58:19+08:00">
                2019-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年6月23日所写，未经允许不得转载。</p>
<ul>
<li><p>系统：ubuntu14.04.6 Desktop</p>
</li>
<li><p>问题描述：eth0默认ip是192.168.122.201 想要修改，修改配置文件不生效</p>
</li>
<li><p>具体过程：</p>
<ol>
<li><p>修改配置文件<code>/etc/network/interfaces</code>如下:</p>
<p>​    <code>vivienne@vivienne-PowerEdge-R730:$ sudo vim /etc/network/interfaces</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> The loopback network interface</div><div class="line">auto lo</div><div class="line">iface lo inet loopback</div><div class="line"></div><div class="line"><span class="meta">#</span> The primary network interface</div><div class="line">auto eth0</div><div class="line">address IP地址</div><div class="line">netmark 255.255.255.0</div><div class="line">gateway 默认网关</div><div class="line">dns-namespace DNS1 DNS2</div></pre></td></tr></table></figure>
</li>
<li><p><code>vivienne@vivienne-PowerEdge-R730:$ sudo /etc/init.d/networking restart</code></p>
<p>结果失败：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stop: Job is already while stopping</div><div class="line">start: Job is already running: networking</div></pre></td></tr></table></figure>
</li>
<li><p>查阅log：<code>vivienne@vivienne-PowerEdge-R730:$ sudo tail -f /var/log/upstart/networking.log</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stopping or restarting the networking job is not supported.</div><div class="line">Use ifdown &amp; ifup to reconfigure desired interface.</div></pre></td></tr></table></figure>
</li>
<li><p>那么使用ifdown ifup来重启，也失败了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vivienne@vivienne-PowerEdge-R730:$ sudo ifdown --exclude=lo -a &amp;&amp; sudo ifup --exclude=lo -a</div><div class="line">RTNETLINK answers: No such process</div><div class="line"></div><div class="line">vivienne@vivienne-PowerEdge-R730:$ sudo ip addr flush dev eth0 &amp;&amp; sudo ifdown eth0 &amp;&amp; sudo ifup eth0</div><div class="line">RTNETLINK answers: No such process</div><div class="line">RTNETLINK answers: No such process</div></pre></td></tr></table></figure>
</li>
<li><p>最后尝试重启Networkmanager。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vivienne@vivienne-PowerEdge-R730:$ sudo NetworkManager restart</div><div class="line">NetworkManager is already running (pid 1790)</div><div class="line">vivienne@vivienne-PowerEdge-R730:$ sudo kill 1790</div><div class="line">vivienne@vivienne-PowerEdge-R730:$ sudo NetworkManager restart</div><div class="line">NetworkManager is already running (pid 7721)</div></pre></td></tr></table></figure>
<p>之后ifconfig查看、ping。解决，over。</p>
</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/2019-06-01-fragmented-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/2019-06-01-fragmented-knowledge/" itemprop="url">2019-06-01-零碎知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-01T16:15:41+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日常零碎/" itemprop="url" rel="index">
                    <span itemprop="name">日常零碎</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年6月1日所写，未经允许不得转载。</p>
<ol>
<li><p><strong>shell中的eval</strong></p>
<p>功能：重新运算求出参数的内容</p>
<p>语法：eval [参数]</p>
<p>补充说明：eval可读取一连串的参数，然后再依参数本身的特性来执行</p>
<p>参数：参数不限数目，彼此之间用分号隔开</p>
<ul>
<li><p>eval命令将会首先扫描命令行进行所有的替换，然后再执行命令。该命令使用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描，这些需要进行两次扫描的变量有时候被称为复杂变量</p>
</li>
<li><p>eval也可以用于回显简单变量，不一定时复杂变量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NAME=ZONE</div><div class="line">eval echo $NAME等价于echo $NAME</div></pre></td></tr></table></figure>
</li>
<li><p>两次扫描</p>
<p>test.txt内容：hello shell world!</p>
<p>myfile=”cat test.txt”</p>
<p>(1) echo $myfile　　#result:cat test.txt</p>
<p>(2) eval echo $myfile　　#result:hello shell world!</p>
<p>第一次扫描进行了变量替换，第二次扫描执行了该字符串中所包含的命令</p>
</li>
<li><p>获得最后一个参数</p>
<p>echo “Last argument is \$(eval echo \\$\$#)”</p>
<p>echo “Last argument is \$(eval echo $#)”</p>
</li>
</ul>
<p>参考资料：<a href="https://www.cnblogs.com/huzhiwei/archive/2012/03/14/2395956.html" target="_blank" rel="external">https://www.cnblogs.com/huzhiwei/archive/2012/03/14/2395956.html</a></p>
</li>
<li><p><strong>Autoconf</strong></p>
<p>用于生成shell脚本的工具，可自动配置源码包，以适应多种类Posix的系统，产生的配置脚本通常叫做configure。</p>
<p>Autoconf的目标是为每个用户提供可移植的配置。</p>
<p>解决的问题：可靠地发现系统特定的构建和运行时信息，为此，GNU项目开发了一套集成实用程序来完成Autoconf的工作：GNU构建系统，其最重要的组建是Autoconf、Automake和Libtool。</p>
<p><strong>Autoscan</strong></p>
<p>Autoconf软件包里面的autoscan工具可以扫描工作目录，生成一个configure.ac的模板文件configure.scan。configure.ac文件是autoconf的输入文件，经过autoconf处理，展开里面的m4宏，输出configure脚本</p>
<blockquote>
<p>注：m4（<a href="https://segmentfault.com/a/1190000004104696）" target="_blank" rel="external">https://segmentfault.com/a/1190000004104696）</a></p>
<p>m4 是一种宏处理器，它扫描用户输入的文本并将其输出，期间如果遇到宏就将其展开后输出。宏有两种，一种是内建的，另一种是用户定义的，它们能接受任意数量的参数。<strong>除了做展开宏的工作之外，m4 内建的宏能够加载文件，执行 Shell 命令，做整数运算，操纵文本，形成递归等等。m4 可用作编译器的前端，或者单纯作为宏处理器来用</strong>。</p>
<p>所有的 Unix 系统都会提供 m4 宏处理器，因为它是 POSIX 标准的一部分。</p>
<p>m4 从文本输入流中获取文本并将其发送到文本输出流，期间如果遇到宏就将其展开后发送到文本输出流。</p>
</blockquote>
<p>样例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">xujiawei@XJW-MacBook-Pro ~/Desktop/testgo $ mkdir Test</div><div class="line">xujiawei@XJW-MacBook-Pro ~/Desktop/testgo $ cd Test</div><div class="line">xujiawei@XJW-MacBook-Pro ~/Desktop/testgo/Test $ mkdir src</div><div class="line">xujiawei@XJW-MacBook-Pro ~/Desktop/testgo/Test $ cd src</div><div class="line">xujiawei@XJW-MacBook-Pro ~/Desktop/testgo/Test/src $ vim main.c</div><div class="line">xujiawei@XJW-MacBook-Pro ~/Desktop/testgo/Test/src $ autoscan</div><div class="line">xujiawei@XJW-MacBook-Pro ~/Desktop/testgo/Test/src $ ls</div><div class="line">autoscan.log   configure.scan main.c</div><div class="line"></div><div class="line"> xujiawei@XJW-MacBook-Pro ~/Desktop/testgo/Test/src $ cat configure.scan</div><div class="line"><span class="meta">#</span>                                               -*- Autoconf -*-</div><div class="line"><span class="meta">#</span> Process this file with autoconf to produce a configure script.</div><div class="line"></div><div class="line">AC_PREREQ([2.69])#声明本文件要求的autoconf版本</div><div class="line">AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])</div><div class="line"><span class="meta">#</span>AC_INIT宏用来定义软件的名称和版本信息，本例写成：AC_INIT(Hello,1.0)，BUG-REPORT-ADDRESS参数是可选项，一般写成作者的邮件地址。</div><div class="line"></div><div class="line">AC_CONFIG_SRCDIR([main.c])</div><div class="line"><span class="meta">#</span>AC_CONFIG_SRCDIR宏通过侦测所指定的源码文件是否存在，来确定源码目录的有效性，可以选择源码目录中的任何一个文件作为代表，宏参数中使用[]，是为了表明其中的字符串是一个整体。</div><div class="line"></div><div class="line">AC_CONFIG_HEADERS([config.h])</div><div class="line"><span class="meta">#</span>AC_CONFIG_HEADERS宏用于生成config.h文件，里面存放configure脚本侦测到的信息如果程序需要使用其中的定义，就在源码中加入#include &lt;config.h&gt;</div><div class="line"><span class="meta">#</span>其他的的一些宏是标准的侦测过程，可以保留不动。</div><div class="line"></div><div class="line"><span class="meta">#</span> Checks for programs.</div><div class="line">AC_PROG_CC</div><div class="line"></div><div class="line"><span class="meta">#</span> Checks for libraries.</div><div class="line"></div><div class="line"><span class="meta">#</span> Checks for header files.</div><div class="line"></div><div class="line"><span class="meta">#</span> Checks for typedefs, structures, and compiler characteristics.</div><div class="line"></div><div class="line"><span class="meta">#</span> Checks for library functions.</div><div class="line"></div><div class="line">AC_OUTPUT</div></pre></td></tr></table></figure>
<p>#号开始的行是注释，其他都是m4宏命令。</p>
<p>configure.ac文件要求AC_INIT宏必须 放在开头位置，AC_OUTPUT放在文件末，中间用来检测编译环境中的各种宏没有特别的先后次序要求，由宏之间相互关系决定。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/16/2019-05-16-fragmented-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/2019-05-16-fragmented-knowledge/" itemprop="url">2019-05-16-日常零碎知识点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-16T14:08:54+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日常零碎/" itemprop="url" rel="index">
                    <span itemprop="name">日常零碎</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年5月16日所写，未经允许不得转载。</p>
<ol>
<li><p><strong>Linux网络编程</strong></p>
<ul>
<li><p>socketaddr</p>
</li>
<li><p>socktaddr_in</p>
</li>
<li><p>socketaddr_un</p>
<blockquote>
<p>UNIX Domain Socket，虽然网络socket也可以用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。Unix Domain Socket也提供面向流和面向数据包两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。X Window服务器和GUI程序之间就是通过UNIX Domain Socket通讯的。</p>
<p>使用UNIX Domain Socket的过程和网络socket十分相似，也要先调用socket()创建一个socket文件描述符，address family指定为AF_UNIX，type可以选择SOCK_DGRAM或SOCK_STREAM，protocol参数仍然指定为0即可。</p>
<p>UNIX Domain Socket与网络socket编程最明显的不同在于地址格式不同，用结构体sockaddr_un表示，网络编程的socket地址是IP地址加端口 号，而UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存 在，则bind()错误返回。</p>
</blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/ace_fei/article/details/6412069" target="_blank" rel="external">https://blog.csdn.net/ace_fei/article/details/6412069</a></li>
<li><a href="https://www.cnblogs.com/lddhbu/archive/2013/02/17/2914728.html" target="_blank" rel="external">https://www.cnblogs.com/lddhbu/archive/2013/02/17/2914728.html</a></li>
</ol>
</li>
</ul>
</li>
<li><p><strong>Linux C中内联汇编 Inline Assembly</strong></p>
<blockquote>
<p>基本语法规则：</p>
<p>内联汇编（或称嵌入汇编）的基本语法模板比较简单，如下所示：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">asm</span> [ <span class="keyword">volatile</span> ] (  </div><div class="line">         assembler <span class="keyword">template</span></div><div class="line">         [ : output operands ]                <span class="comment">/* optional */</span></div><div class="line">         [ : input operands  ]                <span class="comment">/* optional */</span></div><div class="line">         [ : <span class="built_in">list</span> of clobbered registers ]    <span class="comment">/* optional */</span></div><div class="line">         );</div></pre></td></tr></table></figure>
<blockquote>
<p>由5部分组成：</p>
<p>1）关键字asm和volatile</p>
<p>​      asm为gcc关键字，表示接下来要嵌入汇编代码。为避免keyword asm与程序中其它部分产生命名冲突，gcc还支持__asm__关键字，与asm的作用等价。</p>
<p>​      volatile为可选关键字，表示不需要gcc对下面的汇编代码做任何优化。同样出于避免命名冲突的原因，__volatile__也是gcc支持的与volatile等效的关键字。</p>
<p> 2）assembler template</p>
<pre><code>这部分即我们要嵌入的汇编命令，由于我们是在C语言中内联汇编代码，故需用双引号&quot;&quot;将命令括起来，以便gcc以字符串形式将这些命令传给汇编器AS。例如可以写成这样：&quot;movl %eax, %ebx&quot;
</code></pre><p>​       有时候，汇编命令可能有多个，则通常分多行写，每行的命令都用双引号括起来，命令后紧跟”\n\t”之类的分隔符（当然，也可以只用1对双引号将多行命令括起来，从语法来说，两种写法均有效，我们可自行决定用哪种格式来写）。示例代码如下所示：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__asm__ __volatile__ ( <span class="string">"movl %eax, %ebx\n\t"</span></div><div class="line">                       <span class="string">"movl %ecx, 2(%edx, %ebx, $8)\n\t"</span></div><div class="line">                       <span class="string">"movb %ah, (%ebx)"</span></div><div class="line">                     );</div></pre></td></tr></table></figure>
<blockquote>
<p>​        还有时候，根据程序上下文，嵌入的汇编代码中可能会出现一些类似于魔数（<a href="http://en.wikipedia.org/wiki/Magic_number_(programming" target="_blank" rel="external">Magic Number</a>) ）的操作数，比如下面的代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a=<span class="number">10</span>, b;</div><div class="line"><span class="keyword">asm</span> (<span class="string">"movl %1, %%eax;   /* NOTICE: 下面会说明此处用%%eax引用寄存器eax的原因</span></div><div class="line"><span class="string">      movl %%eax, %0;"</span></div><div class="line">      :<span class="string">"=r"</span>(b)          <span class="comment">/* output 该字段的语法后面会详细说明，此处可无视，下同 */</span></div><div class="line">      :<span class="string">"r"</span>(a)           <span class="comment">/* input   */</span></div><div class="line">      :<span class="string">"%eax"</span>           <span class="comment">/* clobbered register */</span></div><div class="line">     );</div></pre></td></tr></table></figure>
<blockquote>
<p>​        movl指令的操作数（operand）中，出现了%1、%0。在内联汇编中，操作数通常用数字来引用，具体的编号规则为：若命令共涉及n个操作数，则第1个输出操作数（the first output operand）被编号为0，第2个output operand编号为1，依次类推，最后1个输入操作数（the last input operand）则被编号为n-1。<br>​       具体到上面的示例代码中，根据上下文，涉及到2个操作数变量a、b，这段汇编代码的作用是将a的值赋给b，可见，a是input operand，而b是output operand，那么根据操作数的引用规则，不难推出，a应该用%1来引用，b应该用%0来引用。</p>
<p>​        还需要说明的是：当命令中同时出现寄存器和以%num来引用的操作数时，会以%%reg来引用寄存器（如上例中的%%eax），以便帮助gcc来区分寄存器和由C语言提供的操作数。  </p>
<p>3）output operands</p>
<pre><code>该字段为可选项，用以指明输出操作数，典型的格式为：
` : &quot;=a&quot; (out_var)`
其中，&quot;=a&quot;指定output operand的应遵守的约束（constraint），out_var为存放指令结果的变量，通常是个C语言变量。本例中，“=”是output operand字段特有的约束，表示该操作数是只写的（write-only）；“a”表示先将命令执行结果输出至%eax，然后再由寄存器%eax更新位于内存中的out_var。关于常用的约束规则，本文后面会给出说明。
若输出有多个，则典型格式示例如下：
</code></pre></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">asm</span> (<span class="string">"cpuid"</span></div><div class="line">      : <span class="string">"=a"</span> (out_var1), <span class="string">"=b"</span> (out_var2), <span class="string">"=c"</span> (out_var3)</div><div class="line">      : <span class="string">"a"</span> (op)</div><div class="line">     );</div></pre></td></tr></table></figure>
<pre><code>&gt;可见，我们可以为每个output operand指定其约束。
&gt;
&gt;4）input operands
&gt;      该字段为可选项，用以指明输入操作数，其典型格式为：
&gt;      `: &quot;constraints&quot; (in_var)`
&gt;       其中，constraints可以是gcc支持的各种约束方式，in_var通常为C语言提供的输入变量。
&gt;       与output operands类似，当有多个input时，典型格式为：
&gt;       `: &quot;constraints1&quot; (in_var1), &quot;constraints2&quot; (in_var2), &quot;constraints3&quot; (in_var3), …`
&gt;       当然，input operands + output operands的总数通常是有限制的，考虑到每种指令集体系结构对其涉及到的指令支持的最多操作数通常也有限制，此处的操作数限制也不难理解。此处具体的上限为max(10, max_in_instruction)，其中max_in_instruction为ISA中拥有最多操作数的那条指令包含的操作数数目。
&gt;       需要明确的是，在指明input operands的情况下，即使指令不会产生output operands，其:也需要给出。例如asm (&quot;sidt %0\n&quot; : :&quot;m&quot;(loc)); 该指令即使没有具体的output operands也要将:写全，因为有后面跟着: input operands字段。
&gt;
&gt;
&gt;
&gt;5）list of clobbered registers 
&gt;       该字段为可选项，用于列出指令中涉及到的且没出现在output operands字段及input operands字段的那些寄存器。若寄存器被列入clobber-list，则等于是告诉gcc，这些寄存器可能会被内联汇编命令改写。因此，执行内联汇编的过程中，这些寄存器就不会被gcc分配给其它进程或命令使用。
</code></pre><p>参考资料：</p>
<p><a href="https://blog.csdn.net/slvher/article/details/8864996" target="_blank" rel="external">https://blog.csdn.net/slvher/article/details/8864996</a></p>
</li>
<li><p><strong><a href="https://en.wikipedia.org/wiki/Magic_number_(programming" target="_blank" rel="external">魔数 Magic Number</a>)</strong></p>
<blockquote>
<p>In computer programming, the term <strong>magic number</strong> has multiple meanings. It could refer to one or more of the following:</p>
<ul>
<li>Unique values with unexplained meaning or multiple occurrences which could (preferably) be replaced with named constants</li>
<li>A constant numerical or text value used to identify a <a href="https://en.wikipedia.org/wiki/File_format" target="_blank" rel="external">file format</a> or protocol; for files, see <a href="https://en.wikipedia.org/wiki/List_of_file_signatures" target="_blank" rel="external">List of file signatures</a></li>
<li>Distinctive unique values that are unlikely to be mistaken for other meanings (e.g., <a href="https://en.wikipedia.org/wiki/Globally_Unique_Identifier" target="_blank" rel="external">Globally Unique Identifiers</a>)</li>
<li>Variable values used to accumulate values of register (e.g. <a href="https://en.wikipedia.org/wiki/Variable_(computer_science" target="_blank" rel="external">variable</a>)). It can be changed at any point in time.</li>
</ul>
</blockquote>
</li>
<li><p><strong>常用非易失内存编程指令</strong></p>
<ul>
<li><p><strong><a href="https://www.felixcloutier.com/x86/clflush" target="_blank" rel="external">clflush（Cache Line Flush，缓存行刷回）</a></strong></p>
<p>在处理器缓存层次结构（数据与指令）的所有级别中，使包含源操作数指定的线性地址的缓存线失效。失效会在整个缓存一致性域中传播。如果缓存层次结构中任何级别的缓存线与内存不一致（污损），则在使之失效之前将它写入内存。源操作数是字节内存位置。</p>
</li>
<li><p><strong><a href="https://hjlebbink.github.io/x86doc/html/CLFLUSHOPT.html" target="_blank" rel="external">CLFLUSHOPT（Optimized CLFLUSH，优化的缓存行刷回）</a></strong></p>
<p>作用与 CLFLUSH 相似，但其之间的指令级并行度更高，比如在访问不同 CacheLine 时，CLFLUHOPT 可以乱序执行。</p>
</li>
<li><p><strong>CLWB（Cache Line Write Back，缓存行写回）</strong></p>
<p>作用与 CLFLUSHOPT 相似，但在将缓存行中的数据写回之后，该缓存行仍将呈现为未被修改过的状态；支持现状</p>
</li>
<li><p><strong>NT STORES（Non­Temporal stores）</strong></p>
<p>NT STORES 是一系列用于存储不同字长数据的指令，其包括 <a href="https://github.com/HJLebbink/asm-dude/wiki/MOVNTDQ" target="_blank" rel="external">MOVNTDQ</a>等。NT Stores 指令在传输数据时能够绕过缓存，而直接将数据写入主存。</p>
</li>
<li><p><strong>FENCE</strong></p>
<p>FENCE 指令，也称内存屏障（Memory Barrier），起着约束其前后访存指令之间相对顺序的作用。其包括 LFENCE（约束 Load 指令）, MFENCE（约束 L/S 指令）, SFENCE（约束 Store 指令）。</p>
</li>
</ul>
<p>参考资料：</p>
<ol>
<li><a href="https://blog.csdn.net/maokelong95/article/details/81362837" target="_blank" rel="external">https://blog.csdn.net/maokelong95/article/details/81362837</a></li>
</ol>
</li>
<li><p><strong><a href="https://blog.csdn.net/qq_21125183/article/details/80590934" target="_blank" rel="external">计算机缓存Cache以及Cache Line</a></strong></p>
<p>计算机存储器，典型访问时间，典型容量：</p>
<ul>
<li>寄存器：1ns，几十～几百B</li>
<li>一级Cache：5～10ns，几十～几百KB</li>
<li>二级Cache：40～60ns，几百KB～几MB</li>
<li>内存：100～150ns，几百MB～几GB</li>
<li>硬盘：3～15ms，几百GB～几TB</li>
</ul>
<p>Cache：高速缓冲存储器，为了更好的利用局部性原理，减少CPU访问主存的次数。</p>
<p>Cache分成多个组，每个组分成多个行，line size是cache的基本单位，从主存向cache迁移数据都是按照line size为单位替换的。比如line size是32Byte，那么迁移必须一次迁移32Byte到cache。同个cache的line size总是相同的。</p>
<p>8路相连，8-way set associative，每个组有8个行。</p>
<p>主存中的地址和cache的映射关系：拿到一个地址，首先是映射到一个组里面去。cache总大小32KB，8路组相连（每组有8个line），每个line的大小line size为64Byte。一共有32K/8/64=64个组。对于32位的内存地址，每个line有2^6=64Byte，所以[0，5]区分line中的那个字节，一个64个组，我们取内存地址中间6位来hash查找地址属于哪个组。即内存地址的[6,11]位来确定属于64组的哪一个组。组确定了以后，[12,31]的内存地址与组中8个line挨个对比，如果[12,31]位与某个line一致，并且这个line位有效，那么缓存命中。</p>
<p>cache分成三类：</p>
<ul>
<li>直接映射高速缓存（direct-mapped），每个组只有一个line，选中组之后不需要和组中的每个line比对，因为只有一个line。</li>
<li>组相连高速缓存（set-associative），S个组，每个组E个line</li>
<li>全相连高速缓存（fully-associative），只有一个组，不用hash来确定组，直接挨个比对高位地址，来确定是否命中，这种方式不适合大的缓存。</li>
</ul>
<p>内存地址：  假设内存容量为M，内存地址为m位：那么寻址范围为000…00~FFF…F(m位)</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/liloke/201111/201111200431313054.png" alt=""></p>
<p>cache的逻辑结构：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/liloke/201111/201111200431344883.png" alt=""></p>
</li>
</ol>
<p>将此图与上图做对比，可以得出各参数如下：</p>
<p>B = 2^b</p>
<p>S = 2^s</p>
<p>现在来解释一下各个参数的意义：</p>
<p>一个cache被分为S个组，每个组有E个cacheline，而一个cacheline中，有B个存储单元，现代处理器中，这个存储单元一般是以字节(通常8个位)为单位的，也是最小的寻址单元。因此，在一个内存地址中，中间的s位决定了该单元被映射到哪一组，而最低的b位决定了该单元在cacheline中的偏移量。valid通常是一位，代表该cacheline是否是有效的(当该cacheline不存在内存映射时，当然是无效的)。tag就是内存地址的高t位，因为可能会有多个内存地址映射到同一个cacheline中，所以该位是用来校验该cacheline是否是CPU要访问的内存单元。</p>
<p>当tag和valid校验成功是，我们称为cache命中，这时只要将cache中的单元取出，放入CPU寄存器中即可。</p>
<p>当tag或valid校验失败的时候，就说明要访问的内存单元(也可能是连续的一些单元，如int占4个字节，double占8个字节)并不在cache中，这时就需要去内存中取了，这就是cache不命中的情况(cache miss)。当不命中的情况发生时，系统就会从内存中取得该单元，将其装入cache中，与此同时也放入CPU寄存器中，等待下一步处理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/Book-list-2019/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/Book-list-2019/" itemprop="url">2019年书单</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T11:06:36+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/书单/" itemprop="url" rel="index">
                    <span itemprop="name">书单</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h3><ol>
<li>高性能计算的问题解决之道——Linux态势感知方法、实用工具及实践技巧<ul>
<li>状态：阅读中</li>
<li>英文书名：<em>Problem-solving in High Performance Computing——A Situational Awareness Approach with Linux</em></li>
<li>作者：Igor Ljubuncic，曾任Intel工程计算部门的操作系统架构师，为全球高性能Linux计算环境提供解决方案；曾任Rackspace云计算中心的熟悉工程师；目前是一名自由作家和商业顾问</li>
<li>译：张文力</li>
<li>出版社：机械工业出版社</li>
<li><a href="">笔记链接</a></li>
</ul>
</li>
<li><p>Docker容器与容器云（第二版）</p>
<ul>
<li>状态：阅读中</li>
<li>作者：浙江大学SEL实验室</li>
<li>出版社：人民邮电出版社</li>
</ul>
</li>
<li><p>深度探索C++对象模型</p>
<ul>
<li>状态：阅读中</li>
<li>作者：Stanley B. Lippman</li>
<li>译：侯捷</li>
<li>出版社：电子工业出版社</li>
</ul>
</li>
</ol>
<h3 id="非技术类"><a href="#非技术类" class="headerlink" title="非技术类"></a>非技术类</h3><ol>
<li>人性的弱点<ul>
<li>状态：阅读中</li>
<li>作者：戴尔·卡耐基(Dale Carnegie),1888-1955</li>
<li>译：陶朦</li>
<li>出版社：天津人民出版社</li>
</ul>
</li>
<li>平衡的智慧——家庭、信仰和工作的优先次序原则<ul>
<li>状态：已读完</li>
<li>作者：帕特·基辛格(Pat Gelsinger)著，英特尔首席技术官</li>
<li>译：高路杜霞</li>
<li>出版社：中国商业出版社</li>
</ul>
</li>
<li>富爸爸穷爸爸<ul>
<li>状态：阅读中</li>
<li>作者：罗伯特·清崎（英文名：Robert Toru Kiyosaki），莱希特</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/Problem-solving-In-High-Performance-Computing-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/Problem-solving-In-High-Performance-Computing-notes/" itemprop="url">高性能计算的问题解决之道-笔记-更新中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T10:55:07+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书/计算机/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年5月9日所写，未经允许不得转载。</p>
<h3 id="关于书"><a href="#关于书" class="headerlink" title="关于书"></a>关于书</h3><ul>
<li><p>中文书名：《高性能计算的问题解决之道——Linux态势感知方法、实用工具及实践技巧》</p>
</li>
<li><p>英文书名：<em>Problem-solving in High Performance Computing——A Situational Awareness Approach with Linux</em></p>
</li>
<li>作者：Igor Ljubuncic，曾任Intel工程计算部门的操作系统架构师，为全球高性能Linux计算环境提供解决方案；曾任Rackspace云计算中心的熟悉工程师；目前是一名自由作家和商业顾问</li>
<li>出版社：机械工业出版社</li>
<li>简介/关键词：<ul>
<li>高性能计算、大规模系统、故障停机</li>
<li>整体态势感知方法：数学模型、最佳实践、监控配置</li>
<li>在数据中心应该如何解决问题，方法论</li>
<li>解决问题和研究的基本方法，常见陷阱</li>
<li>常见应用程序和工具，建立起报告的症状与软硬件资源的实际行为之间的联系</li>
<li>分析、刻画(profile)应用程序，以及分析内核本身</li>
<li>内核崩溃分析和内核调试器的使用，kdump</li>
<li>建立稳健有效的监测环境的考虑因素、方法、工具</li>
<li>版本控制、配置管理方面</li>
</ul>
</li>
</ul>
<h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><h4 id="在一个数据中心如何动手解决问题"><a href="#在一个数据中心如何动手解决问题" class="headerlink" title="在一个数据中心如何动手解决问题"></a>在一个数据中心如何动手解决问题</h4><ol>
<li><p>MTTF(Mean Time to Failure)：系统平均无故障时间</p>
</li>
<li><p>问题的识别：健康的怀疑态度、挑战惯例；探寻工具没有看到的问题；仔细留意现象。</p>
</li>
<li><p>问题的分类：</p>
<ul>
<li>真正的问题：与监控工具关联，预先分析过。</li>
<li>误报的问题：由系统管理链的前述环节所引起的误报，包括人为和机器原因。</li>
<li>虚假的问题：只对环境有间接影响的实际问题，但如果无人值守可能有显著影响。</li>
</ul>
</li>
<li><p>使解决问题成为一门学科，而不是一个不稳定的随机的努力。</p>
<p>面对问题，优先从简单熟悉的部分开始，不要上来做最坏的假设。过多的知识可能会导致误区。</p>
</li>
<li><p>事件通常有一个最大响应时间。服务级别协议SLA(service-level agreement)决定支持团队应该以多快的速度提供问题的解决方案。</p>
</li>
<li><p>停机规模、问题严重性、业务需求通常趋于零变化。</p>
<p>从不能忽视的问题开始，以正确的分类跟进。要确保琐碎的可预测的问题转化为自动化(快速、熟悉、高度可见、便于管理过程中的理解)，集中智慧和技能去处理其余那些反反复复看似怪异的案例。</p>
</li>
<li><p>问题的再现</p>
<ul>
<li><p>隔离问题：实际绘制一张环境图示，用确定的、程式化的方式去捕获问题</p>
</li>
<li><p>偶发性问题需要特殊处理</p>
<p>形成正反馈环路：减少未知因素的数目→显著地限制可能的空间→减少那些可能会出现的问题的发生→允许投入适量的精力去定义有用的、有意义的监控规则和阈值。</p>
</li>
</ul>
</li>
<li><p>学会根据情况暂停，重新设定研究，重新来过，放手，求教于别人or彻底去尝试别的问题，然后再回到这个问题。</p>
</li>
<li><p>Linux内核在发生kernel panic时会打印oops信息，把目前的寄存器状态、堆栈内容，以及完整的call trace都显示出来。然后用objdump反汇编工具找出出错的地方。</p>
</li>
<li><p>透明大页面：THP, Transparent Huge Pages</p>
</li>
<li><p>分析情况时，严格控制环境改变，减少环境的熵，如果改变，确保你知道预期结果是什么。</p>
</li>
<li><p>挑战</p>
<ul>
<li>业务环境中的制约因素</li>
<li>需要关注核心问题，而不是容易看到的那些</li>
<li>人会倾向于关注熟悉的和已知的问题</li>
<li>监控工具会向易于量化的参数产生偏差</li>
<li>对于大多数系统而言，大部分指标不能告诉你内部机制</li>
</ul>
</li>
</ol>
<h4 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h4><ol>
<li><p>工作流程：识别问题，隔离问题，因果关系，改变环境</p>
</li>
<li><p>隔离问题：第一步是迁移问题，从生产环境迁移到一个隔离的测试配置。重新运行获得结果所需要的最小集。</p>
</li>
<li><p>监控在大多数情况下是反应性的，充其量它会确认你所察觉到的正常状态的变化，但并不知道为什么它已经改变。避免假设，逻辑流程中需要嵌入事实和数字。</p>
</li>
<li><p>辨别是程序错误还是特性。</p>
</li>
<li><p>建立明确的基准</p>
<p>能够将现有的性能和系统运行状态与旧有的基线作比较是一个非常重要的能力，这将有助于保持你对环境的认识和控制。</p>
</li>
<li><p>必需指标：性能和行为</p>
</li>
<li><p>一次一个变量</p>
</li>
<li><p>线性复杂度的问题：研究、记录、建立数学公式映射问题和解决方案</p>
<p>非线性问题：理解导致它们表现的触发器</p>
</li>
</ol>
<h4 id="获取系统信息工具"><a href="#获取系统信息工具" class="headerlink" title="获取系统信息工具"></a>获取系统信息工具</h4><ol>
<li><p><code>uptime</code> 命令：收集和报告系统负载情况、系统运行了多长时间以及当前登陆的用户数。</p>
<p>系统负载是系统执行的计算工作量的度量，输出中从右到左依次是最后1分钟、5分钟、15分钟的平均值。</p>
<ul>
<li>完全空闲的系统的负载数量为0.00.</li>
<li>使用或等待CPU的每个进程将负载数量递增1，负载量为1.00转换为单个CPU内核的完全利用。</li>
<li>高负载值不一定转化为实际工作负载。相反，它们表示等待CPU的进程的平均数以及处于不间断睡眠状态(D状态，产生D状态的原因出现uninterruptible sleep状态的进程一般是因为在等待IO，例如磁盘IO、网络IO等。)的进程数。</li>
</ul>
</li>
<li><p><code>top</code>命令：提供正在运行系统的动态实时视图，默认情况下每3s刷新一次。</p>
<ul>
<li><p><code>Tasks</code>字段列出系统上的任务总数(进程)、处于睡眠状态的个数、已被主动停止或正在追踪的进程、僵尸进程。</p>
</li>
<li><p><code>CPU(s)</code>：</p>
<ul>
<li>在用户空间中完成的计算标记为%us</li>
<li>系统调用活动的百分比列在%sy下</li>
<li>nice进程(即具有修改的调度优先级的进程)的比例显示在%ni下</li>
<li>I/O活动(包括磁盘和网络)都反映在%wa中，CPU等待时间是存储和网络吞吐量的指示，即使CPU计算可能很低，也可能直接影响主机的负载和响应能力。</li>
<li>硬件和软件中断以%hi和%si标记</li>
<li>%st是指虚拟机管理程序从虚拟机中窃取的时间，因此它只与虚拟化环境相关。</li>
</ul>
<p>根据经验，非常高的%sy值通常表示内核空间中的问题。例如，可能存在显著的内存抖动，驱动程序可能会行为时常，或者其中一个组件可能存在硬件问题。</p>
<p>非常高百分比的nice进程也意味着存在问题，因为可能由于用户偏好的优先级导致资源争用。</p>
<p>如果遇到%wa值超过10%，则通常表示与性能相关的问题，这可能导致远程文件系统响应缓慢、网络拥塞、大量写入请求或交换引起的本地磁盘活动，以及类似的问题。</p>
</li>
<li><p><code>Mem</code>和<code>Swap</code>：当前内存子系统的使用情况</p>
<ul>
<li>free：虚拟内存中的空闲内存</li>
<li>buffers：用于内存块设备的I/O缓冲区页面</li>
<li>cached：页面缓存，包含需要写入磁盘的脏页面和最近读取请求中使用的页面。虽然缓存大小可能非常大，但是如果正在运行的程序请求额外的内存，它将会收缩。因此处于所有实际目的，用户可将缓存的内存视为空闲内存。</li>
</ul>
<p>释放所有缓存的操作可能需要一些时间才能完成，因为系统忙于将更改提交到磁盘。</p>
<p><code>echo 3&gt; /proc/sys/vm/drop_caches</code></p>
<p>强调缓存机制的另一种方法是下载、编译和运行memhog程序，这个工具使用在命令行中指定大量的内存，然后释放它，<code>./memhog 2048M</code></p>
<p>top命令从/proc树收集信息，<code>cat /proc/meminfo</code></p>
</li>
<li><p>top锁定进程的默认显示包含其他有用的信息，包括任务运行的用户名、优先级、nice值、请求的内存分配、实际使用情况、共享内存、进程状态、CPU百分比、总可用物理内存的百分比、CPU时间和简短的命令行。在交互模式下工作时，可以用<code>-f</code>来更改字段。</p>
</li>
<li><p>几个有用的快捷方式</p>
<ul>
<li><code>-b</code>，在批处理模式下运行top</li>
<li><code>-d</code>，更改刷新延迟(默认是3s)</li>
<li><code>-u</code>，只显示匹配给定的UID或用户名的进程</li>
<li><code>-p</code>，监控最多20个进程、以逗号分隔的一个列表</li>
<li><code>-r</code>，以匹配的PID重调进程的优先级。正的值将降低进程优先级，某些负值只能由根进程使用，标准用户不能重调哪些属于其他用户的进程。</li>
<li><code>-k</code>，以匹配的PID杀死进程。默认情况下，使用SIGTERM</li>
<li><code>-q</code>，退出</li>
</ul>
</li>
<li><p>区域命令，影响信息的显示方式</p>
<ul>
<li><code>t</code>，将根据任务状态显示进程</li>
<li><code>m</code>，将根据内存和交换使用情况以自顶向下的方式显示它们</li>
<li><code>1</code>，将切换CPU信息以单行显示所有内核，或单独显示</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ps</code>命令：</p>
<p>接收几个符号系统中的选项，包括BSD、UNIX和GNU，分别以无前缀、以单个破折号作为前缀、以两个破折号作为前缀来区分。</p>
<p>显示系统上的每个进程<code>ps -ef</code></p>
<p>BSD语法：<code>ps aux</code></p>
<p>一些选项：</p>
<ul>
<li><code>-e|-A</code>：显示所有进程</li>
<li><code>-u|--user</code>：只显示属于列举UID的任务</li>
<li><code>-p|--pid</code>：通过其标识符(PID)选择特定的进程</li>
<li><code>-ppid</code>：通过父进程选择</li>
<li><code>-o</code>：用户指定的格式，以空格或逗号分隔值。</li>
</ul>
<p>一些UNIX语法的列名含义：</p>
<ul>
<li><code>TID</code>：线程ID，也称为轻量级进程(LWP)</li>
<li><code>Rtprio</code>：实时优先级</li>
<li><code>NI</code>：静态优先级</li>
<li><code>PRI</code>：动态优先级</li>
<li><code>PSR</code>：任务当前分配的处理器号</li>
<li><code>WCHAN</code>：进程正在等待的最后一个内核函数(等待通道)。当调试进程似乎被卡住或停滞的时候，可能有用。</li>
</ul>
<p>BSD语法的列名含义：</p>
<ul>
<li><code>VSZ</code>：虚拟内存大小</li>
<li><code>RSS</code>：驻留集大小</li>
<li><code>STAT</code>：为每个显示的PID展示多字符的进程状态，”s”是指部门主管，”N”用于优先级较低的进程，”l”表示进程是多线程的。</li>
<li><code>START</code>：指令启动的时间，只有过去一年中启动的进程才显示年份信息</li>
<li><code>COMMAND</code>：进程命令行，直到打印缓冲区的最大宽度，通常是标准输出。内核线程记为方括号，它们的内存和CPU使用率将为0.</li>
</ul>
</li>
</ol>
<h4 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h4><ol>
<li>日志的默认位置在<code>/var/log</code>下，标准系统日志通常是<code>/var/log/messages</code>或<code>/var/log/syslog</code></li>
<li>研究流程应该是证据驱动的。</li>
<li>一般来说，你可能不想更改服务器上的日志记录策略。但是你可以更改服务将其信息报告给系统日志的方式。使用NFS作为示例，如果正在排查似乎与网络存储相关的问题，那么可以暂时提升NFS服务或客户端的调试级别，收集额外信息，然后再将值还原到其原始状态。例如：<code>echo 32767 &gt;/proc/sys/sunrpc/nfs_debug</code>。在/proc下工作并立即对系统行为进行更改，是用来尝试隔离问题的一种非常有用的方法，也是可以提高性能和稳定性的测试场景。</li>
<li><code>/var/log/kernellog</code>，该日志文件包含重新启动后内核打印的消息，与dmesg命令提供的数据相当，还可以获得时间戳，这在关联问题时可以用到。</li>
<li>系统在启动顺序中提供的数据以及之前启动的数据：<code>boot.msg</code>，<code>boot.omsg</code></li>
<li>其他有用的日志：cron、cups（Common UNIX Printing System，通用Unix打印系统）、audits（The Linux Audit Subsystem is a system to Collect information regarding events occurring on the system(s)<br>Kernel events (syscall events)）、mail、samba。</li>
</ol>
<p>更新中。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/RDMA-2-Communication-Operations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/07/RDMA-2-Communication-Operations/" itemprop="url">RDMA-2-通信操作相关概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-07T13:55:37+08:00">
                2019-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/RDMA/" itemprop="url" rel="index">
                    <span itemprop="name">RDMA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年5月7日所写，未经允许不得转载。</p>
<h3 id="RDMA-Communication-Operations"><a href="#RDMA-Communication-Operations" class="headerlink" title="RDMA Communication Operations"></a>RDMA Communication Operations</h3><ol>
<li><p><strong>Send(发送)/Send With Immdiate(带立即数据发送)</strong></p>
<p>Send操作允许发送数据到一个远程QP的receive queue中。Receiver必须已经提前post一个receiver buffer来接受数据。Sender无法控制数据会放到远程主机的什么地方。</p>
<p>带立即数据发送：通过线路发送消息和4字节的带外数据。立即值作为接受通知的一部分展现给receiver，但是不包含在data buffer中。</p>
</li>
<li><p><strong>Receive</strong></p>
<p>接手主机被通知一个data buffer已经被接收了，可能带有一个inline immediate value。</p>
</li>
<li><p><strong>Read</strong></p>
<p>caller指定远程虚拟地址和拷贝到本地的内存地址。在执行RDMA操作之前，远程主机必须提供适当的访问它内存的permission。一旦设置了这些permissions，RDMA read操作在进行时就不会通知远程主机。对于RDMA read和write，远程端不会意识到这些操作已经完成(除了permissions和resources的准备阶段)。</p>
</li>
<li><p><strong>Write/Write With Immdiate</strong></p>
<p>write操作进行时不会通知远程主机。</p>
<p>带立即数据的write操作，会通知远程主机immediate value。</p>
</li>
<li><p><strong>Atomic Fetch and Add/ Atomic Compare and Swap</strong></p>
<p>这些是RDMA操作的扩展。</p>
<p>Atomic fetch and add操作原子进行往一个特定虚拟地址上增加的指定的值。</p>
<p>Atomic compare and swap操作原子比较一个特定虚拟地址的值，如果相等，那么改成一个指定的值。</p>
</li>
</ol>
<h3 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h3><p>建立一个QP的时候可以选择不同的传输模式。</p>
<p>这个API不支持RD。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">UD</th>
<th style="text-align:center">UC</th>
<th style="text-align:center">RC</th>
<th style="text-align:center">RD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Send(with immediate)</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">Receive</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">RDMA Write(with immediate)</td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">RDMA read</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">Atomic: Fetch and Add/Cmp and Swap</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">Max message size</td>
<td style="text-align:center">MTU</td>
<td style="text-align:center">1GB</td>
<td style="text-align:center">1GB</td>
<td style="text-align:center">1GB</td>
</tr>
</tbody>
</table>
<ol>
<li><p><strong>Reliable Connection(RC)</strong></p>
<ul>
<li><p>一个QP只和一个QP关联。</p>
</li>
<li><p>可靠传输、有序。</p>
</li>
<li><p>一个RC连接类似TCP连接。</p>
</li>
</ul>
</li>
<li><p><strong>Unreliable Connection(UC)</strong></p>
<ul>
<li><p>一个QP只和一个QP关联。</p>
</li>
<li><p>连接不可靠，可能会丢包。</p>
</li>
<li><p>错误的消息不会retry，错误处理需要有上层协议提供。</p>
</li>
</ul>
</li>
<li><p><strong>Unreliable Datagram(UD)</strong></p>
<ul>
<li><p>一个QP可能从其他QP接收或者向另其他QP发送单包消息。</p>
</li>
<li><p>不保证有序和送达。</p>
</li>
<li><p>receiver可能会丢弃包。</p>
</li>
<li>支持多播(一对多)。</li>
<li>一个UD连接类似于一个UDP连接。</li>
</ul>
</li>
</ol>
<h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><ol>
<li><p><strong>Send Request(SR)</strong></p>
<p>一个SR定义了发送多少数据、从哪里发、发送方式、发到哪里。</p>
<p>实现接口：<code>struct ib_send_wr</code></p>
</li>
<li><p><strong>Receive Request(RR)</strong></p>
<p>一个RR定义了buffers，即非RDMA操作数据将要接收到哪里。如果没有定义buffer并且一个发送端试图进行一个send操作或者一个RDMA write with immediate，那么一个Receive Not Ready(RNR) error将会被发送。</p>
<p>实现接口：<code>struct ibv_recv_wr</code></p>
</li>
<li><p><strong>Completion Queue</strong></p>
<p>一个完成队列是一个对象，包含已经提交给Work Queues（WQ）中的完成了的work requests。每个完成的意思是一个特定的WR结束了(既可能是成功完成的WR，也可能是没有成功完成的WR)。</p>
<p>一个CQ是一种机制，通知应用关于结束的Work Requests的信息(状态、操作码、大小、来源)。</p>
<p>CQs有n个Completion Queue Entries(CQE)，当CQ被创建的时候，指定CQE的数量。</p>
<p>当一个CQE被poll的时候，它就会从CQ中删除。</p>
<p>CQ是CQE的FIFO队列。</p>
<p>CQ可以是发送队列、接收队列或者两者皆是。</p>
</li>
<li><p><strong>Memeory Registration</strong></p>
<p>内存注册是一种机制，允许一个应用程序使用虚拟地址向网卡把一系列虚拟上连续的内存位置或者一系列物理上连续的内存位置描述成一个虚拟上的连续缓冲区。</p>
<p>注册过程固定内存页(来防止页被换出，保持物理地址和虚拟地址的映射)。</p>
<p>在注册过程中，OS会检查被注册块的permissions。</p>
<p>注册过程将虚拟地址表写到网卡中。</p>
<p>当注册内存的时候，设定域的操作权限，有local write, remote read, remote write, atomic, bind。</p>
<p>每个MR(内存域)有一个remote和local key(r_key, l_key)。local keys是本地HCA用来访问本地内存，例如说在一个接受操作中。Remote keys是给远程HCA来允许远程进程在RDMA操作中对系统内存进行访问。</p>
<p>同一个内存buffer可以被注册多次(即便是用不同的访问权限)，并且每次注册都会生成不同的keys。</p>
<p>接口：<code>struct ibv_mr</code></p>
</li>
<li><p><strong>Memory Window</strong></p>
<p>一个MW允许应用程序对远程访问内存有灵活的控制。</p>
<p>适用于：</p>
<ul>
<li>应用程序希望动态授予/撤回远程访问一个注册的域的权利，避免像注册/撤销注册/重复注册那样的性能开销。</li>
<li>应用程序想要授予不同的远程agent不同的远程访问权限，或者在一个注册域的不同范围授予这些权限。</li>
</ul>
<p>将MW关联一个MR的操作叫做Binding。</p>
<p>不同的MW可以重叠同一个MR(用不同的访问允许事件)。</p>
</li>
<li><p><strong>Address Vector</strong></p>
<p>地址向量是一个对象，描述了本地节点和远程节点的路由。</p>
<p>在每个UC/RC QP的QP context中有一个地址向量。</p>
<p>在UD QP中，地址向量应该在每个提交发送请求中定义。</p>
<p>接口：<code>struct ibv_ah</code></p>
</li>
<li><p><strong>Global Routing Header(GRH)</strong></p>
<p>用在子网之间的路由，当使用RoCE时，GRH是用来子网内路由的，是一个mandatory，为了让应用程序支持IB和RoCE。</p>
<p>当UD QP使用全局路由时，receiver buffer的前40个字节包含了GRH，这个区域用来存储全局路由信息，这样一个地址向量就能够产生来响应接收的数据包。如果UD使用了GRH，那么RR是应该始终有额外40字节。</p>
<p>接口：<code>struct ibv_grh</code></p>
</li>
<li><p><strong>Protection Domain</strong></p>
<p>是一个对象，里面的组件只能在其中互相交互。包含的组件有AH、QP、MR、SRQ。</p>
<p>保护域用来关联QP和内存域与内存窗口，作为一种允许和控制网卡访问主机系统内存的方式。</p>
<p>保护域也用来关联UD QP和AH，作为一种控制UD 目的地访问的方式。</p>
<p>接口：<code>struct ibv_pd</code></p>
</li>
<li><p><strong>Asynchronous Events</strong></p>
<p>网卡可能会发送异步事想件来通知SW关于在系统中发生的事件。</p>
<p>有两种异步事件类型：</p>
<ul>
<li>affiliated events：发生在个人的对象(CQ、QP、SRQ)。这些事件将会发送给一个特定的进程。</li>
<li>unaffiliated events：发生在全局对象上(网卡，端口错误)。这些事件将会发送给所有的进程。</li>
</ul>
</li>
<li><p><strong>Scatter Gather</strong></p>
<p>使用scatter gather elements收集/分发数据，包括：</p>
<ul>
<li>Address：将要gather或者scatter的本地数据buffer的地址。</li>
<li>Size：要读或者写的数据的大小。</li>
<li>L_key：MR的local key，注册了这段buffer。</li>
</ul>
<p>接口：<code>struct ibv_sge</code></p>
</li>
<li><p><strong>Polling</strong></p>
<p>轮询CQ是否完成是为了获得一个已提交的WR的信息。</p>
<p>如果在一个WR中有一个带有bad status的完成，那么剩下的completions都是坏的，并且工作队列将会被移动到error state。</p>
<p>每个被轮询没有completion的WR都是outstanding的。</p>
<p>只有在一个WR有一个completion之后，发送/接收buffer可能会被使用/复用/释放。</p>
<p>completion status总是应该被检查。</p>
<p>当一个CQE被轮询，就会从CQ中移除.</p>
<p>轮询操作接口：<code>ibv_poll_cq</code></p>
</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>RDMA Aware Programming User Manual.pdf</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/wireshark-lua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/wireshark-lua/" itemprop="url">Wireshark配置Lua插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-28T14:35:44+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/wireshark/" itemprop="url" rel="index">
                    <span itemprop="name">wireshark</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/wireshark/lua/" itemprop="url" rel="index">
                    <span itemprop="name">lua</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年4月28日所写，未经允许不得转载。</p>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>在wireshark的安装目录下面编辑init.lua文件，例如mac上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /Applications/Wireshark.app/Contents/Resources/share/wireshark/init.lua</div></pre></td></tr></table></figure>
<p>最后一行如果没有加添加，否则修改：<code>dofile(&quot;YOURFILEPATH.lua&quot;)</code>，里面写绝对路径。</p>
<p>然后重启wireshark。</p>
<p>注：DATA_DIR表示全局配置路径，USER_DIR表示用户配置路径。可以通过菜单<code>About Wireshark</code>-&gt;<code>Folders</code>查看路径。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://wiki.wireshark.org/Lua/" target="_blank" rel="external">https://wiki.wireshark.org/Lua/</a></p>
<p><a href="https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.html" target="_blank" rel="external">https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/19/RDMA-concepts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/19/RDMA-concepts/" itemprop="url">RDMA-1-基础术语</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-19T21:15:16+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/RDMA/" itemprop="url" rel="index">
                    <span itemprop="name">RDMA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年4月19日所写，未经允许不得转载。</p>
<h3 id="RDMA相关术语"><a href="#RDMA相关术语" class="headerlink" title="RDMA相关术语"></a>RDMA相关术语</h3><ol>
<li>Access Layer：用于访问互连结构（VPI，InfiniBand，以太网，FCoE）的低层操作系统基础设施。 它包括支持上层网络协议、中间件和管理代理所需的所有基本传输服务。</li>
<li>AH (Address Handle，地址句柄)：一个对象，UD QP中用于描述到远程端的路径。</li>
<li>CA (Channel Adapter，通道适配器)：终止一个Infiniband链路的设备，执行传输层的功能。</li>
<li>CI (Channel Interface，通道接口)：通过组合网络适配器，相关固件和设备驱动程序软件实现向动词消费者呈现通道。</li>
<li>CM (Communication Manager)：负责建立、维护释放RC、UC QP服务类型的通信。Service ID Resolution Protocol允许UD服务的用户放置QP来支持他们想要的服务。</li>
<li>Compare &amp; Swap：指示远程QP读取一个64位的值，将它和提供的比较值比较，如果相等，使用QP中的交换值替代。</li>
<li>CQ(Completion Queue)：一个先进先出的完成队列，包括CQE。</li>
<li>CQE(Completion Queue Entry)：CQ中的一个条目，描述了完成的WR的信息，例如状态、大小等。</li>
<li>DMA(Direct Memory Access)：允许硬件直接获取、放置内存中的数据，绕过CPU。</li>
<li>Fetch &amp; Add：指示远程的QP读取一个64位的值并加上QP中的数据值之后替代。</li>
<li>GUID(Globally Unique IDentifier)：64位的数唯一标识一台设备或者一个子网的一个组件。</li>
<li>GID(Global IDentifier)：一个128位的书用来表示一个网络适配器的端口、一个路由器的端口或者一个多播组。</li>
<li>GRH(Global Routing Header)：一个包头用来发送数据包跨过一个子网边界，也用来发送多播消息。</li>
<li>Join operation：一个IB端口要收到多播数据包必须通过发送一个请求给SA显式加入一个多播组。</li>
<li>lkey：一旦MR注册完会收到一个lkey被本地WR用来识别内存域和它相关的权限。</li>
<li>LID(Local IDentifier)：子网管理器分配一个一个16位的地址给端节点，每个LID在它的子网内都是唯一的。</li>
<li>LLE(Low Latency Ethernet)：允许以太网上的IB传输的CEE上的RDMA服务。</li>
<li>NA(Network Adapter)：终止链路的设备，执行传输层功能。</li>
<li>MGID(Multicast Group ID)：IB多播组，用MGID标识，由SM管理。SM把一个MLID和每个MGID联系起来，显式的设置互连的IB交换机，确保加入到多播组的所有端口都收到了数据包。</li>
<li>MR(Memory Region)：已经注册了访问的权限的一段连续内存buffer，这些buffer需要注册来让网络适配器使用它们。在注册过程中，L_Key和R_Key会被创建并和已经创建的内存域关联。</li>
<li>MTU(Maximum Transfer Unit)：一个端口可以发送或接受的一个数据包payload的最大大小(不包括headers)。</li>
<li>MW(Memory Window)：分配的资源——在绑定到现有内存注册中的指定区域后启用远程访问。每个内存窗口都一个关联的窗口句柄，一系列访问权限和当前的R_Key。</li>
<li>Outstanding Work Request：那些已经提交到工作队列但是没有poll通知完成的。</li>
<li>pkey(Partition key)：pkey标识了端口属于的partition。一个pkey约类似于以太网的VLAN ID。用来指向一个在端口的partition key表里的一个条目。每个端口都被子网管理器（SM）指派了至少一个pkey。</li>
<li>PD(Protection Domain)：独立WQ的pair(发送队列和接收队列)包在一起放在一个对象里，目的是传输数据一个网络中节点之间的数据。Posts用来初始化发送和接收数据。有三种QP类型：<strong>UD Unreliable Datagram</strong>，<strong>UC Ureliable Connection</strong>，<strong>RC Reliable Connection</strong>。</li>
<li>RC(Reliable Connection)：一个QP传输服务类型，基于一个面向连接的协议。一个QP(Queue pair)和另外一个单个QP。这些消息将以可靠的方式发送(包括正确性和信息顺序)。</li>
<li>RDMA_CM(Remote Direct Memeory Access Communication Manager)：API，用来建立可靠、面向连接的和不可靠的数据报的数据传输。它提供了一个RDMA传输中性接口，用于建立连接。API基于sockets，但是适用于基于QP的语义：通信必须通过一个特定的RDMA设备，数据传输基于消息。</li>
<li>Requestor：连接中初始化一次数据传输的一方(通过提交一个发送请求)。</li>
<li>Responder：连接中响应从请求方来的命令（可能包括一个写到响应方的内存或从响应方内存读取的请求，以及最后请求响应者接受消息的的命令）的那一方。</li>
<li>rkey：MR一注册就会收到的数字，用来对即将到来的RDMA操作加以限制。</li>
<li>RNR(Receiver Not Ready)：一个RC QP中的流，双方连接已经有了但是接受方还没有RR。</li>
<li>RQ(Receive Queue)：工作队列维护着用户提交的RR。</li>
<li>RR(Receive Request)：提交给一个RQ的WR，描述了使用一个发送操作码的即将到来的数据将会写到哪里。同时一个带有immediate的RDMA Write将会消耗一个RR。</li>
<li>RTR(Ready To Receive)：一种QP的状态，一个RR可以被post或者被处理。</li>
<li>RTS(Ready To Send)：一种QP的状态，一个SR可以被post或者被处理。</li>
<li>SA(Subnet Administrator)：用来查询或者处理子网管理数据的接口。</li>
<li>SGE(Scatter/Gather Elements)：S/G元素数组，S/G元素存在于一个WR ，根据使用的操作码或者从多个缓存中收集数据，把它们作为一个单独的流发送，或者把一个单独流分解成到几个缓存中。</li>
<li>SM(Subnet Manager)：配置和管理子网的实体；发现网络拓扑；制定LID；决定路由方案设置路由表；一个master SM和几个可能的slaves(Standby mode)；管理交换机路由表，从而建立通过结构的路径。</li>
<li>SQ(Send Queue)：一个工作队列，维护了用户提交的SR。</li>
<li>SR(Send Request)：发送给一个SQ的WR，描述了多少数据将会被传输、它的方向和方式(操作码)。</li>
<li>SRQ(Shared Receive Queue)：一个含有WQE的队列，里面有即将到来的来自于任何与它相关联的RC/UC/UD的QP。SRQ可以关联超过一个QP。</li>
<li>TCA(Target Channel Adapter)：一个通道适配器不需要支持verbs，通常在I/O设备中使用。</li>
<li>UC(Unreliable Connection)：一种QP传输服务类型，基于面向连接的协议，QP会关联另一个单独的QP。这种QP不执行可靠协议，消息可能会丢失。</li>
<li>UD(Unreliable Datagram)：一种QP传输服务类型，其中消息可以是一个数据包长度，每个UD QP可以从子网中的另一个UD QP发送/接收消息。消息可能会丢失，订单无法保证。UD QP是唯一支持多播消息的类型。 UD数据包的消息大小限制为路径MTU。</li>
<li>Verbs：一个网络适配器功能的抽象描述。任何应用程序可以使用这些verbs，创建/管理需要对象来使用RDMA进行数据传输。</li>
<li>VPI（Virtual Protocol Interface）：允许用户改变二层协议的端口。</li>
<li>WQ(Work Queue)：发送队列或者消息队列的一种。</li>
<li>WQE：发音为”wookie”，一个工作队列里的一个元素。</li>
<li>WR(Work Request)：用户提交到工作队列的一个请求。</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="http://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf" target="_blank" rel="external">RDMA aware programming user manual.pdf</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/CplusPrimer-object-and-class-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/CplusPrimer-object-and-class-note/" itemprop="url">C++ Primer Plus 第十章对象和类笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T15:51:18+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ Primer Plus</em> 第十章对象和类笔记整理。—— Jiawei Xu 2019年3月7日</p>
<p><strong>关键字：</strong>类、结构、定点表示法、构造函数、析构函数、const成员函数、this指针、类作用域</p>
<ol>
<li><p>数据项通常放在私有部分，组成类接口的成员函数放在公有部分。——数据隐藏</p>
</li>
<li><p>不必在类声明中使用关键字private，因为这是类对象的默认访问控制。</p>
</li>
<li><p><strong>类class和结构struct</strong>之间的唯一区别：结构的默认访问类型是public，而类为private。C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象（常被称为普通老式数据（POD, Plain Old Data）结构）。</p>
</li>
<li><p>cout使用定点表示法：<code>std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield;</code></p>
<p>显示三位小数：<code>std::cout.precision(3);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::streamsize prec = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">3</span>); <span class="comment">//保存</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.precision(prec); 	<span class="comment">//reset</span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::ios_base::fmtflags orig = <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed); <span class="comment">//保存原始flags</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(org, <span class="built_in">std</span>::ios_base::floatfield); <span class="comment">//floatfield包括定点表示法标记和科学表示法标记</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>类的构造函数</strong></p>
<ul>
<li><p>构造函数的原型和函数头虽然没有返回值，但没有被声明为void类型。原型位于类声明的<strong>公有</strong>部分。</p>
</li>
<li><p>构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，<strong>参数名不能与类成员相同</strong>。一种常见的做法是在数据成员名中使用 m<em> 前缀，另一种是，在成员名中使用后缀 </em>。</p>
</li>
<li><p><strong>两种使用构造函数来创建并初始化对象的方式：</strong></p>
<ol>
<li><p>显式地调用构造函数，如：</p>
<p><code>Stock food = Stock (&quot;World Cabbage&quot;, 250, 1.25);</code></p>
<p><strong>C++标准允许编译器使用两种方法来执行：一种是和下面的2一样，另一种方式是允许调用构造函数来创建一个临时变量，然后将该临时对象复制到food中，并丢弃它。</strong></p>
</li>
<li><p>隐式地调用构造函数，如：</p>
<p><code>Stock garment(&quot;Furry Mason&quot;, 50, 2.5);</code></p>
<p>这种格式更紧凑，等价于显式调用<code>Stock garment = Stock(&quot;Furry Mason&quot;, 50, 2.5);</code></p>
</li>
<li><p>每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数，将构造函数和new一起使用的方法：</p>
<p><code>Stock *pstock = new Stock(&quot;Electroshock Games&quot;, 18, 19.0);</code>创建一个Stock对象，将其初始化为参数提供的值，并将对象的地址赋给pstock指针。</p>
</li>
</ol>
</li>
<li><p>无法适用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。</p>
</li>
<li><p><strong>默认构造函数</strong></p>
<ol>
<li><p>用于下面这种声明的构造函数：<code>Stock fluffy_the_cat;</code></p>
<p>如果没有提供任何构造函数，则C++将自动提供默认构造函数。对于Stock类来说，默认构造函数可能如下：<code>Stock::Stock() {}</code></p>
</li>
<li><p>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。原因：想禁止创建未初始化的对象。</p>
</li>
<li><p>定义默认构造函数的方式有两种，不要同时使用，用户定义的默认构造函数通常给所有成员提供隐式初始化。在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数：</p>
<ul>
<li><p>1）给已有构造函数的所有参数提供默认值：</p>
<p><code>Stock(const string &amp; co = &quot;Error&quot;, int n = 0, double pr = 0.0&quot;);</code></p>
</li>
<li><p>2）通过函数重载来定义另一个构造函数——一个没有参数的构造函数：</p>
<p><code>Stock();</code></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>构造函数的作用：</p>
<ol>
<li>用于初始化新对象</li>
<li>通过让构造程序创建一个新的、临时的对象，然后将其内容复制给一个对象来实现。随后程序调用析构函数，已删除该临时对象。有些编译器可能要过一段时间才删除临时变量，因此析构函数的调用将延迟。</li>
</ol>
</li>
<li><p>如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。<strong>通常这种方式的效率更高。</strong></p>
<p><code>Stock stock2 = Stock(&quot;Buffo Objects&quot;, 2, 2.0);</code></p>
<p><code>stock1 = Stock(&quot;Nifty Foods&quot;, 10, 50.0);</code></p>
<p>第一句是初始化，它创建有指定值的的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值，像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象。</p>
</li>
</ul>
</li>
<li><p><strong>类的析构函数</strong></p>
<ul>
<li>析构函数也可以没有返回值和声明类型。析构函数没有参数。原型必须类似于：<code>~Stock();</code>。</li>
<li>通常不应正在代码中显示地调用析构函数。如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用。如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中 ，当使用delete来释放内存时，其析构函数将自动被调用。最后，程序可以创建临时对象来完成该特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。</li>
</ul>
</li>
<li><p>在C++11中，可以将列表初始化语法用于类。只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起。</p>
</li>
<li><p><strong>const成员函数</strong></p>
<p>应尽可能将const引用和指针用作函数形参一样，只要类方法不修改调用函数，就应将其声明为const。</p>
<p><code>const Stock &amp; Stock::topval(const Stock &amp; s) const</code> 三个const的意义：1：返回类型为const的引用 2：将函数参数声明为const引用或指向const的指针保证调用对象不被修改。该函数不会修改被显示地访问的对象；3：该函数不会修改被隐式地访问的对象。</p>
</li>
<li><p><strong>this指针</strong></p>
<p>每个成员函数（包括构造函数和析构函数）都有一个this指针，this指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式 *this 。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。</p>
<p>*this是对象本身，this是对象的地址。</p>
</li>
<li><p>对象数组</p>
<p>初始化对象数组的方案是，首先使用默认构造函数创建数字元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中，因此，要创建类对象数组，则这个类必须有默认构造函数。例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">4</span>;</div><div class="line">Stock stocks[STKS] = &#123;</div><div class="line">    Stock(<span class="string">"NanoSmart"</span>, <span class="number">12.5</span>, <span class="number">20</span>),</div><div class="line">    Stock();</div><div class="line">    Stock(<span class="string">"Monolithic Obelisks"</span>, <span class="number">130</span>, <span class="number">3.25</span>),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>类作用域</strong></p>
<p>使符号常量的作用域为类很有用。常量对于所有对象来说都是相同的，因此可创建一个由所有对象共享的常量。有两种方式：</p>
<ul>
<li><p>1）在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整个型常量提供作用域为整个类的符号名称。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    	<span class="keyword">enum</span> &#123;Months = <span class="number">12</span>&#125;;</div><div class="line">    	<span class="keyword">double</span> costs[Months];</div><div class="line">    	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用枚举只是为了创建符号常量，并不打算创建枚举类型的变量，因此不需要提供枚举名。</p>
<p>用这种方式枚举不会创建类数据成员，也就是说，所有对象中都不包含枚举。</p>
</li>
<li><p>2）另一种在类中定义常量的方式——使用关键字static：例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</div><div class="line">    	<span class="keyword">double</span> costs[Months];</div><div class="line">    	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。因为，只有一个Months常量，被所有Bakery对象共享。C++98中，只能用这种技术声明值为整数或枚举的静态常量，而不能存储double常量。C++11没有这种限制。</p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/07/CplusPrimer-namespace-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/CplusPrimer-namespace-note/" itemprop="url">C++ Primer Plus 命名空间笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T15:20:34+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ Primer Plus</em> 名称空间 笔记整理。—— Jiawei Xu 2019年3月7日</p>
<p><strong>using声明</strong>使特定的标识符可用，<strong>using编译指令</strong>使整个名称空间可用。</p>
<p><strong>名称空间指导原则：</strong></p>
<ol>
<li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li>
<li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li>
<li>如果开发了一个函数库或类库，将其放在一个名称空间中。</li>
<li>不要在头文件中使用using编译指令。这样会掩盖要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理编译指令#include之后。</li>
<li>导入名称时，首选使用作用域解析运算符或using声明的方法。</li>
<li>对于using声明，首选将其作用域设置为局部而不是全局。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">icestrawberryxjw</p>
              <p class="site-description motion-element" itemprop="description">The most difficult thing is the decision to act, the rest is merely tenacity.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/icestrawberryxjw" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">icestrawberryxjw</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
