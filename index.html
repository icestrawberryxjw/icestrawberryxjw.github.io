<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:type" content="website">
<meta property="og:title" content="icestrawberryxjw">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="icestrawberryxjw">
<meta property="og:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="icestrawberryxjw">
<meta name="twitter:description" content="The most difficult thing is the decision to act, the rest is merely tenacity.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>icestrawberryxjw</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">icestrawberryxjw</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/RDMA-2-Communication-Operations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/07/RDMA-2-Communication-Operations/" itemprop="url">RDMA-2-通信操作相关概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-07T13:55:37+08:00">
                2019-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/RDMA/" itemprop="url" rel="index">
                    <span itemprop="name">RDMA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年5月7日所写，未经允许不得转载。</p>
<h3 id="RDMA-Communication-Operations"><a href="#RDMA-Communication-Operations" class="headerlink" title="RDMA Communication Operations"></a>RDMA Communication Operations</h3><ol>
<li><p><strong>Send(发送)/Send With Immdiate(带立即数据发送)</strong></p>
<p>Send操作允许发送数据到一个远程QP的receive queue中。Receiver必须已经提前post一个receiver buffer来接受数据。Sender无法控制数据会放到远程主机的什么地方。</p>
<p>带立即数据发送：通过线路发送消息和4字节的带外数据。立即值作为接受通知的一部分展现给receiver，但是不包含在data buffer中。</p>
</li>
<li><p><strong>Receive</strong></p>
<p>接手主机被通知一个data buffer已经被接收了，可能带有一个inline immediate value。</p>
</li>
<li><p><strong>Read</strong></p>
<p>caller指定远程虚拟地址和拷贝到本地的内存地址。在执行RDMA操作之前，远程主机必须提供适当的访问它内存的permission。一旦设置了这些permissions，RDMA read操作在进行时就不会通知远程主机。对于RDMA read和write，远程端不会意识到这些操作已经完成(除了permissions和resources的准备阶段)。</p>
</li>
<li><p><strong>Write/Write With Immdiate</strong></p>
<p>write操作进行时不会通知远程主机。</p>
<p>带立即数据的write操作，会通知远程主机immediate value。</p>
</li>
<li><p><strong>Atomic Fetch and Add/ Atomic Compare and Swap</strong></p>
<p>这些是RDMA操作的扩展。</p>
<p>Atomic fetch and add操作原子进行往一个特定虚拟地址上增加的指定的值。</p>
<p>Atomic compare and swap操作原子比较一个特定虚拟地址的值，如果相等，那么改成一个指定的值。</p>
</li>
</ol>
<h3 id="传输模式"><a href="#传输模式" class="headerlink" title="传输模式"></a>传输模式</h3><p>建立一个QP的时候可以选择不同的传输模式。</p>
<p>这个API不支持RD。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">UD</th>
<th style="text-align:center">UC</th>
<th style="text-align:center">RC</th>
<th style="text-align:center">RD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Send(with immediate)</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">Receive</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">RDMA Write(with immediate)</td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">RDMA read</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">Atomic: Fetch and Add/Cmp and Swap</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">Max message size</td>
<td style="text-align:center">MTU</td>
<td style="text-align:center">1GB</td>
<td style="text-align:center">1GB</td>
<td style="text-align:center">1GB</td>
</tr>
</tbody>
</table>
<ol>
<li><p><strong>Reliable Connection(RC)</strong></p>
<ul>
<li><p>一个QP只和一个QP关联。</p>
</li>
<li><p>可靠传输、有序。</p>
</li>
<li><p>一个RC连接类似TCP连接。</p>
</li>
</ul>
</li>
<li><p><strong>Unreliable Connection(UC)</strong></p>
<ul>
<li><p>一个QP只和一个QP关联。</p>
</li>
<li><p>连接不可靠，可能会丢包。</p>
</li>
<li><p>错误的消息不会retry，错误处理需要有上层协议提供。</p>
</li>
</ul>
</li>
<li><p><strong>Unreliable Datagram(UD)</strong></p>
<ul>
<li><p>一个QP可能从其他QP接收或者向另其他QP发送单包消息。</p>
</li>
<li><p>不保证有序和送达。</p>
</li>
<li><p>receiver可能会丢弃包。</p>
</li>
<li>支持多播(一对多)。</li>
<li>一个UD连接类似于一个UDP连接。</li>
</ul>
</li>
</ol>
<h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><ol>
<li><p><strong>Send Request(SR)</strong></p>
<p>一个SR定义了发送多少数据、从哪里发、发送方式、发到哪里。</p>
<p>实现接口：<code>struct ib_send_wr</code></p>
</li>
<li><p><strong>Receive Request(RR)</strong></p>
<p>一个RR定义了buffers，即非RDMA操作数据将要接收到哪里。如果没有定义buffer并且一个发送端试图进行一个send操作或者一个RDMA write with immediate，那么一个Receive Not Ready(RNR) error将会被发送。</p>
<p>实现接口：<code>struct ibv_recv_wr</code></p>
</li>
<li><p><strong>Completion Queue</strong></p>
<p>一个完成队列是一个对象，包含已经提交给Work Queues（WQ）中的完成了的work requests。每个完成的意思是一个特定的WR结束了(既可能是成功完成的WR，也可能是没有成功完成的WR)。</p>
<p>一个CQ是一种机制，通知应用关于结束的Work Requests的信息(状态、操作码、大小、来源)。</p>
<p>CQs有n个Completion Queue Entries(CQE)，当CQ被创建的时候，指定CQE的数量。</p>
<p>当一个CQE被poll的时候，它就会从CQ中删除。</p>
<p>CQ是CQE的FIFO队列。</p>
<p>CQ可以是发送队列、接收队列或者两者皆是。</p>
</li>
<li><p><strong>Memeory Registration</strong></p>
<p>内存注册是一种机制，允许一个应用程序使用虚拟地址向网卡把一系列虚拟上连续的内存位置或者一系列物理上连续的内存位置描述成一个虚拟上的连续缓存。</p>
<p>注册过程固定内存页(来防止页被换出，保持物理地址和虚拟地址的映射)。</p>
<p>在注册过程中，OS会检查被注册块的permissions。</p>
<p>注册过程将虚拟地址表写到网卡中。</p>
<p>当注册内存的时候，设定域的操作权限，有local write, remote read, remote write, atomic, bind。</p>
<p>每个MR(内存域)有一个remote和local key(r_key, l_key)。local keys是本地HCA用来访问本地内存，例如说在一个接受操作中。Remote keys是给远程HCA来允许远程进程在RDMA操作中对系统内存进行访问。</p>
<p>同一个内存缓存可以被注册多次(即便是用不同的访问权限)，并且每次注册都会生成不同的keys。</p>
<p>接口：<code>struct ibv_mr</code></p>
</li>
<li><p><strong>Memory Window</strong></p>
<p>一个MW允许应用程序对远程访问内存有灵活的控制。</p>
<p>适用于：</p>
<ul>
<li>应用程序希望动态授予/撤回远程访问一个注册的域的权利，避免像注册/撤销注册/重复注册那样的性能开销。</li>
<li>应用程序想要授予不同的远程agent不同的远程访问权限，或者在一个注册域的不同范围授予这些权限。</li>
</ul>
<p>将MW关联一个MR的操作叫做Binding。</p>
<p>不同的MW可以重叠同一个MR(用不同的访问允许事件)。</p>
</li>
<li><p><strong>Address Vector</strong></p>
<p>地址向量是一个对象，描述了本地节点和远程节点的路由。</p>
<p>在每个UC/RC QP的QP context中有一个地址向量。</p>
<p>在UD QP中，地址向量应该在每个提交发送请求中定义。</p>
<p>接口：<code>struct ibv_ah</code></p>
</li>
<li><p><strong>Global Routing Header(GRH)</strong></p>
<p>用在子网之间的路由，当使用RoCE时，GRH是用来子网内路由的，是一个mandatory，为了让应用程序支持IB和RoCE。</p>
<p>当UD QP使用全局路由时，receiver buffer的前40个字节包含了GRH，这个区域用来存储全局路由信息，这样一个地址向量就能够产生来响应接收的数据包。如果UD使用了GRH，那么RR是应该始终有额外40字节。</p>
<p>接口：<code>struct ibv_grh</code></p>
</li>
<li><p><strong>Protection Domain</strong></p>
<p>是一个对象，里面的组件只能在其中互相交互。包含的组件有AH、QP、MR、SRQ。</p>
<p>保护域用来关联QP和内存域与内存窗口，作为一种允许和控制网卡访问主机系统内存的方式。</p>
<p>保护域也用来关联UD QP和AH，作为一种控制UD 目的地访问的方式。</p>
<p>接口：<code>struct ibv_pd</code></p>
</li>
<li><p><strong>Asynchronous Events</strong></p>
<p>网卡可能会发送异步事想件来通知SW关于在系统中发生的事件。</p>
<p>有两种异步事件类型：</p>
<ul>
<li>affiliated events：发生在个人的对象(CQ、QP、SRQ)。这些事件将会发送给一个特定的进程。</li>
<li>unaffiliated events：发生在全局对象上(网卡，端口错误)。这些事件将会发送给所有的进程。</li>
</ul>
</li>
<li><p><strong>Scatter Gather</strong></p>
<p>使用scatter gather elements收集/分发数据，包括：</p>
<ul>
<li>Address：将要gather或者scatter的本地数据缓存的地址。</li>
<li>Size：要读或者写的数据的大小。</li>
<li>L_key：MR的local key，注册了这段buffer。</li>
</ul>
<p>接口：<code>struct ibv_sge</code></p>
</li>
<li><p><strong>Polling</strong></p>
<p>轮询CQ是否完成是为了获得一个已提交的WR的信息。</p>
<p>如果在一个WR中有一个带有bad status的完成，那么剩下的completions都是坏的，并且工作队列将会被移动到error state。</p>
<p>每个被轮询没有completion的WR都是outstanding的。</p>
<p>只有在一个WR有一个completion之后，发送/接收buffer可能会被使用/复用/释放。</p>
<p>completion status总是应该被检查。</p>
<p>当一个CQE被轮询，就会从CQ中移除.</p>
<p>轮询操作接口：<code>ibv_poll_cq</code></p>
</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>RDMA Aware Programming User Manual.pdf</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/28/wireshark-lua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/28/wireshark-lua/" itemprop="url">Wireshark配置Lua插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-28T14:35:44+08:00">
                2019-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/wireshark/" itemprop="url" rel="index">
                    <span itemprop="name">wireshark</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/wireshark/lua/" itemprop="url" rel="index">
                    <span itemprop="name">lua</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年4月28日所写，未经允许不得转载。</p>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>在wireshark的安装目录下面编辑init.lua文件，例如mac上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /Applications/Wireshark.app/Contents/Resources/share/wireshark/init.lua</div></pre></td></tr></table></figure>
<p>最后一行如果没有加添加，否则修改：<code>dofile(&quot;YOURFILEPATH.lua&quot;)</code>，里面写绝对路径。</p>
<p>然后重启wireshark。</p>
<p>注：DATA_DIR表示全局配置路径，USER_DIR表示用户配置路径。可以通过菜单<code>About Wireshark</code>-&gt;<code>Folders</code>查看路径。</p>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://wiki.wireshark.org/Lua/" target="_blank" rel="external">https://wiki.wireshark.org/Lua/</a></p>
<p><a href="https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.html" target="_blank" rel="external">https://www.wireshark.org/docs/wsdg_html_chunked/wsluarm.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/19/RDMA-concepts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/19/RDMA-concepts/" itemprop="url">RDMA-1-基础术语</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-19T21:15:16+08:00">
                2019-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/RDMA/" itemprop="url" rel="index">
                    <span itemprop="name">RDMA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年4月19日所写，未经允许不得转载。</p>
<h3 id="RDMA相关术语"><a href="#RDMA相关术语" class="headerlink" title="RDMA相关术语"></a>RDMA相关术语</h3><ol>
<li>Access Layer：用于访问互连结构（VPI，InfiniBand，以太网，FCoE）的低层操作系统基础设施。 它包括支持上层网络协议、中间件和管理代理所需的所有基本传输服务。</li>
<li>AH (Address Handle，地址句柄)：一个对象，UD QP中用于描述到远程端的路径。</li>
<li>CA (Channel Adapter，通道适配器)：终止一个Infiniband链路的设备，执行传输层的功能。</li>
<li>CI (Channel Interface，通道接口)：通过组合网络适配器，相关固件和设备驱动程序软件实现向动词消费者呈现通道。</li>
<li>CM (Communication Manager)：负责建立、维护释放RC、UC QP服务类型的通信。Service ID Resolution Protocol允许UD服务的用户放置QP来支持他们想要的服务。</li>
<li>Compare &amp; Swap：指示远程QP读取一个64位的值，将它和提供的比较值比较，如果相等，使用QP中的交换值替代。</li>
<li>CQ(Completion Queue)：一个先进先出的完成队列，包括CQE。</li>
<li>CQE(Completion Queue Entry)：CQ中的一个条目，描述了完成的WR的信息，例如状态、大小等。</li>
<li>DMA(Direct Memory Access)：允许硬件直接获取、放置内存中的数据，绕过CPU。</li>
<li>Fetch &amp; Add：指示远程的QP读取一个64位的值并加上QP中的数据值之后替代。</li>
<li>GUID(Globally Unique IDentifier)：64位的数唯一标识一台设备或者一个子网的一个组件。</li>
<li>GID(Global IDentifier)：一个128位的书用来表示一个网络适配器的端口、一个路由器的端口或者一个多播组。</li>
<li>GRH(Global Routing Header)：一个包头用来发送数据包跨过一个子网边界，也用来发送多播消息。</li>
<li>Join operation：一个IB端口要收到多播数据包必须通过发送一个请求给SA显式加入一个多播组。</li>
<li>lkey：一旦MR注册完会收到一个lkey被本地WR用来识别内存域和它相关的权限。</li>
<li>LID(Local IDentifier)：子网管理器分配一个一个16位的地址给端节点，每个LID在它的子网内都是唯一的。</li>
<li>LLE(Low Latency Ethernet)：允许以太网上的IB传输的CEE上的RDMA服务。</li>
<li>NA(Network Adapter)：终止链路的设备，执行传输层功能。</li>
<li>MGID(Multicast Group ID)：IB多播组，用MGID标识，由SM管理。SM把一个MLID和每个MGID联系起来，显式的设置互连的IB交换机，确保加入到多播组的所有端口都收到了数据包。</li>
<li>MR(Memory Region)：已经注册了访问的权限的一段连续内存buffer，这些buffer需要注册来让网络适配器使用它们。在注册过程中，L_Key和R_Key会被创建并和已经创建的内存域关联。</li>
<li>MTU(Maximum Transfer Unit)：一个端口可以发送或接受的一个数据包payload的最大大小(不包括headers)。</li>
<li>MW(Memory Window)：分配的资源——在绑定到现有内存注册中的指定区域后启用远程访问。每个内存窗口都一个关联的窗口句柄，一系列访问权限和当前的R_Key。</li>
<li>Outstanding Work Request：那些已经提交到工作队列但是没有poll通知完成的。</li>
<li>pkey(Partition key)：pkey标识了端口属于的partition。一个pkey约类似于以太网的VLAN ID。用来指向一个在端口的partition key表里的一个条目。每个端口都被子网管理器（SM）指派了至少一个pkey。</li>
<li>PD(Protection Domain)：独立WQ的pair(发送队列和接收队列)包在一起放在一个对象里，目的是传输数据一个网络中节点之间的数据。Posts用来初始化发送和接收数据。有三种QP类型：<strong>UD Unreliable Datagram</strong>，<strong>UC Ureliable Connection</strong>，<strong>RC Reliable Connection</strong>。</li>
<li>RC(Reliable Connection)：一个QP传输服务类型，基于一个面向连接的协议。一个QP(Queue pair)和另外一个单个QP。这些消息将以可靠的方式发送(包括正确性和信息顺序)。</li>
<li>RDMA_CM(Remote Direct Memeory Access Communication Manager)：API，用来建立可靠、面向连接的和不可靠的数据报的数据传输。它提供了一个RDMA传输中性接口，用于建立连接。API基于sockets，但是适用于基于QP的语义：通信必须通过一个特定的RDMA设备，数据传输基于消息。</li>
<li>Requestor：连接中初始化一次数据传输的一方(通过提交一个发送请求)。</li>
<li>Responder：连接中响应从请求方来的命令（可能包括一个写到响应方的内存或从响应方内存读取的请求，以及最后请求响应者接受消息的的命令）的那一方。</li>
<li>rkey：MR一注册就会收到的数字，用来对即将到来的RDMA操作加以限制。</li>
<li>RNR(Receiver Not Ready)：一个RC QP中的流，双方连接已经有了但是接受方还没有RR。</li>
<li>RQ(Receive Queue)：工作队列维护着用户提交的RR。</li>
<li>RR(Receive Request)：提交给一个RQ的WR，描述了使用一个发送操作码的即将到来的数据将会写到哪里。同时一个带有immediate的RDMA Write将会消耗一个RR。</li>
<li>RTR(Ready To Receive)：一种QP的状态，一个RR可以被post或者被处理。</li>
<li>RTS(Ready To Send)：一种QP的状态，一个SR可以被post或者被处理。</li>
<li>SA(Subnet Administrator)：用来查询或者处理子网管理数据的接口。</li>
<li>SGE(Scatter/Gather Elements)：S/G元素数组，S/G元素存在于一个WR ，根据使用的操作码或者从多个缓存中收集数据，把它们作为一个单独的流发送，或者把一个单独流分解成到几个缓存中。</li>
<li>SM(Subnet Manager)：配置和管理子网的实体；发现网络拓扑；制定LID；决定路由方案设置路由表；一个master SM和几个可能的slaves(Standby mode)；管理交换机路由表，从而建立通过结构的路径。</li>
<li>SQ(Send Queue)：一个工作队列，维护了用户提交的SR。</li>
<li>SR(Send Request)：发送给一个SQ的WR，描述了多少数据将会被传输、它的方向和方式(操作码)。</li>
<li>SRQ(Shared Receive Queue)：一个含有WQE的队列，里面有即将到来的来自于任何与它相关联的RC/UC/UD的QP。SRQ可以关联超过一个QP。</li>
<li>TCA(Target Channel Adapter)：一个通道适配器不需要支持verbs，通常在I/O设备中使用。</li>
<li>UC(Unreliable Connection)：一种QP传输服务类型，基于面向连接的协议，QP会关联另一个单独的QP。这种QP不执行可靠协议，消息可能会丢失。</li>
<li>UD(Unreliable Datagram)：一种QP传输服务类型，其中消息可以是一个数据包长度，每个UD QP可以从子网中的另一个UD QP发送/接收消息。消息可能会丢失，订单无法保证。UD QP是唯一支持多播消息的类型。 UD数据包的消息大小限制为路径MTU。</li>
<li>Verbs：一个网络适配器功能的抽象描述。任何应用程序可以使用这些verbs，创建/管理需要对象来使用RDMA进行数据传输。</li>
<li>VPI（Virtual Protocol Interface）：允许用户改变二层协议的端口。</li>
<li>WQ(Work Queue)：发送队列或者消息队列的一种。</li>
<li>WQE：发音为”wookie”，一个工作队列里的一个元素。</li>
<li>WR(Work Request)：用户提交到工作队列的一个请求。</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="http://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf" target="_blank" rel="external">RDMA aware programming user manual.pdf</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/CplusPrimer-object-and-class-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/CplusPrimer-object-and-class-note/" itemprop="url">C++ Primer Plus 第十章对象和类笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T15:51:18+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ Primer Plus</em> 第十章对象和类笔记整理。—— Jiawei Xu 2019年3月7日</p>
<p><strong>关键字：</strong>类、结构、定点表示法、构造函数、析构函数、const成员函数、this指针、类作用域</p>
<ol>
<li><p>数据项通常放在私有部分，组成类接口的成员函数放在公有部分。——数据隐藏</p>
</li>
<li><p>不必在类声明中使用关键字private，因为这是类对象的默认访问控制。</p>
</li>
<li><p><strong>类class和结构struct</strong>之间的唯一区别：结构的默认访问类型是public，而类为private。C++程序员通常使用类来实现类描述，而把结构限制为只表示纯粹的数据对象（常被称为普通老式数据（POD, Plain Old Data）结构）。</p>
</li>
<li><p>cout使用定点表示法：<code>std::cout.setf(std::ios_base::fixed, std::ios_base::floatfield;</code></p>
<p>显示三位小数：<code>std::cout.precision(3);</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::streamsize prec = <span class="built_in">std</span>::<span class="built_in">cout</span>.precision(<span class="number">3</span>); <span class="comment">//保存</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.precision(prec); 	<span class="comment">//reset</span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::ios_base::fmtflags orig = <span class="built_in">std</span>::<span class="built_in">cout</span>.setf(<span class="built_in">std</span>::ios_base::fixed); <span class="comment">//保存原始flags</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>.setf(org, <span class="built_in">std</span>::ios_base::floatfield); <span class="comment">//floatfield包括定点表示法标记和科学表示法标记</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>类的构造函数</strong></p>
<ul>
<li><p>构造函数的原型和函数头虽然没有返回值，但没有被声明为void类型。原型位于类声明的<strong>公有</strong>部分。</p>
</li>
<li><p>构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，<strong>参数名不能与类成员相同</strong>。一种常见的做法是在数据成员名中使用 m<em> 前缀，另一种是，在成员名中使用后缀 </em>。</p>
</li>
<li><p><strong>两种使用构造函数来创建并初始化对象的方式：</strong></p>
<ol>
<li><p>显式地调用构造函数，如：</p>
<p><code>Stock food = Stock (&quot;World Cabbage&quot;, 250, 1.25);</code></p>
<p><strong>C++标准允许编译器使用两种方法来执行：一种是和下面的2一样，另一种方式是允许调用构造函数来创建一个临时变量，然后将该临时对象复制到food中，并丢弃它。</strong></p>
</li>
<li><p>隐式地调用构造函数，如：</p>
<p><code>Stock garment(&quot;Furry Mason&quot;, 50, 2.5);</code></p>
<p>这种格式更紧凑，等价于显式调用<code>Stock garment = Stock(&quot;Furry Mason&quot;, 50, 2.5);</code></p>
</li>
<li><p>每次创建类对象（甚至使用new动态分配内存）时，C++都使用类构造函数，将构造函数和new一起使用的方法：</p>
<p><code>Stock *pstock = new Stock(&quot;Electroshock Games&quot;, 18, 19.0);</code>创建一个Stock对象，将其初始化为参数提供的值，并将对象的地址赋给pstock指针。</p>
</li>
</ol>
</li>
<li><p>无法适用对象来调用构造函数，因为在构造函数构造出对象之前，对象是不存在的。</p>
</li>
<li><p><strong>默认构造函数</strong></p>
<ol>
<li><p>用于下面这种声明的构造函数：<code>Stock fluffy_the_cat;</code></p>
<p>如果没有提供任何构造函数，则C++将自动提供默认构造函数。对于Stock类来说，默认构造函数可能如下：<code>Stock::Stock() {}</code></p>
</li>
<li><p>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。原因：想禁止创建未初始化的对象。</p>
</li>
<li><p>定义默认构造函数的方式有两种，不要同时使用，用户定义的默认构造函数通常给所有成员提供隐式初始化。在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数：</p>
<ul>
<li><p>1）给已有构造函数的所有参数提供默认值：</p>
<p><code>Stock(const string &amp; co = &quot;Error&quot;, int n = 0, double pr = 0.0&quot;);</code></p>
</li>
<li><p>2）通过函数重载来定义另一个构造函数——一个没有参数的构造函数：</p>
<p><code>Stock();</code></p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>构造函数的作用：</p>
<ol>
<li>用于初始化新对象</li>
<li>通过让构造程序创建一个新的、临时的对象，然后将其内容复制给一个对象来实现。随后程序调用析构函数，已删除该临时对象。有些编译器可能要过一段时间才删除临时变量，因此析构函数的调用将延迟。</li>
</ol>
</li>
<li><p>如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。<strong>通常这种方式的效率更高。</strong></p>
<p><code>Stock stock2 = Stock(&quot;Buffo Objects&quot;, 2, 2.0);</code></p>
<p><code>stock1 = Stock(&quot;Nifty Foods&quot;, 10, 50.0);</code></p>
<p>第一句是初始化，它创建有指定值的的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值，像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象。</p>
</li>
</ul>
</li>
<li><p><strong>类的析构函数</strong></p>
<ul>
<li>析构函数也可以没有返回值和声明类型。析构函数没有参数。原型必须类似于：<code>~Stock();</code>。</li>
<li>通常不应正在代码中显示地调用析构函数。如果创建的是静态存储类对象，则其析构函数将在程序结束时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用。如果对象是通过new创建的，则它将驻留在栈内存或自由存储区中 ，当使用delete来释放内存时，其析构函数将自动被调用。最后，程序可以创建临时对象来完成该特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。</li>
</ul>
</li>
<li><p>在C++11中，可以将列表初始化语法用于类。只要提供与某个构造函数的参数列表匹配的内容，并用大括号将它们括起。</p>
</li>
<li><p><strong>const成员函数</strong></p>
<p>应尽可能将const引用和指针用作函数形参一样，只要类方法不修改调用函数，就应将其声明为const。</p>
<p><code>const Stock &amp; Stock::topval(const Stock &amp; s) const</code> 三个const的意义：1：返回类型为const的引用 2：将函数参数声明为const引用或指向const的指针保证调用对象不被修改。该函数不会修改被显示地访问的对象；3：该函数不会修改被隐式地访问的对象。</p>
</li>
<li><p><strong>this指针</strong></p>
<p>每个成员函数（包括构造函数和析构函数）都有一个this指针，this指针指向调用对象。如果方法需要引用整个调用对象，则可以使用表达式 *this 。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。</p>
<p>*this是对象本身，this是对象的地址。</p>
</li>
<li><p>对象数组</p>
<p>初始化对象数组的方案是，首先使用默认构造函数创建数字元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中，因此，要创建类对象数组，则这个类必须有默认构造函数。例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">4</span>;</div><div class="line">Stock stocks[STKS] = &#123;</div><div class="line">    Stock(<span class="string">"NanoSmart"</span>, <span class="number">12.5</span>, <span class="number">20</span>),</div><div class="line">    Stock();</div><div class="line">    Stock(<span class="string">"Monolithic Obelisks"</span>, <span class="number">130</span>, <span class="number">3.25</span>),</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>类作用域</strong></p>
<p>使符号常量的作用域为类很有用。常量对于所有对象来说都是相同的，因此可创建一个由所有对象共享的常量。有两种方式：</p>
<ul>
<li><p>1）在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以用枚举为整个型常量提供作用域为整个类的符号名称。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    	<span class="keyword">enum</span> &#123;Months = <span class="number">12</span>&#125;;</div><div class="line">    	<span class="keyword">double</span> costs[Months];</div><div class="line">    	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用枚举只是为了创建符号常量，并不打算创建枚举类型的变量，因此不需要提供枚举名。</p>
<p>用这种方式枚举不会创建类数据成员，也就是说，所有对象中都不包含枚举。</p>
</li>
<li><p>2）另一种在类中定义常量的方式——使用关键字static：例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakery</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">    	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</div><div class="line">    	<span class="keyword">double</span> costs[Months];</div><div class="line">    	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将创建一个名为Months的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。因为，只有一个Months常量，被所有Bakery对象共享。C++98中，只能用这种技术声明值为整数或枚举的静态常量，而不能存储double常量。C++11没有这种限制。</p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/07/CplusPrimer-namespace-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/CplusPrimer-namespace-note/" itemprop="url">C++ Primer Plus 命名空间笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T15:20:34+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ Primer Plus</em> 名称空间 笔记整理。—— Jiawei Xu 2019年3月7日</p>
<p><strong>using声明</strong>使特定的标识符可用，<strong>using编译指令</strong>使整个名称空间可用。</p>
<p><strong>名称空间指导原则：</strong></p>
<ol>
<li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量。</li>
<li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量。</li>
<li>如果开发了一个函数库或类库，将其放在一个名称空间中。</li>
<li>不要在头文件中使用using编译指令。这样会掩盖要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令using，应将其放在所有预处理编译指令#include之后。</li>
<li>导入名称时，首选使用作用域解析运算符或using声明的方法。</li>
<li>对于using声明，首选将其作用域设置为局部而不是全局。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/ip-conf-file-inconsistency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/ip-conf-file-inconsistency/" itemprop="url">解决Centos网卡IP和配置文件不符的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T22:15:45+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月9日所写，未经允许不得转载。</p>
<p>昨天发现连不上自己的服务器了，以为是网卡没起来或者网线被别人重插了，后来看了一下发现网卡起来了，ip也配的是对的，再ifconfig下，发现居然网卡em1用的是网卡em2的配置文件。如图：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060901.png" alt="2018060901"></p>
<p>并且，修改em2的配置文件中的ip，em1会相应变化，推测em1和em2互用了对方的配置文件= =。</p>
<p>使用nmcli查看，确实如此：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060902.png" alt="2018060902"></p>
<p>在别的正常的服务器上，是这样的：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060903.png" alt="2018060903"></p>
<p><strong>验证了我的猜测，下面是解决方案：</strong></p>
<p>Red Hat Enterprise Linux 7 与 CentOS 7 中默认的网络服务由 NetworkManager 提供，这是动态控制及配置网络的守护进程，它用于保持当前网络设备及连接处于工作状态，同时也支持传统的 ifcfg 类型的配置文件。可以用<strong>命令行工具 nmcli</strong> 来控制 NetworkManager，相应的也有一个<strong>图形化的配置工具nmtui</strong>。</p>
<p>NetworkManager 可以用于以下类型的连接：Ethernet，VLANS，Bridges，Bonds，Teams，Wi-Fi，mobile boradband（如移动3G）以及 IP-over-InfiniBand。针对与这些网络类型，NetworkManager 可以配置他们的网络别名，IP 地址，静态路由，DNS，VPN连接以及很多其它的特殊参数。 </p>
<p><strong>一些Network Manager中的概念：</strong></p>
<ul>
<li>device叫网络接口，是物理设备</li>
<li>connection是连接，偏重于逻辑设置</li>
<li>多个connection可以应用到同一个device，但同一时间只能启用其中一个connection。这样的好处是针对一个网络接口，我们可以设置多个网络连接，比如静态IP和动态IP，再根据需要up相应的connection。</li>
</ul>
<p><strong>nmcli的具体用法可以参考manpage，下面是常用命令（单词可以不写全，比如connection写成con）：</strong></p>
<ol>
<li><p>nmcli modifiy命令修改网卡的具体配置，实际上编辑的是<code>/etc/sysconfig/network-scripts/ifcfg-*</code>文件。在不想使用该文件时，可以通过delete删除对应的连接：<code>nmcli connection delete ens3</code>。默认情况下通过nmcli add 或 modify的操作只是修改了配置文件，并不会立即生效，想要生效启用，需要通过“nmcli conn up 接口名” 来启用对应的配置。 </p>
</li>
<li><p><code>nmcli -p con up em1 ifname em1</code>修改设备连接的配置文件，<strong>只用这个来修改网卡使用的配置文件的话重启网卡之后就会无效！</strong>因为默认的网卡和配置文件之间的连接没有删除。</p>
</li>
<li><p><code>nmcli -p connection show &quot;em1&quot;</code> 显示em1连接配置集详情 </p>
</li>
<li><p><code>nmcli -p -m multiline -f all con show</code> 显示NetworkManager 连接配置集</p>
</li>
<li><p><code>nmcli -f name,autoconnect c s</code></p>
</li>
<li><p><code>nmcli connection show</code>查看当前的连接，terminal里未启用的是黄色，启用的是绿色。</p>
</li>
<li><p><code>nmcli connection show --active</code>仅查看活跃连接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# nmcli connection show --active</div><div class="line">名称    UUID                                  类型            设备   </div><div class="line">em2     c67732e2-be50-4589-ad40-4537da423795  802-3-ethernet  em1    </div><div class="line">virbr0  4c0b2e32-9e55-472f-8693-03fda6c95847  bridge          virbr0`</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="解决步骤："><a href="#解决步骤：" class="headerlink" title="解决步骤："></a><strong>解决步骤</strong>：</h3><p>一开始以为网卡的配置是单纯找对应网卡名称的配置文件，现在才知道是将网卡设备和逻辑接口连接起来，然后使用逻辑接口的配置文件。</p>
<p>首先使用<code>nmcli connection delete CONNECTION_NAME</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection delete em2     //把网卡em1和配置文件ifcfg-em2的连接断开</div></pre></td></tr></table></figure>
<p>下一步，把网卡em1和接口em1匹配起来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection add ifname em1 con-name em1 type ethernet //建立网卡em1和逻辑接口em1的连接</div></pre></td></tr></table></figure>
<p>然后，使用<code>nmcli connection show</code>就可以看到增加了一条连接信息，显示黄色说明还没有启动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nmcli connection delete be36eaf2011de-43ab-9ff6-58b32796a444 //删掉下图绿色下面一行的未启动的网卡em2和逻辑接口em1的连接</div><div class="line">nmcli connection add ifname em2 con-name em2 type ethernet //建立网卡em2和逻辑接口em2的连接</div></pre></td></tr></table></figure>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060904.jpg" alt="2018060904"></p>
<p>但是，因为刚刚建立网卡em1和逻辑接口em1的时候，网卡em2和逻辑接口em1的连接还没删除，所以在/etc/sysconfig/network-scripts里面会出现ifcfg-em1-1，把文件名改成ifcfg-em1，需要在里面配置好静态ip、网关等信息然后保存。</p>
<p>再次用<code>nmcli connection show</code>查看，发现网卡em1和逻辑接口em1连接了，网卡em2和逻辑接口em2连接了，原来的连接断开了。但是em1的连接没有启用（红色）。</p>
<p>用nmtui编辑连接后，ifcfg文件也会有相应的改动；手工修改ifcfg后，nmtui中也能看到。<br>但是，<strong>不论用nmtui还是直接修改ifcfg文件，想让新的配置生效，需要load连接配置文件并重新up连接。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nmcli con load /etc/sysconfig/network-scripts/ifcfg-em1</div><div class="line">nmcli con load /etc/sysconfig/network-scripts/ifcfg-em2</div><div class="line">nmcli con up em1</div></pre></td></tr></table></figure>
<p>再次用<code>nmcli connection show</code>查看，发现网卡em1和逻辑接口em1连接启用了（显示绿色）</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060905.jpg" alt="2018060905"></p>
<p>服务器重启之后，配置依然有效，至此解决。</p>
<p>参考资料：</p>
<ol>
<li><a href="https://www.cnblogs.com/panblack/p/Centos7-WhatsNew-02-networking.html" target="_blank" rel="external">https://www.cnblogs.com/panblack/p/Centos7-WhatsNew-02-networking.html</a></li>
<li>nmcli(1) Linux man page</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/promiscuous-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/promiscuous-mode/" itemprop="url">关于网卡的混杂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T22:13:00+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年6月9日所写，未经允许不得转载。</p>
<p>tcpdump的一个副作用就是可以让网卡进入混杂模式。每次tcpdump，都会在/var/log/messages里看到这样：</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060907.png" alt="2018060907"></p>
<p>实际上，网卡是否处于PROMISC模式，ifconfig（ip link show也是如此）并不是最直接的判断依据，换句话说就是ifconfig能看到PROMISC标记表示一定处于混杂模式，但处于混杂模式并不一定能看到PROMISC标记。内核判断网卡是否处于混杂模式是看<code>/sys/class/net/ifname/flags</code>的值，如果置位了0x100，则处于混杂模式。</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2018060906.png" alt="2018060906"></p>
<ul>
<li><strong>混杂模式的ifconfig和ip link show都按看不到的问题</strong></li>
</ul>
<p><a href="http://seclists.org/bugtraq/2002/Jul/302有这样的解释" target="_blank" rel="external">http://seclists.org/bugtraq/2002/Jul/302有这样的解释</a></p>
<blockquote>
<p>This is a well knwon issue and C. Grenier and I have understood why<br>very recently. In fact, this due to the changing of the handling of<br>promiscuous mode in kernel space.</p>
<p>With kernel 2.0, one had to perform the following to set the interface<br>to promiscuous mode:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">strncpy</span>(ifr.ifr_name, <span class="string">"eth0"</span>, IFNAMSIZ);</div><div class="line">&gt; ioctl(sock, SIOCGIFFLAGS, &amp;ifr);</div><div class="line">&gt; ifr.ifr_flags |= IFF_PROMISC;</div><div class="line">&gt; ioctl(sock, SIOCSIFFLAGS, &amp;ifr);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The trouble was that the promiscuous mode was handled by a flag.  Each<br>time a process sets this mode, the flag is set. But if another process<br>removes this mode, the flag is cleared. Rather bad behavior.</p>
<p>Since kernel 2.2, a processus must ask to enter in a membership of<br>process (setsockopt(…, PACKET_ADD_MEMBERSHIP,…)) using the<br>interface in promiscuous mode. A counter is then increased. One a<br>process of the membership does not need the promiscuous mode anymore,<br>it drops the membership (setsockopt(…, PACKET_DROP_MEMBERSHIP, …))<br>the counter is decreased, and promiscuous mode is disabled as soon as<br>the counter is 0. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">struct</span> <span class="title">packet_mreq</span> <span class="title">mr</span>;</span></div><div class="line">&gt; ...</div><div class="line">&gt; <span class="built_in">memset</span>(mr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mr));</div><div class="line">&gt; mr.mr_ifindex = ifr.ifr_ifindex;</div><div class="line">&gt; mr.mr_type =  PACKET_MR_PROMISC;</div><div class="line">&gt; setsockopt(sock, SOL_PACKET, PACKET_ADD_MEMBERSHIP, (<span class="keyword">char</span> *)&amp;mr, <span class="keyword">sizeof</span>(mr));</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>The call to ioctl(SIOCGIFFLAGS) reports only promiscuous mode sets by<br>ioctl(SIOCSIFFLAGS).</p>
</blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://ieevee.com/tech/2016/11/24/promisc.html" target="_blank" rel="external">https://ieevee.com/tech/2016/11/24/promisc.html</a></li>
<li><a href="http://seclists.org/bugtraq/2002/Jul/302" target="_blank" rel="external">http://seclists.org/bugtraq/2002/Jul/302</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/CplusPrimerChapter9-mem-manage-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/CplusPrimerChapter9-mem-manage-note/" itemprop="url">C++内存模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-06T21:58:50+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/技术/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>C++ Primer Plus</em> 第九章的内存模型 笔记整理。—— Jiawei Xu 2019年3月6日</p>
<hr>
<p><strong>关键字：</strong>存储持续性、链接性、作用域、初始化、单定义规则、存储说明符（auto, register, static, extern, mutable, thread_local）、CV限定符（const, volatile）、名称修饰/矫正/C++语言链接性</p>
<h4 id="变量内存管理-存储持续性"><a href="#变量内存管理-存储持续性" class="headerlink" title="变量内存管理-存储持续性"></a>变量内存管理-存储持续性</h4><p>C++使用三种（在C++11中是四种）不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间。</p>
<ul>
<li><p><strong>自动存储持续性</strong>（栈）：</p>
<p>在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。它们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，它们的内存被释放。<strong>C++有两种存储持续性为自动的变量</strong>：局部变量和register关键字。</p>
</li>
<li><p><strong>静态存储持续性</strong>（全局变量/外部变量、static）：</p>
<p>在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为<strong>静态</strong>。它们在程序整个运行过程中都存在。</p>
<p><strong>C++有三种存储持续性为静态的变量</strong>，在整个程序执行期间存在，未被初始化的静态变量默认为0，静态数组和结果的每个元素和成员的所有位都置为0，这种变量被称为<strong>零初始化</strong>的(zero-initialized)：</p>
<ul>
<li><strong>外部链接性external linkage</strong>：可在其他文件中访问，格式：代码块外面声明</li>
<li><strong>内部链接性internal linkage</strong>：只能在当前文件中访问，格式：代码块外面声明+static限定符</li>
<li><strong>无连接性static linkage</strong>：只能在当前函数或代码块中访问，格式：代码块内声明+static限定符</li>
</ul>
</li>
<li><p><strong>动态存储持续性</strong>（堆/自由存储）：</p>
<p>用new运算符分配的内存将一直存在，直到使用delete运算符将其释放或程序结束为止。这种内存的持续性为动态，有时候被称为自由存储(free store)或堆(heap)。</p>
</li>
<li><p><strong>线程存储持续性</strong>（C++11、并行编程、thread_local）</p>
<p>如果变量使用关键字<strong>thread_local</strong>声明的，则其生命周期与所属的线程一样长，并行编程的内容。thread_local之于线程，犹如常规静态变量之于整个程序。</p>
</li>
</ul>
<h4 id="链接性（linkage）"><a href="#链接性（linkage）" class="headerlink" title="链接性（linkage）"></a>链接性（linkage）</h4><p>描述了名称如何在不同单元间共享。链接性在外部的名称可在文件间共享，链接性在内部的名称只能由一个文件中的函数共享。</p>
<h4 id="作用域（scope）"><a href="#作用域（scope）" class="headerlink" title="作用域（scope）"></a>作用域（scope）</h4><p>文件作用域（作用域为全局）：从定义位置到文件结尾之间可用。</p>
<p>局部作用域（自动变量，automatic variable）：局部。</p>
<p>静态变量的作用域：全局还是局部取决于如何被定义。</p>
<p>函数原型作用域(function prototype scope)中使用的名称只在包含参数列表的括号内可用。</p>
<p>类中声明的成员的作用域：整个类。</p>
<p>在名称空间中声明的变量的作用域为整个名称空间，全局作用域是名称空间作用域的特例。</p>
<h4 id="Auto"><a href="#Auto" class="headerlink" title="Auto"></a>Auto</h4><p>C和C++11之前，用于显式地指出变量为自动存储</p>
<p>C++11中，用于自动类型推断</p>
<h4 id="寄存器变量Register"><a href="#寄存器变量Register" class="headerlink" title="寄存器变量Register"></a>寄存器变量Register</h4><p>C和C++11之前，建议编译器使用CPU寄存器来存储自动变量，旨在提高访问变量的速度；</p>
<p>C++11中，用于显式地指出变量是自动的，作用域为代码块，在代码块中声明，无链接性。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li><p>静态初始化=零初始化+常量表达式初始化（sizeof运算符也包括）</p>
<p>在编译器处理文件时初始化</p>
</li>
<li><p>动态初始化：</p>
<p>在编译后初始化</p>
</li>
<li><p>C++新增关键字constexpr</p>
<p>创建常量表达式的方式</p>
</li>
</ul>
<h4 id="外部-全局变量的C-单定义规则-One-Definition-Rule-ODR"><a href="#外部-全局变量的C-单定义规则-One-Definition-Rule-ODR" class="headerlink" title="外部/全局变量的C++单定义规则(One Definition Rule, ODR)"></a>外部/全局变量的C++单定义规则(One Definition Rule, ODR)</h4><p><strong>外部变量</strong>：链接性为外部的变量，存储持续性为静态，作用域为整个文件。也称全局变量。</p>
<p>如果要在多个文件中使用外部变量，只需要在一个文件里包含定义，但是其他文件使用的时候都要用extern声明。</p>
<p>两种外部变量声明的方式：</p>
<ul>
<li><p>定义声明/定义defining declaring/definition（给变量分配存储空间）</p>
</li>
<li><p>引用申明/声明 referencing declaration/declaration（不给变量分配存储空间）</p>
<p>方法：在变量前面用<strong>关键字extern</strong>，且不进行初始化（两个条件都要满足，否则声明为定义，会分配存储空间）</p>
<p><strong>C++中的作用域解析运算符(::)</strong>：放在变量名前，该运算符表示使用变量的全局版本（更安全，不依赖于作用域）</p>
</li>
</ul>
<p>在多文件程序中，可以在一个文件（且只能在一个文件）定义一个外部变量，使用它的其他文件必须使用关键字extern声明它。</p>
<h4 id="存储说明符"><a href="#存储说明符" class="headerlink" title="存储说明符"></a>存储说明符</h4><ul>
<li>auto（C++11之后不再是说明符）</li>
<li>register</li>
<li>static</li>
<li>extern</li>
<li>thread_local（C++11新增）</li>
<li>mutable：即使结构（或类）变量为const，其某个成员也可以被修改，</li>
</ul>
<h4 id="CV-限定符"><a href="#CV-限定符" class="headerlink" title="CV-限定符"></a>CV-限定符</h4><ul>
<li>const：在C++中，const限定符对默认存储类型有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。<ul>
<li>在C++下，全局const定义就像是使用了static说明符一样。</li>
<li>可以使用extern关键字覆盖默认的内部链接性<code>extern const int states=50;</code>，鉴于单个const在多个文件间共享，因此只有一个文件可对其进行初始化。</li>
<li>在函数或代码块中声明const时，作用域为代码块。</li>
</ul>
</li>
<li>volatile：即使程序代码没有对内存单元进行修改，其值也可能发生变化。作用是为了改善编译器的优化能力。例如，假设编译器发现，程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到寄存器中。这种优化假设变量的值在这两次使用之间不会变化。如果不将变量声明为volatile。则编译器将进行这种优化；将变量声明为volatile，相当于告诉编译器不要进行这种优化。</li>
</ul>
<h4 id="函数链接性"><a href="#函数链接性" class="headerlink" title="函数链接性"></a>函数链接性</h4><ul>
<li><p>所有函数的存储持续性都自动为静态的。默认情况下，函数的链接性为外部的，可以在文件间共享。、</p>
</li>
<li><p>可以使用static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字。于是，可以在其他文件中定义同名的函数，和变量一样，在定义静态函数的文件中，静态函数将覆盖外部定义。</p>
</li>
<li>单定义规则也适用于非内联函数，对于每个非内联函数，程序只能包含一个定义。对于链接性为外部的函数来说，多文件程序中，只能有一个文件包含该函数的定义，但使用该函数的每个文件都应包含其函数原型。</li>
</ul>
<h4 id="C-查找函数定义的顺序"><a href="#C-查找函数定义的顺序" class="headerlink" title="C++查找函数定义的顺序"></a>C++查找函数定义的顺序</h4><ul>
<li>静态函数：本文件</li>
<li>所有程序文件-&gt;没找到的话，在库中搜索</li>
</ul>
<h4 id="名称矫正-名称修饰-C-语言链接"><a href="#名称矫正-名称修饰-C-语言链接" class="headerlink" title="名称矫正/名称修饰/C++语言链接"></a>名称矫正/名称修饰/C++语言链接</h4><p>在C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称，这种方法被称为C++语言链接（C++ language linkage）。方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot; void spiff(int)  //使用C语言链接性</div><div class="line">extern void spiff(int) 		//使用C++语言链接性</div><div class="line">extern &quot;C++&quot; void spiff(int) 		//使用C++语言链接性</div></pre></td></tr></table></figure>
<h4 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h4><p>含义：使用C++运算符new(或C函数malloc())分配的内存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/FreeFlow-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/FreeFlow-note/" itemprop="url">FreeFlow Software-based Virtual RDMA Networking for Containerized Clouds(NSDI 2019)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T20:29:43+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/科研论文笔记/" itemprop="url" rel="index">
                    <span itemprop="name">科研论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2019年2月25日所写，未经允许不得转载。</p>
<h3 id="概述-主要成果"><a href="#概述-主要成果" class="headerlink" title="概述-主要成果"></a>概述-主要成果</h3><ol>
<li>容器的优点：large-scale cloud applications, high resource efficiency, lightweight isolation。RDMA的优点：data-intensive applications, high networking performance, high throughput, low latency, low CPU utilization。</li>
<li>FreeFlow是一个software-based RDMA virtualization framework designed for containerized clouds.</li>
<li>FreeFlow满足云环境下的一些要求，例如多租户隔离，容器迁移的可移植性。</li>
<li>FreeFlow对应用透明，提供几乎裸金属RDMA的网络性能，同时CPU overhead不大。</li>
<li>Application代码修改很少 。FreeFlow在TensorFlow和Spark上测试，提供了和裸金属RDMA媲美的应用程序性能。</li>
<li>boost the performancee of real-world applications by up to 14.6 times more in throughput and about 98% lower in latency over using conventional TCP/IP virtual networking. </li>
<li>开源：<a href="https://github.com/Microsoft/Freeflow" target="_blank" rel="external">https://github.com/Microsoft/Freeflow</a></li>
</ol>
<h3 id="容器云的three-properties-in-networking"><a href="#容器云的three-properties-in-networking" class="headerlink" title="容器云的three properties in networking"></a>容器云的three properties in networking</h3><ol>
<li>Isolation：每个容器都有独立的网络命名空间，包括端口、流表、接口。</li>
<li>Portability：每个容器必须使用虚拟网络来和其他容器交互，它的虚拟IP是固定的，不管宿主机是哪个。 </li>
<li>Controllability：Orchestrators can easily enforce control plane policies 控制平面规则（比如访问控制admission control, routing）和data plane policies数据平面规则（比如QoS, metering计量），这个特性在多租户云环境尤其需要。</li>
</ol>
<p>In TCP/IP-based operations, network- ing is fully virtualized via a software (virtual) switch.</p>
<h3 id="解决问题时的Challenge"><a href="#解决问题时的Challenge" class="headerlink" title="解决问题时的Challenge"></a>解决问题时的Challenge</h3><p>很难完全虚拟化基于RDMA的网络传输。 </p>
<p>It is difficult to modify the control plane states (e.g., routes) in hardware in shared cloud environments, while it is also hard to control the data path since traffic directly goes between RAM and NIC via PCIe bus. 控制平面状态如路由等在硬件上难修改，数据平面流量走RAM和NIC。</p>
<h3 id="Goal-of-the-paper"><a href="#Goal-of-the-paper" class="headerlink" title="Goal of the paper"></a>Goal of the paper</h3><blockquote>
<p>We want cloudbased, containerized applications to be able to use RDMA as efficiently as they would in a dedicated bare-metal cluster; while at the same time achieving the isolation, portability and controllability requirements in containerized clouds.</p>
<p>The goal of FreeFlow is to <strong>provide an virtual interface inside</strong> <strong>each container</strong>, and applications can use RDMA via a virtual network on top of the virtual interface in an unmodified way.</p>
</blockquote>
<p>总结来说就是面向容器的基于软件的RDMA虚拟化 </p>
<h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>Currently, there is no mature RDMA virtualization solutions for containers. </p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic1.jpg" alt="RDMA networking solutions that can be potentially used for containers."></p>
<p><strong>现有工作的缺点：</strong> </p>
<ol>
<li><p><strong>基于硬件的I/0虚拟化技术</strong></p>
<blockquote>
<p>Hardware-based I/O virtualization techniques like <strong>SR-IOV</strong> have fundamental portability limitations, since they require reconfiguration of hardware NICs and switches to support migrations of containers. </p>
</blockquote>
</li>
<li><p><strong>控制路径虚拟化解决方案</strong></p>
<blockquote>
<p>Control path virtualization solutions, such as <strong>HyV</strong>, only manipulate the control plane commands for isolation and portability, and they do not have the visibility or control of the data traffic. Because of this, they cannot flexibly support data plane policies needed by cloud providers. </p>
</blockquote>
</li>
<li><p><strong>软件RDMA</strong></p>
<blockquote>
<p>Software-emulated RDMA, e.g., <strong>SoftRoCE</strong>, can easily achieve isolation, portability, and controllability by running RDMA on top of the UDP networking stack and use existing virtual IP networking solutions, but its performance will be limited by UDP. </p>
</blockquote>
</li>
</ol>
<h3 id="FreeFlow设计思路"><a href="#FreeFlow设计思路" class="headerlink" title="FreeFlow设计思路"></a>FreeFlow设计思路</h3><p><strong>技术核心：每个server上都有一个软件虚拟交换机，类似于TCP/IP的VSwitch</strong></p>
<blockquote>
<p>The software virtual switch has the full access to both control path (e.g., address, routing) and data path (e.g., data traffic) of the communications among containers. This design philosophy is similar to existing software virtual switches used for TCP/IP networking in the containerized cloud.</p>
</blockquote>
<p><strong>设计时考虑的两点：</strong> </p>
<ol>
<li><p><strong>透明性 (设计：应用程序和FreeFlow共享内存和文件描述符+尽量少修改应用程序的代码)</strong></p>
<blockquote>
<p><strong>We want FreeFlow to be completed transparent to applications</strong>.  If FreeFlow and a container share the same memory (x4.3) and file descriptor (x4.4), any operations on the underlying physical RDMA NIC will automatically take effect inside the container. </p>
<p><strong>A further problem is that sharing resources transparently to applications is not straightforward,</strong> given that applications do not cooperatively create resources that are shareable. Wedesign methods to convert resource from non-shareable to shareable with no or minimal modifications on application code.</p>
</blockquote>
</li>
<li><p><strong>性能要求（throughput：利用零拷贝，latency：CPU自旋的共享内存进程间channel+限制CPU开销）</strong></p>
<p>提供和裸金属RDMA媲美的吞吐和延迟，吞吐的瓶颈是内存拷贝，延时的瓶颈但是inter-process communication. </p>
</li>
</ol>
<p><strong>Evaluation tools:</strong> </p>
<ul>
<li>standard microbenchmarking tools</li>
<li>real-world data-intensive applications（without any or with minimal modification）<ul>
<li>Spark</li>
<li>TensorFlow</li>
</ul>
</li>
</ul>
<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><h4 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h4><ol>
<li><p>host mode networking</p>
<p>容器使用宿主机的IP和端口空间，像host OS里的原始进程一样通信。</p>
<p>poor isolation（e.g.,端口冲突）and portability（e.g.,迁移到另一个主机之后必须改IP和端口）</p>
</li>
<li><p>virtual mode networking </p>
<p>namespace完全隔离，容器之间通过overlay网络的软件vSwitch通信。Orchestrators可以完全控制容器迁移，可以实施控制平面和数据平面的策略。</p>
<blockquote>
<p>Indeed, orchestrators like <strong><em>Kubernetes</em></strong> mandate the use of virtual networking mode. A number of software solutions are available to provide virtual networking fabrics for containers, such as <strong><em>Weave</em></strong>, and <strong><em>Docker Overlay</em></strong>.</p>
</blockquote>
</li>
</ol>
<h4 id="Approach-to-virtualize-RDMA-network"><a href="#Approach-to-virtualize-RDMA-network" class="headerlink" title="Approach to virtualize RDMA network"></a>Approach to virtualize RDMA network</h4><blockquote>
<p>One possible approach：the NIC runs a simple layer-2 switch</p>
<p>Use hardware-based solutions such as SR-IOV. As an example shown in Figure 1(a), <strong>with SRIOV, the NIC runs a simple layer-2 switch that merely performs VLAN forwarding</strong>. Hence, all packets generated from and destined to a virtual network have to be directly routed in the underlying physical network. Thus, migrating container C1 to Host2 requires <strong>reconfiguring the physical switch</strong> to route C1’s packets to Host2 rather than Host1.  </p>
<p>缺点： 1) 影响可移植性，迁移需要重新并配置, 2) physical sw需要维护很大一张路由表 </p>
</blockquote>
<p><strong><em>The right approach to virtualizing RDMA network for containers：use a software switch – just like it is done for virtualizing traditional TCP/IP networking.</em></strong></p>
<p>虚拟化RDMA网络的方式使用软件sw，虚拟网络路由完全每个主机里的软件switches实现，physical network只负责把数据包发给不同的主机。软件sw可以提供好的隔离和控制平面的可移植性。也可以用来实现数据平面的网络功能比如QoS和metering计量。</p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic2.jpg" alt=""></p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic3.jpg" alt=""></p>
<ol>
<li><p><strong>software FreeFlow router也是一个主机上的容器</strong> </p>
<p>FreeFlow intercepts the communication between applications and physical NICs, and performs control plane and data plane policies inside the software FreeFlow router which runs as another container on the host machine. </p>
</li>
<li><p><strong>router和应用程序共享内存</strong></p>
<p>数据层面上，物理网卡访问router的内存，因为容器和router的内存是同一块物理内存，所以网卡能够直接访问应用程序的内存。</p>
</li>
</ol>
<h3 id="RDMA-API选择"><a href="#RDMA-API选择" class="headerlink" title="RDMA API选择"></a>RDMA API选择</h3><p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic5.png" alt=""></p>
<blockquote>
<p><strong>MPI</strong></p>
<p><strong>Message Passing Interface</strong> is a library specification that enables the development of paral- lel software libraries to utilize parallel computers, clusters, and heterogeneous networks. Mella- nox OFED includes the following MPI implementation over InfiniBand: </p>
<p>Open MPI – an open source MPI-2 implementation by the Open MPI Project </p>
<p>Mellanox OFED also includes MPI benchmark tests such as OSU BW/LAT, Intel MPI Bench- mark, and Presta. </p>
<p><strong>SDP</strong></p>
<p>为了充分利用 RDMA 提供的所有优势，需要使用 RDMA 语义或上层协议，比如 User-Level Direct Access Transport (uDAPL) 或 Message Passing Interface (MPI) 来编写应用程序。然而，对于 RDMA 来说，重写一个 TCP 应用程序可能非常昂贵，因此，针对这种情况开发了一个替代解决方案。该方法称之为 Direct Socket Protocol (SDP)，无需重新编码任何应用程序。</p>
<p>SDP 是一个连线协议，在 RDMA 能力的适配器和套接字之间使用。鉴于这个原因，SDP 对应用程序是透明的，而标准流套接字的实现不需要使用另一个 API 替换。DB2 应用程序和 DB2 服务器无需修改就可在 SDP 或 TCP 上运行。用户只需要在执行应用程序之前通过预加载 SDP 共享库来选择要使用的协议即可。所有关于 TCP 的设置，比如主机名、IP 地址和端口，均无需修改。</p>
<p>例如，一个使用 TCP 连接到数据库服务器的 Java 应用程序也可以使用相同 JDBC URL 在 SDP 上运行。该 SDP 库，一旦预加载之后，将根据一组在 <code>/etc/libsdp.conf</code> 中定义的规则，以及服务器接受的协议来决定必需启动哪个协议。默认规则指定 SDP 作为第一个选项，如果连接失败，SDP 库将退回到 TCP。</p>
<p>一个应用程序可以只使用 SDP，或者只使用 TCP，或者同时使用二者。例如，可以将一个应用程序配置为使用 SDP 实现 DB2 数据库连接以及使用 TCP 实现 LDAP 连接。数据库和 LDAP 服务器可以在不同的物理机器上运行，或者运行在相同的机器上但侦听不同的接口。本文稍后将讨论各种场景以及如何应用规则。</p>
<p><strong>rocket</strong></p>
<p>include <rdma rsocket.h=""></rdma></p>
<p>rsockets is a protocol over RDMA that supports a socket-level API for applications. rsocket APIs are intended to match the behavior of corresponding socket calls, except where noted. rsocket functions match the name and function signature of socket calls, with the exception that all function calls are prefixed with an ‘r’.</p>
<p><strong>iSER(iSCSI RDMA Protocol)</strong></p>
</blockquote>
<p><strong>FreeFlow选择IB Verb API（Verbs）</strong>： The Verbs library and associated drivers allow applications to read, write and monitor the three queues. Actual transfer of the data, including packetization and error recovery, is handled by the NIC. To transparently support Verbs, FreeFlow <strong>creates virtual QPs and CQs in virtual NICs</strong> and relates the operations on them with operations on real QPs and CQs in the physical NICs.</p>
<h4 id="具体架构设计"><a href="#具体架构设计" class="headerlink" title="具体架构设计"></a>具体架构设计</h4><p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic6.png" alt="FreeFlow Architecture"></p>
<ul>
<li><p>FreeFlow network library (FFL)</p>
</li>
<li><p>FreeFlow software router (FFR)</p>
</li>
<li><p>FreeFlow network orchestrator (FFO).</p>
</li>
</ul>
<p>There are various types of RDMA operations including one- and two-sided operations for data transfer, poll- and event-based mechanisms for work completion notification, and TCP/IP and RDMA-CM for the connection establishment.</p>
<p>关于RDMA： </p>
<ol>
<li><p>The Verbs library and associated drivers allow applications to read, write and <strong>monitor</strong> the three queues. Verb libs有监控工具 </p>
</li>
<li><p>Actual transfer of the data, including packetization and error recovery, is handled by the NIC. 网卡负责实际的传输，包括 packetization和错误恢复 </p>
</li>
</ol>
<p>one-sided operations such as WRITE and READ</p>
<p>two-sided operations such as SEND and RECV </p>
<p>为了透明支持Verbs，FreeFlow建了虚拟的QP和CP和物理网卡上的真实QP和CP关联. </p>
<p>Step1: 应用请求支持Verbs的网卡列表，FFL截获了call然后返回容器的虚拟网卡的文本数据。 </p>
<p>Step2: 应用在它的的虚拟网卡上创建QP和CQ，FFR在物理网卡上创建相应的队列（QP和CQ’）。等到FFR完成了队列的创建了之后，QP-IDs和其他元数据信息通过FFL转发给应用。 </p>
<p>Step3: 应用注册了一块内存mem给QP。 FFR分配了相应的的块内存s-mem在它的共享内存IPC空间，和mem的空间一样大，注册s-mem给QP’ </p>
<p>FFR返回了它使用来创造s-mem的ID（一个IPC内存的主机范围的唯一名称）。FFL用这个ID来将s-mem和自己的虚拟内存空间映射起来。 </p>
<p>Step4: 应用请求local QP地址（RDMA的GID）。地址信息将会和另一边共享  local QP和remote QP配对。这一步最后，FFR返回QP’的实际的GID。 </p>
<p>Step5: 应用和远程交换GID和QP-ID。交换信息的通道是TCP/IP或者RDMA-CM。 </p>
<p>Step6：应用使用接受端的GID把它的local QP和远程容器的QP匹配起来。 </p>
<p>Step7：应用修改了local QP的状态，修改为Ready 、Send/Receive state。FFR相应修改QP’的状态。 </p>
<p>One-sided Operation </p>
<ul>
<li>Client需要server 的GID、远程内存buffer的地址，访问内存的security key。 </li>
<li>有两个挑战： <ul>
<li>目标的内存地址mem在远程的容器的虚拟内存里面。但是本地的FFR不知道对应的另一半的s-mem。解决方案：FreeFlow在FFO中为每个FFR建立一个中心化的key-value存储，来学习应用虚拟内存空间和对应FFR虚拟内存空间的s-mem指针。 </li>
<li>远程FFR不知道什么时候把数据拷贝到应用内存里面 </li>
</ul>
</li>
<li>基于零拷贝的机制来支持one-side operation：使得mem和s-mem是一段相同的物理内存，这样FFR不需要做任何拷贝，应用可以直接得到数据 <ul>
<li>第一种方法：写新的API，ibv_malloc和ibv_free来让应用代理内存的创造和删除，缺点是需要改动app的data buffer creation的代码 </li>
<li>第二种方法：FFL截断malloc call。FFL释放va的物理内存然后指定一个FFR的物理共享内存给va，但是va必须是一个内存整页的开头，会降低host的内存利用率 </li>
<li>更推荐第一种方法 </li>
</ul>
</li>
</ul>
<p>Event-based Operations </p>
<p>从CQ中获得通知的方法： </p>
<ol>
<li>应用定期poll CQ看有没有完成的operation </li>
<li>event-based的方法，应用创建一个事件channel，将CQ放进channel中。channel包含一个文件描述符（当opeartion完成时会引发）。 </li>
</ol>
<p>在FreeFlow中，因为raw file descriptor是物理网卡创建的，FFR需要把文件描述符传给FFL，这里FFR和FFL是共享OS kernel的两个进程. </p>
<p>FFL和FFR之间的通信： </p>
<p><img src="https://icestrawberryxjwme-1255869739.cos.ap-shanghai.myqcloud.com/blogPic/2019-02-25-FreeFlow-note-Pic4.jpg" alt=""></p>
<p>低延时通信用FastPath： 用一个cpu core 自旋，数据平面无阻塞 </p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li><p>implement FFL by modifying <strong>libibverbs (v1.2.1), libmlx4 (v1.2.1) and librdmacm (v1.1.0)</strong>. </p>
</li>
<li><p>增加了4000 lines of C code to implement FreeFlow’s logic. </p>
</li>
<li><p>implemented FFR from scratch in about 2000 lines of C++ code.  </p>
</li>
<li><p>For FFO, use ZooKeeper to store the user defined information; e.g., IP assignment, access control, resource sharing policies, and memory mapping information for one-sided operations. </p>
</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><a href="https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1207rdmasocketdirect/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/data/library/techarticle/dm-1207rdmasocketdirect/</a></li>
<li><a href="https://linux.die.net/man/7/rsocket" target="_blank" rel="external">https://linux.die.net/man/7/rsocket</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/18/RoGUE-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="icestrawberryxjw">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="icestrawberryxjw">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/RoGUE-note/" itemprop="url">RoGUE_RDMA over Generic Unconverged Ethernet(SoCC'18)笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-18T10:49:21+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/科研论文笔记/" itemprop="url" rel="index">
                    <span itemprop="name">科研论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为 Jiawei Xu 于2018年11月15日所写，未经允许不得转载。</p>
<h3 id="1-问题描述和论文概括"><a href="#1-问题描述和论文概括" class="headerlink" title="1. 问题描述和论文概括"></a>1. 问题描述和论文概括</h3><p>RDMA为用户态提供了直接访问、在应用程序的buffer中传输数据的能力。RDMA旁路了开销较高的系统调用，在硬件上进行组包和包解析操作。允许单向操作，凭借一边的连接可以在硬件上完全处理而不需要主机软件的参与。因此RDMA相比于TCP/IP网络提高了端到端的时延和CPU占用。</p>
<p>RNIC：RDMA网卡</p>
<p>PFC：使用backpressure-based congestion control来给RDMA提供无损网络。PFC是的交换机或者主机当他们的buffer占用超过一定的阀值产生pause frame，然后让发送方节流。有了PFC之后，丢包只会发生在少见的bit损坏上，RNIC就可以用简单的硬件重传方案来恢复。</p>
<p>RoCE的优势：低延迟、低CPU利用率，场景：DC云基础设施服务。</p>
<p>目前RoCE、FPC的缺点：影响网络稳定性、复杂的网络管理、HOL Blocking问题、设备故障和不正确的路由可能导致整个网络死锁、Bufferbloat问题、unfair packet scheduling。</p>
<p>关于FPC问题的相关进展：</p>
<ol>
<li><p>DCQCN缓解了一部分风险，但是没有完全解决这些问题。</p>
</li>
<li><p>最近的研究关于数据中心拥塞控制，DCQCN，缓解了PFC被唤醒的频率。但是还是有问题：从其接收队列停止读取的慢速或恶意主机可以生成暂停帧并拒绝其他租户访问网络。</p>
</li>
<li><p>深入的监控通过识别是否有这样的问题会发生来解决这个问题，但是监控是有限的、不准确的、不能大规模部署。</p>
</li>
</ol>
<p>和SIGCOMM’18的思路一样：不去修复以上这些问题，而是去掉RoCE中的PFC，用新的拥塞控制和新的拥塞导致的丢包恢复方案代替。</p>
<p>该论文提出的RoGUE（RDMA over Generic Unconverged Ethernet)的理念和贡献：不需要依靠PFC。重新思考RDMA拥塞控制和恢复机制，寻找一种保持低延时低CPU优点、但是还能够容忍由于拥塞导致的丢包的方式。（从降低能耗角度），并且增加了UC的丢包恢复。</p>
<h3 id="2-设计难点和挑战"><a href="#2-设计难点和挑战" class="headerlink" title="2. 设计难点和挑战"></a>2. 设计难点和挑战</h3><p>那么问题来了，在哪里和如何实现所想要的（拥塞控制）功能？</p>
<table>
<thead>
<tr>
<th></th>
<th>想法一</th>
<th>想法二</th>
</tr>
</thead>
<tbody>
<tr>
<td>在哪里实现</td>
<td>完全用RNIC硬件实现</td>
<td>完全用软件实现</td>
</tr>
<tr>
<td>pros</td>
<td>1、管理者，特别是本地或者私有云的小规模，不能依靠RNIC提供商来推行硬件改变，因此他们需要了解传统RNIC；大的云比如google和Microsoft可以和提供商推广自定义的交换机网卡特性比如结合了拥塞控制的改进，但是对于企业小中型私有数据中心和云。他们就只能用不灵活的通用的硬件。2、刻在硬件上的方法不能处理交换机上非标准协议实现，也不能处理交换机功能的升级或者端系统拥塞控制协议；3、不利于各种算法的快速实现应用，不利于向下兼容和网络升级。数据中心拥塞控制是快速发展的，每年都有一些新的拥塞控制算法提出来。在硬件上实现拥塞控制算法会降低阻碍这些新算法的应用。4、现有的RNIC丢包恢复机制是设计用来在低错包的情况下工作的。当时PFC关掉时，在有新建连接的burst时流丢包严重，但是RNIC硬件机制恢复这些丢包时效率很低，它花几百毫秒来检测丢包然后恢复。</td>
<td>1、基于包层面的拥塞信号对软件是透明的，传统方案利用的拥塞信号例如丢包和ECN比特都是被RNIC接收，软件无法得到；2、无差别的使用软件驱动的控制（比如使用软件来调整数据包速度使其达到一个合适的速率，或者识别和恢复丢包）会严重破坏RDMA cpu和时延的效益；</td>
</tr>
<tr>
<td>cons</td>
<td>低时延、低CPU利用率、性能高</td>
<td>易于实现</td>
</tr>
</tbody>
</table>
<p>子结论一：需要平衡好硬件和软件的工作范围</p>
<p>RoGUE的实现方式：OpenFabrics Enterprise Distribution(OFED) 用户层面API之上一个中介层，它把RDMA的拥塞控制和丢包恢复功能提到了软件上，利用现有的硬件来协助软件加速性能。</p>
<h3 id="3-RoGUE设计"><a href="#3-RoGUE设计" class="headerlink" title="3. RoGUE设计"></a>3. RoGUE设计</h3><p><strong>软硬件具体分工：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>拥塞控制功能</th>
<th>丢包恢复功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>软件</td>
<td>1、拥塞控制逻辑（依靠时延来估计和响应拥塞，而不是用丢包和ECN bits。原因是：ECN标记只是表示网络拥塞，而时延表示RNIC和网络的拥塞。并且RNIC消耗ECN标记，使得它们对软件是透明的）；2、Segmentation；3、TCP Vegas算法来做拥塞响应调整拥塞窗口（RoGUE软件上使用一个拥塞窗口，结合硬件速率限制器来调整RNIC的数据包，用这两个方法一起保证稳定的拥塞控制行为）</td>
<td>当硬件重传无效的时候，响应慢就会影响吞吐率（burst流丢包），RoGUE使用一个软件上的shadow queue pair来进行重传</td>
</tr>
<tr>
<td>RNIC</td>
<td>1、高性能通信；2、精准时间戳；3、速率限制</td>
<td>当偶尔有丢包发生的时候，RoGUE首先依靠RNIC的硬件重传机制</td>
</tr>
</tbody>
</table>
<p>RoGUE在OFED用户层API上加了一层。把来自应用程序的一个很大的verb集合作为输入。</p>
<p><strong>RoGUE如何实现拥塞控制呢？</strong></p>
<ol>
<li><p>对输入数据进行segmentation</p>
</li>
<li><p>使用RTT和丢包来估算拥塞，用一个窗口来记录verbs</p>
</li>
<li><p>在硬件上进行速率限制来pace out packets</p>
</li>
</ol>
<hr>
<p><strong>为了提供低开销、高性能、拥塞控制和可靠性，需要解决以下问题</strong>：</p>
<p>Q1: 如何取segments的大小？</p>
<p>Q2: 拥塞如何估计和根据现有RNIC的能力和限制有效控制？</p>
<p>Q3: 如何适应不同的底层（RC vs UC）？</p>
<p>Q4: 对由拥塞导致的丢包如何恢复？</p>
<p><strong>A1:</strong></p>
<p>RDMA的一个主要优点是使用大segments并卸载分组化并解析到RNIC可以最大限度地减少CPU的参与和负载。 但是，大的segments还会降低来自网络的反馈的粒度，从而影响拥塞控制。</p>
<p>设计的两个重点考虑：segmentation（RoGUE传输的一个verb有多大）、signaling（RNIC通知软件一个verb完成的频率）。</p>
<p>解决方法：通过实验测试，考虑两个不同的网卡RNICs：10 Gbps ConnectX-3 Pro和100 Gbps ConnectX-4 RNIC，使用ib_read_bw OFED RDMA基准测试工具来做到线速使用不同大小的READs 用dstat工具来测量cpu利用率。此设计优先考虑CPU效率而不是更快的响应。<br>结论：综合考虑拥塞信号频率和CPU，Segmentation大小是64KB（10Gbps），256KB（100bps），每一个batch发送一次拥塞信号给软件层，这里batch就取segmentation的大小。</p>
<p>对于饥饿问题的考虑： RoGUE使用类似于TCP的拥塞窗口来避免过快地发送数据。 因此，在接收器确认先前的发送之前，不会发送新数据。 在高速网络上，拥塞窗口可能小到16KB。 当batch大小超过拥塞窗口时，如果只有一个批次入队，RNIC将会饿死，因为RoGUE在从下一batch中放进队列verbs之前等待先前batch完成的信号，并且直到最后一个数据包发送一个RTT之后才接收到这些信号。为了避免饥饿，RoGUE因此确保在仍有应用程序数据要发送时<strong>至少有2个batch入队</strong>。</p>
<p><strong>A2：</strong></p>
<p>为了控制发送速率，RoGUE依靠（1）基于RTT的拥塞控制窗口（2）硬件限速</p>
<p>因为丢包信号软件不能很快得到，所以用时延作为拥塞信号。使用了一个拥塞窗口，限制了数据包的总数，允许RoGUE ack计时一个batch中的数据包避免拥塞崩溃。但是一个segments中传输的包都以线速传输，因此RoGUE暂时可能会产生一个burst导致丢包，所以RoGUE设置了硬件限速器。综合以上来控制发送速率。</p>
<p>RTT测量方法：跟论文Timely中的一样，对于RC来说，第i个verb的RTT=收到ack的时间戳-开始传输时间戳（=max{入队时间，上一个verb收到ack的时间戳}）-传输时延（=verb的字节数/限速器的配置设置速率）</p>
<p>拥塞窗口调整方法：TCP Vegas（加性增，加性减），简单来说就是在每个batch的最后，用上面得到的当前RTT用来估计预期和实际拥塞窗口的差。</p>
<p><strong>A3：</strong></p>
<p>特定传输设计</p>
<p>RoGUE is the first approach to offer congestion control for the UC transport type. </p>
<p>支持UC传输类型非常重要，因为最近的工作表明它比RC更具可扩展性，因为UC流量可能会影响其他拥塞控制的流量，如RC或TCP流量。</p>
<ul>
<li>RC传输：对于RC上的WRITE和SEND动词，RoGUE严格遵循上述设计。 RC中的主要问题是由READ动词引起的。 首先，保持拥塞窗口是复杂的，因为在相反方向上引起WRITE和READ的拥塞。 为了克服这个问题，RoGUE为单个RC QP维护独立的READ和WRITE拥塞窗口。 其次，READ需要在远程主机上设置速率限制。 RoGUE使用一个接收器端库，该接收器端异步地将限制应用于QP，并在每次更改时使用READ速率限制将WRITE_IMM发送到远程主机。</li>
<li>UC传输：与RC传输不同，RNIC不在UC传输中生成ACK。 因此，不可能立即使用信号来计算网络RTT。 UC传输中的信号仅指示消息已在网络上发送，而不是已由远程RNIC确认。计算RTT的时候完成时间就是一个Verb中最后一个包发送的时间，这篇论文忽略这个误差。</li>
<li>不处理RD传输</li>
</ul>
<p>RoGUE必须能够在UC传输中的RTT测量期间处理分组丢失。 在批次i的测量之前到达的批次j &gt; i的RTT测量被解释为批次i中的分组丢失，并且拥塞窗口积性减小。 当所有未完成的RTT测量都被丢弃时，RoGUE使用超时来重试RTT的采样。 超时后，RoGUE将拥塞窗口重置为其初始大小，并且在成功对RTT进行采样之前不会将新批次排入队列。</p>
<p><strong>A4:</strong></p>
<p>当QP发生error state，使用shadow QP mechanism</p>
<h3 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h3><p>32台servers，用10Gbps的RNIC相连。</p>
<ol>
<li>测量CPU利用率。同时使用QP或TCP流来驱动测试平台中两台机器之间的线速流量（“客户端”发送到“服务器”），比较DCTCP、RoCE和RoGUE、RC和UC传输类型、比较 READ 和WRITE verb的情况。 对于READ，服务器将数据发送到客户端。 我们使用dstat来测量客户端和服务器上每10秒（平均5次运行）的CPU利用率。并且还对DCTCP先进行了优化。</li>
<li>从一个长时间运行的流开始，单独发送，然后添加/删除最多4个额外的流，一次一个。 测量10Gbps网络中RoGUE平均1s间隔的所有五个流的瞬时吞吐量，以及40Gbps网络中RoGUE模拟器的0.1s间隔的瞬时吞吐量。</li>
</ol>
<h3 id="5-实验结果和结论"><a href="#5-实验结果和结论" class="headerlink" title="5. 实验结果和结论"></a>5. 实验结果和结论</h3><p>角度是低能耗（低CPU）+去PFC，对性能的要求是较RoCE持平</p>
<p>没有讨论实现上的开销；忽略了UC的RTT测量时延</p>
<h3 id="最后：背景知识"><a href="#最后：背景知识" class="headerlink" title="最后：背景知识"></a>最后：背景知识</h3><p>使用RDMA，用户空间应用程序调用内核来分配NIC队列，然后建立与远程计算机的连接。 应用程序使用客户端库直接与RNIC连接，以将RDMA verbs发送到队列。</p>
<p>最常用的verb是READ，WRITE，SEND和RECV。 READ从远程主机的内存中获取数据，WRITE将数据传输到远程主机的内存中。 READ和WRITE被认为是“单方面的”，因为它们只需要发送端的主机活动：接收方的RNIC在没有软件参与的情况下处理请求。SEND是“双面的”：它们将消息传送到远程主机，其中软件将RECV verbs排入队列以接收消息。 verbs中的数据大小通常可达2GB。 WRITE_WITH_IMM和SEND_WITH_IMM是WRITE和SEND的变体，它们携带额外的4字节的立即数据，可由远程主机上的软件读取。</p>
<p>READ，WRITE和SEND被发布到发送队列。 RNIC还在建立连接时创建接收队列。 对于READ和WRITE，不需要接收队列，而对于SEND，软件必须将相应的RECV发布给它们。 所有发送和接收队列都配对，每个队列对（QP）与完成队列相关联，该完成队列表示事件完成并提供即时数据。 用户空间应用程序可以使用中断或轮询完成队列。</p>
<p>RDMA支持三种传输类型：可靠连接（RC），不可靠连接（UC）和不可靠数据报（UD）。 所有传输都支持SEND / RECV，因为它们的要求最低。 RC和UC支持WRITE，但只有RC支持READ。 在RC中，RNIC负责丢失后的重传。 相反，UC和UD中的RNIC忽略了数据包丢弃。 RNIC可以通过事件对verb的完成申请发出信号。 如果在verb完成时不需要通知应用程序，则它可以禁用信号，这会降低CPU利用率。</p>
<p>RC的workflow：</p>
<p>1、发送端主机软件将verb放进队列</p>
<p>2、发送端RNIC使用DMA从主机内存中获取要写入的数据，并通过网络以一个或多个数据包发送数据。</p>
<p>4、接收端RNIC把数据写入内存，等到收到最后一个包了之后，就发回一个ACK，发送的RNIC接收ACK</p>
<p>6、发送端选择性产生一个信号通知应用程序WRITE完成了</p>
<p>UC verb类似，除了接收端不会有ack并且信号是当verb最后一个包发送的时候会发出而不是收到ack的时候。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol>
<li><em>RoGUE: RDMA over Generic Unconverged Ethernet</em>, Yanfang Le (UW-Madison), Brent Stephens (UW-Madison), Arjun Singhvi (UW-Madison), Aditya Akella (UW-Madison), Michael Swift (UW-Madison), <em>SoCC‘18</em></li>
<li><em>Revisiting Network Support for RDMA</em>, Radhika Mittal (Berkeley, USA), Alexander Shpiner (Mellanox, Israel), Aurojit Panda (ICSI and NYU, USA), Eitan Zahavi (Mellanox, Israel), Arvind Krishnamurthy (UW, USA), Sylvia Ratnasamy (Berkeley, USA), Scott Shenker (ICSI and Berkeley, USA), <em>SIGCOMM‘18</em></li>
<li><p><a href="https://dl.acm.org/citation.cfm?doid=190314.190317" target="_blank" rel="external">TCP Vegas Algorithm</a></p>
</li>
<li><p><a href="https://conferences.sigcomm.org/sigcomm/2015/pdf/papers/p537.pdf" target="_blank" rel="external"><em>TIMELY: RTT-based Congestion Control for the Datacenter</em></a>, Radhika Mittal(UC Berkeley), Vinh The Lam, Nandita Dukkipati, Emily Blem, Hassan Wassel,Monia Ghobadi(Microsoft), Amin Vahdat, Yaogong Wang, David Wetherall, David Zats, <em>SIGCOMM’2015</em></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">icestrawberryxjw</p>
              <p class="site-description motion-element" itemprop="description">The most difficult thing is the decision to act, the rest is merely tenacity.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/icestrawberryxjw" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">icestrawberryxjw</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
